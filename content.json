{"meta":{"title":"JavaGuy的博客","subtitle":"Step by step, just Right!","description":"华中科技大学 | 计算机科学与技术 | 分布式云数据库内核","author":"JavaGuy","url":"https://javaguycoffee.com","root":"/"},"pages":[{"title":"404","date":"2019-07-19T08:41:10.000Z","updated":"2022-07-21T03:51:31.812Z","comments":true,"path":"404.html","permalink":"https://javaguycoffee.com/404.html","excerpt":"","text":""},{"title":"","date":"2022-07-21T03:51:31.999Z","updated":"2022-07-21T03:51:31.999Z","comments":true,"path":"baidu_verify_code-r7CYm21B6o.html","permalink":"https://javaguycoffee.com/baidu_verify_code-r7CYm21B6o.html","excerpt":"","text":"84f2b1be0ccbd3455ac89f1e13806971"},{"title":"about","date":"2019-07-19T08:41:10.000Z","updated":"2022-07-21T03:51:31.996Z","comments":true,"path":"about/index.html","permalink":"https://javaguycoffee.com/about/index.html","excerpt":"","text":"教育背景 硕士 华中科技大学 计算机科学与技术2020/07 - 至今 本科 深圳大学 计算机科学与技术/信息与计算科学双专业2016/09 - 2020/06 研究方向主要研究MySQL InnoDB内核，分布式MA系统等方向，对JavaEE, 算法等方向也感兴趣。 联系方式 电子邮箱&#122;&#x68;&#97;&#x6e;&#x67;&#49;&#x38;&#x34;&#50;&#x32;&#x37;&#57;&#x33;&#x38;&#48;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;&#49;&#x38;&#x34;&#x32;&#x32;&#55;&#x39;&#x33;&#56;&#48;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d; 地址华中科技大学南一楼多媒体与数据库所 微信JavaGuy15338759541"},{"title":"categories","date":"2019-07-19T08:39:20.000Z","updated":"2022-07-21T03:51:32.000Z","comments":true,"path":"categories/index.html","permalink":"https://javaguycoffee.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-07-19T08:39:20.000Z","updated":"2022-07-21T03:51:31.997Z","comments":true,"path":"archives/index.html","permalink":"https://javaguycoffee.com/archives/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-19T08:42:10.000Z","updated":"2022-07-21T03:51:32.004Z","comments":true,"path":"friends/index.html","permalink":"https://javaguycoffee.com/friends/index.html","excerpt":"","text":"友链交换想要交换友链的小伙伴，欢迎在留言板留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：JavaGuy 地址：https://javaguycoffee.com/ 简介：专注于分布式MA系统和Java精进 头像：https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/20210319162111.png?versionId=CAEQEBiBgMCT.6WmwhciIDcwNGI5NTQ1NTk3MDQxNzlhNjRmZTU5YzhhYWU1OTBj"},{"title":"contact","date":"2019-07-26T09:17:02.000Z","updated":"2022-07-21T03:51:32.002Z","comments":true,"path":"contact/index.html","permalink":"https://javaguycoffee.com/contact/index.html","excerpt":"","text":"欢迎留言大家有任何问题，都可以在评论区给我留言，大家一起交流学习进步~ 友链交换想要交换友链的小伙伴，欢迎在评论区留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：JavaGuy 地址：https://javaguycoffee.com/ 简介：专注于分布式MA系统和Java精进 头像：https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/20210319162111.png?versionId=CAEQEBiBgMCT.6WmwhciIDcwNGI5NTQ1NTk3MDQxNzlhNjRmZTU5YzhhYWU1OTBj"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-07-21T03:51:32.005Z","comments":true,"path":"tags/index.html","permalink":"https://javaguycoffee.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leveldb学习","slug":"leveldb学习","date":"2022-07-21T03:55:36.000Z","updated":"2022-07-21T10:12:53.871Z","comments":true,"path":"2022/07/21/leveldb-xue-xi/","link":"","permalink":"https://javaguycoffee.com/2022/07/21/leveldb-xue-xi/","excerpt":"","text":"1、简介Google开发的一个高性能的KV数据库，提供自定义key排序。 1.1、功能 key和value是任意的字节数组 数据根据key排序进行存储，用户可以自定义排序 有Put(key, value), Get(key), Delete(key)三个基本操作 支持原子修改、数据快照、数据压缩 支持正向和逆向遍历数据 1.2、基本操作 打开数据库 每个leveldb数据库都有一个相关的文件系统目录，所有数据存放在该目录下。 #include &lt;cassert> #include \"leveldb/db.h\" leveldb::DB* db; leveldb::Options options; options.create_if_missing = true; options.error_if_exists = true; //捕捉数据库存在error leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db); assert(status.ok()); ... Status 可以打印函数调用返回的错误信息 leveldb::Status s = ...; if (!s.ok()) cerr &lt;&lt; s.ToString() &lt;&lt; endl; 关闭数据库 ... open the db as described above ... ... do something with db ... delete db; 基本读写操作 比如移动key1的值到key2 std::string value; leveldb::Status s = db->Get(leveldb::ReadOptions(), key1, &amp;value); if (s.ok()) s = db->Put(leveldb::WriteOptions(), key2, value); if (s.ok()) s = db->Delete(leveldb::WriteOptions(), key1); 原子更新 比如上面第二步未完成，进程挂掉了，这样数据就会在两个key里面都丢失了。 #include \"leveldb/write_batch.h\" ... std::string value; leveldb::Status s = db->Get(leveldb::ReadOptions(), key1, &amp;value); if (s.ok()) { leveldb::WriteBatch batch; batch.Delete(key1); batch.Put(key2, value); s = db->Write(leveldb::WriteOptions(), &amp;batch); } 同步写 默认leveldb写是异步的，但是leveldb也是支持同步写的。 leveldb::WriteOptions write_options; write_options.sync = true; db->Put(write_options, ...); 一般来说，异步写性能要比同步写高出几千倍，但是异步写缺点是当进程挂掉时，最后几次update会丢失，但是同步写不会。这并不能说异步写不安全，因为有崩溃恢复机制（同步写来维护checkpoint）来保证安全。 并发 在一个进程里，同一个leveldb::DB对象可以被多个线程安全并发地共享，Iterator对象、WriteBatch对象用户必须自己同步。 迭代器 遍历数据库里所有数据 leveldb::Iterator* it = db->NewIterator(leveldb::ReadOptions()); for (it->SeekToFirst(); it->Valid(); it->Next()) { cout &lt;&lt; it->key().ToString() &lt;&lt; \": \" &lt;&lt; it->value().ToString() &lt;&lt; endl; } assert(it->status().ok()); // Check for any errors found during the scan delete it; 遍历在[start, limit)范围内的数据 for (it->Seek(start); it->Valid() &amp;&amp; it->key().ToString() &lt; limit; it->Next()) { ... } 逆向遍历数据 for (it->SeekToLast(); it->Valid(); it->Prev()) { ... } 数据快照 ​ 对数据库的某个状态进行快照，使用ReadOptions::snapshot来维护，非空表示存在快照，读操作则作用于该快照，为空的话，作用于当前状态。 leveldb::ReadOptions options; options.snapshot = db->GetSnapshot(); ... apply some updates to db ... leveldb::Iterator* iter = db->NewIterator(options); ... read using iter to view the state when the snapshot was created ... delete iter; db->ReleaseSnapshot(options.snapshot); Slice Slice是一个包含length和指向字节数组指针的数据结构，返回Slice数据结构比std::string更节省空间，上面的it-&gt;key()和it-&gt;value()都是Slice数据类型。 字符串可以很容易转为Slice类型。 leveldb::Slice s1 = \"hello\"; std::string str(\"world\"); leveldb::Slice s2 = str; Slice转为c++字符串 std::string str = s1.ToString(); assert(str == std::string(\"hello\")); 比较器 默认根据key按字典序排列，也可定义自己的比较器，需要继承 leveldb::Comparator Block Size 默认是4096字节，可以更改。 数据压缩 默认开启，因为默认压缩算法非常快；同时也可以禁用压缩 leveldb::Options options; options.compression = leveldb::kNoCompression; ... leveldb::DB::Open(options, name, ...) .... Cache 主要用来缓存非压缩数据，压缩数据缓存由操作系统缓存或者客户端负责 #include \"leveldb/cache.h\" leveldb::Options options; options.block_cache = leveldb::NewLRUCache(100 * 1048576); // 100MB cache leveldb::DB* db; leveldb::DB::Open(options, name, &amp;db); ... use the db ... delete db delete options.block_cache; 进行批量读取时，需要关闭缓存，可以这样实现： leveldb::ReadOptions options; options.fill_cache = false; leveldb::Iterator* it = db->NewIterator(options); for (it->SeekToFirst(); it->Valid(); it->Next()) { ... } delete it; Key Layout 因为相邻的keys会被放在同一个block里，可以将经常一起访问的数据块key放置相邻，不常访问的数据块放在一个独立的region里。 假如在leveldb里实现一个简单的文件系统，可能要存储以下数据 filename -> permission-bits, length, list of file_block_ids file_block_id -> data 过滤器 可以减少Get()方法获取数据实际访问磁盘的数量。 leveldb::Options options; options.filter_policy = NewBloomFilterPolicy(10); leveldb::DB* db; leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db); ... use the database ... delete db; delete options.filter_policy; 推荐使用布隆过滤器，那些不适合放在内存中或者随机读比较频繁的推荐使用过滤器。 如果自定义了比较器，过滤器也需要自定义。 class CustomFilterPolicy : public leveldb::FilterPolicy { private: leveldb::FilterPolicy* builtin_policy_; public: CustomFilterPolicy() : builtin_policy_(leveldb::NewBloomFilterPolicy(10)) {} ~CustomFilterPolicy() { delete builtin_policy_; } const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; } void CreateFilter(const leveldb::Slice* keys, int n, std::string* dst) const { // Use builtin bloom filter code after removing trailing spaces std::vector&lt;leveldb::Slice> trimmed(n); for (int i = 0; i &lt; n; i++) { trimmed[i] = RemoveTrailingSpaces(keys[i]); } builtin_policy_->CreateFilter(trimmed.data(), n, dst); } }; Checksums leveldb给所有存储在文件系统里的数据关联Checksums，有以下两个控件来控制Checksums的验证。 ReadOptions::verify_checksums：当进行特殊读时，verify_checksums`设置为true来对所有读取的数据进行校验；默认情况下设为false。 Options::paranoid_checks：一旦检测到内部崩溃，设置为true，让数据库捕捉error 如果数据库崩溃了，leveldb::RepairDB函数用来尽可能恢复数据。 Approximate Size GetApproximateSizes方法可以用来估算某几个key range占用文件系统空间大小。 leveldb::Range ranges[2]; ranges[0] = leveldb::Range(\"a\", \"c\"); ranges[1] = leveldb::Range(\"x\", \"z\"); uint64_t sizes[2]; db->GetApproximateSizes(ranges, 2, sizes); Environment leveldb实现的所有文件操作（系统调用）都在leveldb::Env对象里进行了定义，也可以继承该对象进行功能扩展。 class SlowEnv : public leveldb::Env { ... implementation of the Env interface ... }; SlowEnv env; leveldb::Options options; options.env = &amp;env; Status s = leveldb::DB::Open(options, ...); 移植 可以参考leveldb/port/port.h、leveldb/port/port_example.h和leveldb/util/env_posix.h 1.3 、实现和BigTable类似，但是文件组织方式不同，有以下几种不同的文件类型。 Log files(.log) 存储对数据库最近的更新操作，在内存中以memtable形式存在，每次读取数据都要将磁盘中数据更新到memtable，确保读到最新数据。当log数据超过4MB时，将其转化为Sorted tables，创建一个新的log文件。 Sorted tables(.ldb) 包括level-0， level-N（N&gt;=1)，其中level-0包含重复的key，level-N不包含。 Manifest 该文件列出了所有level的Sorted tables，相应的key range，其他元数据 Current 包含最新的Manifest文件的名字 Info logs Compactions​","categories":[],"tags":[]},{"title":"Linux系统基本结构学习","slug":"Linux系统基本结构学习","date":"2021-03-22T03:48:05.000Z","updated":"2022-07-21T03:51:31.871Z","comments":true,"path":"2021/03/22/linux-xi-tong-ji-ben-jie-gou-xue-xi/","link":"","permalink":"https://javaguycoffee.com/2021/03/22/linux-xi-tong-ji-ben-jie-gou-xue-xi/","excerpt":"","text":"1、系统与硬件1.1、Linux硬件资源管理1.1.1、查看系统PCI设备lspci命令可以列出所有PCI设备，如主板、声卡、显卡、网卡、USB接口设备等 lspci 下面我们来分析下上面的输出结果 00:00.0 Host bridge: Intel Corporation 440BX/ZX/DX - 82443BX/ZX/DX Host bridge (rev 01) 上面显示集成主板类型是：Intel Corporation 440BX/ZX/DX 00:0f.0 VGA compatible controller: VMware SVGA II Adapter 上面显示VGA显卡设备是：VMware SVGA II Adapter 02:00.0 USB controller: VMware USB1.1 UHCI Controller 02:02.0 USB controller: VMware USB2 EHCI Controller 上面显示了两个USB设备 02:01.0 Ethernet controller: Intel Corporation 82545EM Gigabit Ethernet Controller (Copper) (rev 01) 上面显示的是千兆网卡设备 此外 lspci -v命令能看到更详细的PCI设备信息 lspci -v 1.1.2、查看CPU信息more /proc/cpuinfo 各参数含义说明如下表 参数名 含义 processor 逻辑处理器的唯一标识符 vendor_id 处理器类型，GenuineIntel代表是Intel处理器 physical id 每个物理封装的唯一标识符，也就是一个物理CPU siblings 位于相同物理封装中的逻辑处理器的数量 core id 每个内核的唯一标识符 cpu cores 位于相同物理封装中的内核数量 如果siblings等于cpu cores，那么说明系统不支持超线程，或者超线程未打开；如果siblings是cpu cores的两倍，则说明系统支持超线程。 查看系统物理CPU的数量： cat /proc/cpuinfo | grep \"physical id\" | sort | uniq | wc -l 查看每个物理CPU中内核的个数： cat /proc/cpuinfo | grep \"cpu cores\" 查看系统所有逻辑CPU个数（所有物理CPU中内核个数+超线程个数） cat /proc/cpuinfo | grep \"processor\" | wc -l 由以上结果可知，我本人的CentOS7系统有2个物理CPU，每个物理CPU中有2个内核，并且没有启动超线程，总共有4个逻辑CPU。 这和我个人设置的配置完全吻合 1.1.3、查看系统内存信息cat /proc/meminfo 由以上信息可知，系统目前物理内存MemTotal大约为5.3G，可用物理内存MemFree大约为2.7G，缓冲区Buffers占用了1772KB，缓存Cached占用了约1.5G 1.1.4、查看磁盘分区信息fdisk -l 通过以上输出可知，该系统一共有一个107.4G的磁盘，划分了三个分区，分别是centos-root，centos-swap，centos-home 1.2、Linux外在设备的使用有时候我们需要使用软盘，U盘，光驱，磁带等外在设备，这需要挂载才能使用。 1.2.1、硬件与设备文件在Linux系统下， 硬件设备都是以文件方式存在，不同硬件设备有不同的文件类型，我们把硬件与系统下相对应的文件称为设备文件。设备文件存放在 /dev下面，命名方式是主设备号（设备类型）+次设备号（具体哪一个设备） 软盘在Linux下对应设备文件是/dev/fdx，fd是主设备号，次设备号x是软盘驱动器相应的编号。如/dev/fd0就表示系统中第一个软盘驱动器。 U盘在Linux下对应设备文件是/dev/sdax，主设备号sd表示SCSI disk，a表示第一块SCSI设备；b表示第二块，其设备文件是/dev/sdb；以此类推。x表示SCSI设备的相应分区编号。如：/dev/sda1表示第一块SCSI设备的第一个分区。 IDE光驱在Linux下对应的设备文件是/dev/had，表示在第一个IDE口（Master）的IDE光驱；SCSI光驱在Linux下对应的设备文件为/dev/srx，x表示SCSI ID;很多Linux发行版还有一个/dev/cdrom设备文件，它是一个指向光驱的符号链接。 磁带驱动器对应设备文件是/dev/stx，st代表SCSI tape，x是磁带驱动器的编号。系统第一个磁带驱动器设备文件为/dev/st0，以此类推。 1.2.2、常见文件系统类型​ 文件系统格式 备注 msdos DOS文件系统类型 vfat Windows文件系统类型 ISO9660 光盘格式文件系统类型类型 ext2/ext3/ext4 Linux下主流文件系统类型 xfs Linux下一种高性能日志文件系统，在CentOS7.x版本是默认文件系统 了解了设备文件与对应的文件系统类型后，我们就能在Linux下挂载使用这些设备了。 1.2.3、设备的挂载使用Linux下的挂载命令是mount，格式如下： mount -t 文件系统类型 设备名 挂载点 将设备指定到这个挂载目录之后，以后访问这个目录就相当于访问这个设备了。 Linux系统有一个/mnt目录，专门用作临时挂载点（Mount Point）目录，主要用于系统管理员临时挂载一些媒体设备。此外，Linux还有一个/media目录，主要用于自动挂载U盘，光盘。在CentOS7中新出现了一个/run目录，现在所有的移动设备都会自动挂载到这个目录下。 1.2.3.1、挂载软盘mount -t msdos /dev/fd0 /mnt/floppy 这个命令把一个DOS文件格式的软盘挂载在/mnt/floppy目录下 1.2.3.2、挂载U盘首先通过下面命令查看U盘设备名以及是否挂载 df -h 然后建立挂载点 mkdir /mnt/usb 最后，进行挂载 mount -t xfs /dev/sda1 /mnt/usb 这样我们就能通过/mnt/usb目录来访问sda1里面的内容了 1.2.3.3、挂载光盘mount -t iso9660 /dev/hda /mnt/cdrom 注意使用mount挂载的软盘，光盘，U盘，而非软驱（软盘驱动器），光驱，因此，我们需要挂载另外一个软盘，光盘时，需要先卸载，然后重新挂载。 2、文件系统结构介绍2.1、目录结构2.1.1、经典树形结构典型的树形结构，root目录下有dev，bin，home，usr，var，boot等目录，var下有log，run等目录 Linux系统是一种一切皆文件的操作系统，整个系统以文件的形式存放在根目录下，分层分级组织在一起，形成了一个树形目录结构。 2.1.2、目录功能介绍2.1.2.1、/etc目录主要用于存放系统管理相关的配置文件和其子目录。 文件或目录 主要作用 passwd 用户库文件，存放每个用户的用户名，UID，GID和工作目录 shadow 存放用户加密后的密码文件 group 存放用户组信息 fstab 系统开机启动自动挂载分区列表 systemd 配置文件目录，是CentOS7.x新增目录，Linux系统启动用来对整个系统进行初始化配置 hosts 设定用户的IP和名字对应表，类似Windows系统的hosts文件 resolv.conf 客户端DNS配置文件 sysconfig/network-scripts/ifcfg-xxx IP地址配置文件 X11 X-Windows配置文件 rsyslog.conf 系统日志输出配置文件 sysctl.conf 系统内核参数配置文件，CentOS7.x移到了/usr/lib/sysctl.d目录下，但该配置文件依然存在，并且有效 services 定义系统服务与端口的对应关系 profile 系统全局环境变量配置文件 2.1.2.2、/usr目录主要存放应用程序和文件。此目录空间最大，默认软件包会安装在此目录下。 文件或目录 主要作用 lib64和local/lib64 64位操作系统的函数库目录 src 包含所有程序源代码，主要是Linux核心程序源代码 local 主要存放本地安装的软件和其他文件 bin和local/bin 使用者可执行的二进制文件目录 lib和local/lib 32位操作系统的函数库目录 sbin和local/sbin 存放系统管理员才能执行的命令 include 包含C语言的头文件，扩展名大多是.h share 存放共享文件和数据库 2.1.2.3、/var目录主要存放系统运行和软件运行的日志信息 文件或目录 主要作用 log 存放各种应用程序的日志文件，需要定期清理 lib 存放系统正常运行时需要改变的库文件 spool 是mail，new，打印机队列和其他队列的输入，输出的缓冲目录 tmp 该目录可以比/tmp存放更大的文件 lock 存放被锁定的文件 local 存放/usr/local中所安装程序的可变数据 account 存放已经格式化的man页 run 包含到下次系统启动前的系统信息 2.1.2.4、/dev目录包含系统所有的设备文件 设备名 具体含义 fd* 软盘设备 audio* 声卡设备 hd* IDE硬盘设备 sd* SCSI设备，sda代表第一块SCSI硬盘 lp* 并行串口 pty* 网络中登录的远程终端设备 ram* 系统内存 tty* 虚拟/字符控制台，我的CentOS7.x系统上有64个tty*文件 ttyS* 串行端口，类似Windows下的COM* console 系统控制台，即桌面控制台 null 输出空设备 2.1.2.5、/proc目录虚拟目录，存在于内存中，里面所有信息都是内存的映射，可以获取进程的有用信息，也可以在系统运行中修改内核参数。 文件或目录 说明 cpuinfo 系统CPU的有关信息，包括CPU名称，型号，类型等 meminfo 内存信息，包括物理内存和虚拟内存 filesystems 当前系统支持的文件系统类型 devices 内核中的设备驱动程序列表 net 网络使用协议及状态信息 dma 当前使用的dma通道 ioports 当前使用的IO端口 modules 当前系统加载的内核模块信息 stat 系统的各种状态信息 uptime 系统总的启动时间和空闲时间，以秒为单位 version 内核版本信息 loadavg 系统平均负载 kcore 系统物理内存的映像 kmsg 内核输出信息，同时输出到rsyslog 2.1.2.6、/boot目录存放启动Linux的一些核心文件，包含一些镜像文件和链接文件，如果遭到破坏，系统将无法启动。 2.1.2.7、/bin和/sbin目录都是存放可执行的二进制文件 /bin存放我们经常使用的Linux命令，如文件操作命令ls，cd，cp；文本编辑命令vi，ed；磁盘操作命令dd，df，mount等 /sbin中的s是super user的意思，只有root用户才能执行这些命令，如磁盘检查修复命令fcsk，磁盘分区命令fdisk，创建文件系统命令mkfs，关机命令shutdown，初始化系统命令init等 2.1.2.8、/home目录用户的工作目录。每个用户都有一个自己的目录，以用户账号命名 2.1.2.9、/lib目录存放共享程序库和映像文件，可供多个程序使用。 2.1.2.10、/root目录是root用户默认的主目录 2.1.2.11、/run和/mnt目录/run是外在设备的自动挂载目录，CentOS7.x以前是/media目录 /mnt是手动挂载移动设备的目录 2.1.2.12、/tmp目录存放临时文件，可随时删除 2.2、系统核心组成最核心的就是Linux内核，它由5个部分组成，分别是内存管理，进程管理，进程间通信，虚拟文件系统和网络接口 2.2.1、内存管理合理有效地管理系统的物理内存，快速响应各个子系统对内存分配的请求，支持虚拟内存。 2.2.2、进程管理进程调度器基于优先级的调度算法来对时间片的分配进行管理，在多个进程间快速切换，可以达到一个CPU多个程序同时运行的效果。实际上，同一时间只有一个进程在运行（一个CPU）。 2.2.3、进程间通信控制不同进程之间在用户空间的同步、数据共享和交换。 2.2.4、虚拟文件系统包括逻辑文件系统和设备驱动程序。 逻辑文件系统：Linux支持的文件系统，如ext2，ext3，ext4，xfs，fat等 设备驱动程序：为每一种硬件控制器编写的设备驱动程序模块 2.2.5、网络接口提供了对各种网络标准的实现和各种网络硬件的支持。一般分为网络协议和网络设备驱动程序。 网络协议：负责实现每一种可能的网络传输协议。 网络设备驱动程序：主要负责与硬件设备进行通信。 3、运行机制介绍3.1、Linux初始化init系统3.1.1、初始化init系统Linux启动：BIOS-&gt;内核初始化 内核初始化最后一步是启动PID为1的init进程，该进程负责产生其他所有的用户进程。但是需要一个系统和管理init进程的行为，该系统就是init系统。 CentOS7.x之前都采用的是sysvinit，CentOS7.x开始采用systemd，ubuntu采用的是upstart 3.1.2、系统关机过程3.1.2.1、shutdown命令必须由超级用户才能执行，该命令执行后，会以广播的形式通知正在工作的用户，系统将在指定时间内关闭。当指定时间已到时，shutdown发送信号给init进程改变系统运行级别。关机就执行init 0，重启就执行init 6 立即重启 shutdown -r now 立即关机 shutdown -h now 设定时间关机 shutdown +5 \"system will shutdown after 5 mins\" 3.1.2.2、halt命令halt相当于shutdown -h halt [-finp] 3.1.2.3、reboot命令系统重启 3.1.2.4、init命令用于系统不同运行级别之间的转换 0：关机模式 1：单用户模式，只有管理员能登陆 6：重启模式 4、系统服务管理工具systemdsystemd提供了一个很强大的命令行工具systemctl，可以用来查看、启动、停止、重启、启用或禁用系统服务。 4.1、启动、停止、重启服务在root账户下： 启动 systemctl start httpd.service 这样就启动了httpd服务（Apache Http服务器） 停止 systemctl stop httpd.service 重启 systemctl restart httpd.service 4.2、查看、禁止、启用服务 开机启动 systemctl enable httpd.service 关闭开机启动 systemctl disable httpd.service 查看服务运行状态 systemctl status httpd.service 4.3、电源管理命令 关闭系统 systemctl poweroff 重启系统 systemctl reboot 进入待机模式 systemctl suspend 进入休眠模式 systemctl hibernate 进入混合休眠模式 systemctl hybrid-sleep 5、参考文献高俊峰《循序渐进Linux》第二版","categories":[{"name":"Linux","slug":"Linux","permalink":"https://javaguycoffee.com/categories/Linux/"},{"name":"基础知识","slug":"Linux/基础知识","permalink":"https://javaguycoffee.com/categories/Linux/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://javaguycoffee.com/tags/Linux/"}]},{"title":"ArrayList源码分析","slug":"ArrayList源码分析","date":"2021-03-20T15:07:35.000Z","updated":"2022-07-21T03:51:31.855Z","comments":true,"path":"2021/03/20/arraylist-yuan-ma-fen-xi/","link":"","permalink":"https://javaguycoffee.com/2021/03/20/arraylist-yuan-ma-fen-xi/","excerpt":"","text":"1、概览1.1、基本特点ArrayList相当于一个动态数组，容量可以动态增长，继承自抽象类AbstractList，实现了List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable接口，因此具有List的一些特性，支持随机访问，克隆和序列化 public class ArrayList&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, java.io.Serializable 1.1.1、标记接口一般我们认为没有任何方法的接口是标记接口。这并不是Java的一种语法，而是一种设计理念，用来标记类提供的某项功能。 1.1.2、RandomAccess, Cloneable, java.io.Serializable这三个接口我们去看源码会发现里面什么方法都没有，因此它们都是标记接口，分别用来标记实现类支持随机访问，克隆和序列化。 public interface RandomAccess { } public interface Cloneable { } public interface Serializable { } 1.2、线程安全型对ArrayList的修改操作，我们可以分为两种： 一种是对数组元素位置的调整，比如添加删除元素 另一种是对数组元素的修改，比如修改某个元素。这在多线程环境下是无法保证原子性的，而ArrayList又没有采用加锁机制来保证操作的原子性，因此是线程不安全的。如果你想要在多线程环境下使用这种结构，建议用Vector，它就相当于一个线程安全的ArrayList。 2、属性2.1、DEFAULT_CAPACITY默认初始化容量DEFAULT_CAPACITY为10 private static final int DEFAULT_CAPACITY = 10; 2.2、EMPTY_ELEMENTDATAEMPTY_ELEMENTDATA是一个静态常量的空数组对象，用来初始化elementData private static final Object[] EMPTY_ELEMENTDATA = {}; 2.3、DEFAULTCAPACITY_EMPTY_ELEMENTDATADEFAULTCAPACITY_EMPTY_ELEMENTDATA也是一个静态常量，也是用来初始化elementData，关于它和EMPTY_ELEMENTDATA不同的地方，后面扩容的部分会谈到。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 2.4、elementData保存数组元素的对象数组，并且加上了transient关键字，表示该属性不使用Java默认序列化机制进行序列化 transient Object[] elementData; // non-private to simplify nested class access 2.5、size保存数组当前实际的大小 private int size; 2.6、MAX_ARRAY_SIZE静态常量，定义数组容量的最大值，在扩容的时候会用到。 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 2.7、modCountmodCount 用来记录 ArrayList 结构发生变化的次数，如果一个动作前后 modCount 的值不相等，说明 ArrayList 被其它线程修改了 protected transient int modCount = 0; 2.8、serialVersionUID实现了Serializable接口的类如果我们不显示的指定serialVersionUID的话，那么会基于类的属性方法等参数生成一个默认的serialVersionUID，如果类的属性或方法有所改动，那么这个默认的serialVersionUID也会随之改动。 所以如果我们不显示的指定serialVersionUID的话，只要类有所改动serialVersionUID就会变化，从而导致反序列化失败。 对于serialVersionUID的显式赋值，一般情况下直接设置成1L就行了，当然了也可以使用IDEA帮我们自动生成的serialVersionUID作为默认值。 private static final long serialVersionUID = 8683452581122892189L; 3、构造方法3.1、无参构造如果是无参构造，就会初始化一个默认容量为10的空数组 public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 3.2、带初始化容量的构造如果是传初始容量进行构造，则会分三种情况，如下： public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } 我们会发现，当传入参数initialCapacity为0时，会将elementData初始化为EMPTY_ELEMENTDATA空数组，上面的无参构造是初始化为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，对于两者的区别，后面的扩容会进行分析。 3.3、传一个集合构造如果是给传一个集合进行构造，会分两种情况进行讨论 public ArrayList(Collection&lt;? extends E> c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 如果集合为空，则也是会将elementData初始化为EMPTY_ELEMENTDATA，如果集合不为空，我们注意到会判断elementData.getClass() != Object[].class 首先我们查看Collection接口的toArray方法，可以发现它返回一个Object对象数组 Object[] toArray(); 但是为什么它的getClass()不一定等于Object[].class呢？我们接着查看下getClass()的源码，可以发现getClass()是返回该对象的运行时的类，而class获得的是类型类即Object[]类型。 //@return The {@code Class} object that represents the runtime class of this object. public final native Class&lt;?> getClass(); 我们来看看下面这段代码 public static void main(String[] args) { User[] users = new User[]{ new User(1, \"admin\", \"admin@qq.com\"), new User(2, \"maco\", \"maco@qq.com\"), new User(3, \"kitty\", \"kitty@163.com\") }; Object[] objects = users; System.out.println(objects.getClass()); // class [Ltest.User; if(objects.getClass() != Object[].class){ objects = Arrays.copyOf(objects, objects.length, Object[].class); } System.out.println(objects.getClass());// class [Ljava.lang.Object; } 代码运行结果如下： 所以如果我们的Collection是Collection&lt;User&gt;那么c.toArray().getClass()将返回User[]类型，这样会导致后面我们插入Object对象会报错，因此我们有必要进行判断，如果不是Object[]类型的话，就调用Arrays.copyOf方法进行拷贝，将elementData转成Object[]类型，下面我们来看看Arrays.copyOf的源码： public static &lt;T,U> T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]> newType) { @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 首先会根据newType和newLength初始化一个copy数组，用来存放从original拷贝过来的数组，并返回给调用者。其实上述三目运算符应该是可以省略的，即我们可以直接写成 T[] copy = (T[]) Array.newInstance(newType.getComponentType(), newLength); 因为Object[]类型的getComponentType方法是Object，最后两者的初始化基本是相同的。至于作者为什么这么写，我想应该是针对Object[]初始化的一种小优化吧，毕竟Array.newInstance会调用本地newArray方法进行初始化相对比较耗时。 public static Object newInstance(Class&lt;?> componentType, int length) throws NegativeArraySizeException { return newArray(componentType, length); } private static native Object newArray(Class&lt;?> componentType, int length) throws NegativeArraySizeException; 4、关键方法4.1、trimToSize该方法用来最小化ArrayList实例存储空间，将容器大小调整为当前元素所占用的大小。 public void trimToSize() { modCount++; if (size &lt; elementData.length) { elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); } } 注意到这里size==0时，我们是将elementData初始化为EMPTY_ELEMENTDATA，而非DEFAULTCAPACITY_EMPTY_ELEMENTDATA。然后我们看看Arrays.copyOf(elementData, size)的源码 public static &lt;T> T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass()); } 我们会发现它调用了另外一个copyOf方法，这个方法前面ArrayList的容器构造方法提到过，只不过这里我们的第三个参数就是第一个参数的类型，因为最终都是调用底层System.arraycopy()方法，我们可以来看看System.arraycopy()源码注释 /** If the &lt;code>src&lt;/code> and &lt;code>dest&lt;/code> arguments refer to the * same array object, then the copying is performed as if the * components at positions &lt;code>srcPos&lt;/code> through * &lt;code>srcPos+length-1&lt;/code> were first copied to a temporary * array with &lt;code>length&lt;/code> components and then the contents of * the temporary array were copied into positions * &lt;code>destPos&lt;/code> through &lt;code>destPos+length-1&lt;/code> of the * destination array.*/ 大致意思就是，如果src和dest是同一个数组的引用时，在拷贝的时候，会先将src数组拷贝length长度到一个临时数组，然后再将临时数组的内容拷贝到dest数组的destPos位置，而如果src和dest指向不同数组的话，就直接进行拷贝 4.2、添加元素与扩容4.2.1、在最后添加一个元素 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 我们发现首先会调用ensureCapacityInternal保证数组有足够空间容纳这一个元素，我们来看看ensureCapacityInternal源码 private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } 我们发现它传给ensureExplicitCapacity的minCapacity并不是形参minCapacity，而是通过calculateCapacity方法计算之后的minCapacity，我们来看看这个calculateCapacity方法 private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } 我们会发现当elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA空数组的时候，会返回DEFAULT_CAPACITY和minCapacity的较大值，比如我们现在就添加一个元素，那么此时minCapacity就是1，那么方法就会返回DEFAULT_CAPACITY即10，接着就按照DEFAULT_CAPACITY进行扩容，而如果elementData为EMPTY_ELEMENTDATA的时候那么就会返回1，就会只扩充1个元素容量。这里就体现出了两者的差别。 然后我们来看看ensureExplicitCapacity方法 private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0) grow(minCapacity); } 如果elementData.length &gt;= minCapacity的话，就表示我们当前elementData足够容纳新添加的元素，因此就不用扩容；否则，我们就会调用grow方法进行扩容。 下面我们来看看grow方法 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 我们发现newCapacity先尝试扩大为oldCapacity的1.5倍，如果还不够的话就直接扩大到minCapacity。然后需要判断下newCapacity是否超出MAX_ARRAY_SIZE的大小，如果是，需要调用hugeCapacity方法进行容量调整 private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 最后调用Arrays.copyOf方法进行数组拷贝 4.2.2、在指定位置添加一个元素 public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 首先会调用rangeCheckForAdd方法进行下标范围检查 private void rangeCheckForAdd(int index) { if (index > size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 然后调用ensureCapacityInternal方法确保至少有size + 1的空间，接着会调用System.arraycopy方法进行数组移位（将index后面的元素往后移一位），然后再将element插到index的位置，数组的大小加一。 4.2.3、在最后添加一个集合元素该方法用来添加集合c里面的所有元素，所以至少需要保证容量至少要有size + numNew即两者的size大小之和，然后调用 System.arraycopy 将要添加的集合中的元素复制到原集合已有元素的后面 public boolean addAll(Collection&lt;? extends E> c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } 4.3、删除元素4.3.1、删除指定索引位置的元素 public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); //需要移动的元素数量 int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } 首先会做下标范围检查 private void rangeCheck(int index) { if (index >= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } 然后计算需要移动的元素数量，如果index==size-1，即numMoved为0，不需要移动。否则调用System.arraycopy方法将numMoved个元素往前移一位 最后，将elementData之前最后一个元素的位置赋值为null，建议GC进行回收 4.3.2、删除指定对象 public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } 根据o是否为null分两种情况，然后遍历数组进行查找，如果找到了就调用fastRemove方法进行删除，返回true；遍历完没找到就返回false。 看完fastRemove源码后，我们发现它和remove(int)方法几乎完全相同，只是没做rangeCheck，没返回删除的元素值。 private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } 4.3.3、删除集合c里的所有元素 public boolean removeAll(Collection&lt;?> c) { Objects.requireNonNull(c); return batchRemove(c, false); } Objects类的requireNonNull静态方法定义如下： public static &lt;T> T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } 即当集合c为null时，会抛出空指针异常。 然后调用batchRemove方法进行批量删除，我们来重点看看batchRemove方法 private boolean batchRemove(Collection&lt;?> c, boolean complement) { final Object[] elementData = this.elementData; int r = 0, w = 0;//r用来表示当前下标，w用来表示需要保留的元素数量 boolean modified = false; try { for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) //判断elementData[r]是否需要保留 elementData[w++] = elementData[r]; } finally { // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) { //可能是elementData[r]为null，c.contains(elementData[r])方法抛出了空指针异常,将r后面的元素都拷贝到w后面 System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; //需要保留的元素数量增加size-r } if (w != size) {//表明有元素被删除了，将modified赋值为true // clear to let GC do its work for (int i = w; i &lt; size; i++)//将w之后的元素都设为null，建议GC进行回收 elementData[i] = null; modCount += size - w;//删除的元素数量为size-w size = w; modified = true; } } return modified; } 4.3.4、删除除集合c里的所有元素 public boolean retainAll(Collection&lt;?> c) { Objects.requireNonNull(c); return batchRemove(c, true); } 和removeAll类似，只是retainAll是保留集合c里面的元素，其他的全部删除。 4.4、遍历4.4.1、迭代器迭代器有两个，分别是Itr和ListItr ，两个都是ArrayList的内部类，我们来看看两者的类结构图 ListItr 有 add() 方法，可以向List中添加对象，而 Itr 不能 ListItr 和 Itr 都有 hasNext() 和 next() 方法，可以实现顺序向后遍历，但是 ListItr 有 hasPrevious() 和 previous() 方法，可以实现逆向遍历。Itr 就不可以。 ListItr 可以定位当前的索引位置，nextIndex() 和 previousIndex() 可以实现。Itr 没有此功能。 都可实现删除对象，但是 ListItr 可以实现对象的修改，set() 方法可以实现。Iierator 仅能遍历，不能修改 4.4.2、forEachforEach() 方法与 Java-foreach循环 不同。 前者用于遍历动态数组中每一个元素并执行特定操作，而后者用于遍历数组中的每个元素 public void forEach(Consumer&lt;? super E> action) { Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) { action.accept(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } 这里的action是对每个元素执行的操作，一般是一个lambda表达式 我们看下面的例子： import java.util.ArrayList; class Main { public static void main(String[] args) { // 创建一个数组 ArrayList&lt;Integer> numbers = new ArrayList&lt;>(); // 往数组中添加元素 numbers.add(1); numbers.add(2); numbers.add(3); numbers.add(4); System.out.println(\"ArrayList: \" + numbers); // 所有元素乘以 10 System.out.print(\"更新 ArrayList: \"); // 将 lambda 表达式传递给 forEach numbers.forEach((e) -> { e = e * 10; System.out.print(e + \" \"); }); } } 上面代码输出为： ArrayList: [1, 2, 3, 4] 更新 ArrayList: 10 20 30 40 以上实例中，我们将匿名函数 lambda 的表达式作为 forEach() 方法的参数传入，lambda 表达式将动态数组中的每个元素乘以 10，然后输出结果。 4.5、序列化通常我们序列化一个对象的目的是为了可以反序列化回来，使用场景有很多，比如说： 把对象保存到文件中，然后可以再恢复 使用网络IO传递一个对象 因为memcached不支持存储对象，把对象序列化后存到memcached中，用的时候再序列化回来 我们会发现ArrayList有两个字段用transient关键字进行了修饰，让其不被序列化 transient Object[] elementData; protected transient int modCount = 0; 但是为什么最重要的elementData都不让序列化呢？因为ArrayList不想用Java默认序列化机制来序列化elementData，因为这可能造成空间浪费，降低序列化和反序列化的效率。对此，ArrayList自定义了序列化和反序列化的策略 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff int expectedModCount = modCount; //写当前类的 non-static 和 non-transient 字段到s输出流中 s.defaultWriteObject(); // 写入数组的实际大小，而非容量 s.writeInt(size); // 只序列化数组的前 size 个对象 for (int i=0; i&lt;size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } 反序列化方法如下： private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { elementData = EMPTY_ELEMENTDATA; //从输入流s中读取当前类的 non-static 和 non-transient 字段，包括size s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size > 0) { // be like clone(), allocate array based upon size not capacity int capacity = calculateCapacity(elementData, size); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity); ensureCapacityInternal(size); Object[] a = elementData; //依次读取对象 for (int i=0; i&lt;size; i++) { a[i] = s.readObject(); } } } 我们来看一下ObjectStreamClass类的私有构造方法的部分源码： if (externalizable) { cons = getExternalizableConstructor(cl); } else { cons = getSerializableConstructor(cl); writeObjectMethod = getPrivateMethod(cl, \"writeObject\", new Class&lt;?>[] { ObjectOutputStream.class }, Void.TYPE); readObjectMethod = getPrivateMethod(cl, \"readObject\", new Class&lt;?>[] { ObjectInputStream.class }, Void.TYPE); readObjectNoDataMethod = getPrivateMethod( cl, \"readObjectNoData\", null, Void.TYPE); hasWriteObjectData = (writeObjectMethod != null); } 从上面这段源码中可以看出，在序列化（反序列化）的时候，ObjectOutputStream（ObjectInputStream）会寻找目标类中的私有的writeObject（readObject）方法，赋值给变量writeObjectMethod（readObjectMethod）。 再来看看ObjectOutputStream中的最终序列化对象的方法writeSerialData，如果writeObjectMethod != null（目标类中定义了私有的writeObject方法），那么将调用目标类中的writeObject方法，如果如果writeObjectMethod == null，那么将调用默认的defaultWriteFields方法来读取目标类中的属性。 private void writeSerialData(Object obj, ObjectStreamClass desc) throws IOException { ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout(); for (int i = 0; i &lt; slots.length; i++) { ObjectStreamClass slotDesc = slots[i].desc; if (slotDesc.hasWriteObjectMethod()) { ... slotDesc.invokeWriteObject(obj, this); ... } else { defaultWriteFields(obj, slotDesc); } } } boolean hasWriteObjectMethod() { requireInitialized(); return (writeObjectMethod != null); } 4.6、fail-fast如果在创建迭代器之后的任何时候以任何方式修改了列表（增加、删除、修改），除了通过迭代器自己的remove 或 add方法，迭代器将抛出 ConcurrentModificationException 异常 需要注意的是：这里异常的抛出条件是检测到 modCount != expectedmodCount，如果并发场景下一个线程修改了modCount值时另一个线程又 “及时地” 修改了expectedmodCount值，则异常不会抛出。所以不能依赖于这个异常来检测程序的正确性。 下面是用到modCount的一些情景 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ int expectedModCount = modCount; // 记录下当前的 modCount // 一些操作之后.... if (modCount != expectedModCount) { // 比较现在与之前的 modCount，不相等表示在中间过程中被修改了 throw new ConcurrentModificationException(); } } public void forEach(Consumer&lt;? super E> action) { final int expectedModCount = modCount; // 一些操作之后.... if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } public boolean removeIf(Predicate&lt;? super E> filter) { final int expectedModCount = modCount; // 一些操作之后.... if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } public void replaceAll(UnaryOperator&lt;E> operator) { final int expectedModCount = modCount; // 一些操作之后.... if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; // 修改了要加一 } public void sort(Comparator&lt;? super E> c) { final int expectedModCount = modCount; // 一些操作之后.... if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } // 内部迭代器 private class Itr implements Iterator&lt;E> { public void forEachRemaining(Consumer&lt;? super E> consumer) { checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 5、参考资料https://laijianfeng.org/2019/01/ArrayList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ https://my.oschina.net/u/4309288/blog/3338206 https://www.matools.com/api/java8 https://www.runoob.com/java/java-arraylist-foreach.html https://blog.csdn.net/Leon_cx/article/details/81517603","categories":[{"name":"Java","slug":"Java","permalink":"https://javaguycoffee.com/categories/Java/"},{"name":"Jdk源码","slug":"Java/Jdk源码","permalink":"https://javaguycoffee.com/categories/Java/Jdk%E6%BA%90%E7%A0%81/"},{"name":"Java容器","slug":"Java/Jdk源码/Java容器","permalink":"https://javaguycoffee.com/categories/Java/Jdk%E6%BA%90%E7%A0%81/Java%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"https://javaguycoffee.com/tags/ArrayList/"},{"name":"jdk源码","slug":"jdk源码","permalink":"https://javaguycoffee.com/tags/jdk%E6%BA%90%E7%A0%81/"},{"name":"Java容器","slug":"Java容器","permalink":"https://javaguycoffee.com/tags/Java%E5%AE%B9%E5%99%A8/"},{"name":"序列化","slug":"序列化","permalink":"https://javaguycoffee.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"fail-fast","slug":"fail-fast","permalink":"https://javaguycoffee.com/tags/fail-fast/"},{"name":"forEach","slug":"forEach","permalink":"https://javaguycoffee.com/tags/forEach/"}]},{"title":"进程间通信方式大总结","slug":"进程间通信方式大总结","date":"2021-03-20T01:01:48.000Z","updated":"2022-07-21T03:51:31.993Z","comments":true,"path":"2021/03/20/jin-cheng-jian-tong-xin-fang-shi-da-zong-jie/","link":"","permalink":"https://javaguycoffee.com/2021/03/20/jin-cheng-jian-tong-xin-fang-shi-da-zong-jie/","excerpt":"","text":"每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication） 进程间通信常见有以下7种方式： 1、匿名管道 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程); 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写 管道的局限性： 只支持单向数据流； 只能用于具有亲缘关系的进程之间； 没有名字； 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）； 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等； // 需要的头文件 #include &lt;unistd.h> // 通过pipe()函数来创建匿名管道 // 返回值：成功返回0，失败返回-1 // fd参数返回两个文件描述符 // fd[0]指向管道的读端，fd[1]指向管道的写端 // fd[1]的输出是fd[0]的输入。 int pipe (int fd[2]); 通过匿名管道实现进程间通信的步骤如下： 父进程创建管道，得到两个⽂件描述符指向管道的两端 父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。 父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。 2、有名管道有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。 匿名管道和有名管道总结： （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。 （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。 （3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。 （4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。 3、信号（signal） 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程 Linux系统中常用信号： （1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。 （2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。 （3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\\\\键将产生该信号。 （4）SIGBUS和SIGSEGV：进程访问非法地址。 （5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。 （6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。 （7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。 （8）SIGALRM：定时器信号。 （9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。 信号来源信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源： 硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。 软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。 信号生命周期和处理流程 （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统； （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。 （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度 4、消息队列 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。 消息队列特点总结： （1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识. （2）消息队列允许一个或多个进程向它写入与读取消息. （3）管道和消息队列的通信数据都是先进先出的原则。 （4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。 （5）消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。 （6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，System V消息队列目前被大量使用。System V消息队列是随内核持续的，只有在内核重启或者人工删除时，该消息队列才会被删除。 5、共享内存 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。 通信流程大概这样： 写端： 获取mutex对象，锁定共享区域。 将要通信的数据写入共享区域。 释放mutex对象 读端： 获取mutex对象，锁定共享区域。 从共享区域读数据。 释放mutex对象 用于共享内存API： #include &lt;sys/shm.h> int shmget(key_t key, size_t size, int shmflg); //分配一个共享内存块 void *shmat(int shm_id, const void *shm_addr, int shmflg); //将共享内存区映射到本地进程的虚拟地址空间 int shmdt(const void *shm_addr); //解除映射 int shmctl(int shm_id, int cmd, struct shmid_ds *buf); //控制对共享内存的使用，如删除共享内存等 6、信号量（semaphore）信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。 为了获得共享资源，进程需要执行下列操作： （1）创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。 （2）等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。 （3）挂出一个信号量：该操作将信号量的值加1，也称为V操作。 为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）、Posix基于内存的信号量（存放在共享内存区中）、System V信号量（在内核中维护）。这三种信号量都可用于进程间或线程间的同步。 信号量与互斥量之间的区别： （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源 （2）互斥量值只能为0/1，信号量值可以为非负整数。 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。 （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。 7、Socket套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。 套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。 套接字特性 套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。 （1）套接字的域 它指定套接字通信中使用的网络介质，最常见的套接字域有两种： 一是AF_INET，它指的是Internet网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。 另一个域AF_UNIX，表示UNIX文件系统，它就是文件输入/输出，而它的地址就是文件名。 （2）套接字的端口号 每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。 （3）套接字协议类型 因特网提供三种通信机制， 一是流套接字，流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。 二个是数据报套接字，它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。 三是原始套接字，原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。 套接字通信的建立 服务器端 （1）首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。 （2）然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。 （3）接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。 （4）最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。 客户端 （1）客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。 （2）一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://javaguycoffee.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程通信","slug":"操作系统/进程通信","permalink":"https://javaguycoffee.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"https://javaguycoffee.com/tags/Socket/"},{"name":"管道","slug":"管道","permalink":"https://javaguycoffee.com/tags/%E7%AE%A1%E9%81%93/"},{"name":"Signal","slug":"Signal","permalink":"https://javaguycoffee.com/tags/Signal/"},{"name":"消息队列","slug":"消息队列","permalink":"https://javaguycoffee.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"共享内存","slug":"共享内存","permalink":"https://javaguycoffee.com/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"name":"信号量","slug":"信号量","permalink":"https://javaguycoffee.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-03-18T01:33:31.000Z","updated":"2022-07-21T03:51:31.882Z","comments":true,"path":"2021/03/18/hello-world/","link":"","permalink":"https://javaguycoffee.com/2021/03/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://javaguycoffee.com/categories/Linux/"},{"name":"基础知识","slug":"Linux/基础知识","permalink":"https://javaguycoffee.com/categories/Linux/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"Java","permalink":"https://javaguycoffee.com/categories/Java/"},{"name":"Jdk源码","slug":"Java/Jdk源码","permalink":"https://javaguycoffee.com/categories/Java/Jdk%E6%BA%90%E7%A0%81/"},{"name":"Java容器","slug":"Java/Jdk源码/Java容器","permalink":"https://javaguycoffee.com/categories/Java/Jdk%E6%BA%90%E7%A0%81/Java%E5%AE%B9%E5%99%A8/"},{"name":"操作系统","slug":"操作系统","permalink":"https://javaguycoffee.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程通信","slug":"操作系统/进程通信","permalink":"https://javaguycoffee.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://javaguycoffee.com/tags/Linux/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://javaguycoffee.com/tags/ArrayList/"},{"name":"jdk源码","slug":"jdk源码","permalink":"https://javaguycoffee.com/tags/jdk%E6%BA%90%E7%A0%81/"},{"name":"Java容器","slug":"Java容器","permalink":"https://javaguycoffee.com/tags/Java%E5%AE%B9%E5%99%A8/"},{"name":"序列化","slug":"序列化","permalink":"https://javaguycoffee.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"fail-fast","slug":"fail-fast","permalink":"https://javaguycoffee.com/tags/fail-fast/"},{"name":"forEach","slug":"forEach","permalink":"https://javaguycoffee.com/tags/forEach/"},{"name":"Socket","slug":"Socket","permalink":"https://javaguycoffee.com/tags/Socket/"},{"name":"管道","slug":"管道","permalink":"https://javaguycoffee.com/tags/%E7%AE%A1%E9%81%93/"},{"name":"Signal","slug":"Signal","permalink":"https://javaguycoffee.com/tags/Signal/"},{"name":"消息队列","slug":"消息队列","permalink":"https://javaguycoffee.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"共享内存","slug":"共享内存","permalink":"https://javaguycoffee.com/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"name":"信号量","slug":"信号量","permalink":"https://javaguycoffee.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"}]}