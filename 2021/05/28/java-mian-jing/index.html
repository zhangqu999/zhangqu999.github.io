<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java面经, SpringBoot Java MySQL MA JavaGuy Math 算法">
    <meta name="baidu-site-verification" content="code-r7CYm21B6o" />
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48" />
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7" />
    <meta name="description" content="1、计算机网络1.1、网络模型与相关协议
​    OSI七层模型:物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层。


​    TCP/IP5层模型：物理层，数据链路层，网络层，运输层，应用层。


​    TCP/IP">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Java面经 | JavaGuy的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="JavaGuy的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JavaGuy的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">JavaGuy的博客</div>
        <div class="logo-desc">
            
            华中科技大学 | 计算机科学与技术 | 分布式云数据库内核
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '91a6f824b85ba9ed6e7cf599364e2f8bc897a465357160c6425c8eacd8883377';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/6.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Java面经
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        <span class="chip bg-color">无标签</span>
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-05-28
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    JavaGuy
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    92.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    334 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="1、计算机网络"><a href="#1、计算机网络" class="headerlink" title="1、计算机网络"></a>1、计算机网络</h1><h2 id="1-1、网络模型与相关协议"><a href="#1-1、网络模型与相关协议" class="headerlink" title="1.1、网络模型与相关协议"></a>1.1、网络模型与相关协议</h2><ul>
<li>​    OSI七层模型:物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层。</li>
</ul>
<ul>
<li>​    TCP/IP5层模型：物理层，数据链路层，网络层，运输层，应用层。</li>
</ul>
<ul>
<li>​    TCP/IP4层模型：网络接口层，网络层(IP)，运输层(TCP/UDP)，应用层(HTTP)。</li>
</ul>
<ul>
<li>常见应用层协议：DNS，HTTP, SMTP, POP3(接受文件)，FTP,Telent远程终端协议。</li>
</ul>
<ul>
<li>传输层：TCP，UDP; 网络层：ICMP,IGMP，IP</li>
</ul>
<p><strong>在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层</strong></p>
<ul>
<li>ARP是IP地址解析为MAC地址 </li>
<li>RARP 将MAC地址解析为IP地址</li>
</ul>
<p>一条TCP连接上发送数据速度的影响因素有哪些？</p>
<ul>
<li> 服务器到客户端之间带宽瓶颈</li>
<li>客户端接收能力限制</li>
<li>服务器网卡处理能力</li>
</ul>
<h2 id="1-2、TCP、UDP协议的区别"><a href="#1-2、TCP、UDP协议的区别" class="headerlink" title="1.2、TCP、UDP协议的区别"></a>1.2、TCP、UDP协议的区别</h2><p>​    TCP提供可靠的、面向连接的运输服务。在传输数据之前必须三次握手建立连接，数据传输结束之后，4次挥手释放连接，而且在数据传递时，又有****确认应答、超时重传、滑动窗口、拥塞控制*<em><strong>等机制保证传送数据的可靠性。TCP经常用于对网络通信质量有很高要求的地方，如</strong></em>*文件传输，邮件发送，远程登录****等场景。SMTP、TELNET、HTTP、FTP</p>
<p>​    UDP在传送数据之前不需要建立连接，目的主机收到UDP报文后，不需要给出确认。UDP不提供可靠交付，一般用于即时通信，如语音、视频、直播等。<em><strong>*RIP(路由选择协议)，DNS*</strong></em></p>
<h2 id="1-3、TCP粘包"><a href="#1-3、TCP粘包" class="headerlink" title="1.3、TCP粘包"></a>1.3、TCP粘包</h2><p><em><strong>*TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。原因可能是发送方也可能是接收方造成的。*</strong></em></p>
<p><em><strong>*发送方原因：TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。*</strong></em></p>
<p><em><strong>*接收方原因：TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。*</strong></em></p>
<p><em><strong>*如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。处理方法：发送方关闭Nagle算法。*</strong></em></p>
<p><em><strong>*接收方：接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。*</strong></em></p>
<p><em><strong>*TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），*</strong>***</em>*采用了基于流的传输，*<strong><strong><strong>*基于流的传输不认为消息是一条一条的，*</strong></strong></strong>*是无保护消息边界的。而UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。****</p>
<p><em><strong>*数据报文的结构：应用程序+TCP/UDP报文头部+IP报文头部(到这是以太网帧，46-1500)+以太网头部；*</strong></em></p>
<p><em><strong>*TCP报文头部结构：（前20字节固定）*</strong>***</em>*16为源端口号+16位目的端口号+32位序号+32位确认号+4位头部长度（单位4字节）*<strong><strong><strong>*+6位保留+6个关键字*</strong></strong></strong>*（SYN,ACK，FIN）+16位窗口大小（*<strong><strong><strong>*指接收窗口*</strong></strong></strong>*）+16位校验和****<em><strong>*+16位紧急指针+最多40字节的选项；*</strong></em></p>
<p><em><strong>*UDP报文头部结构首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。：*</strong></em></p>
<p><em><strong>*IP报文头部结构：*</strong></em></p>
<p><em><strong>*4位版本+4位首部长度*</strong>***</em>*（单位4字节）+8位服务类型+****<em><strong>*16位总长度（字节）*</strong></em></p>
<p><em><strong>*16位标识（分组）+3位标志（是否分组）+13为片内偏移*</strong></em></p>
<p><em><strong>*8位TTL*</strong>***</em>*+8位上层协议+****<em><strong>*16位首部检验和*</strong></em></p>
<p><em><strong>*32位源IP地址*</strong></em></p>
<p><em><strong>*32位目的IP地址*</strong></em></p>
<p><em><strong>*以太网头部：*</strong></em></p>
<p><em><strong>*6字节目的地址+6字节源地址+2字节类型。这个地址指MAC地址。*</strong></em></p>
<h2 id="1-4、点对点和端对端的区别"><a href="#1-4、点对点和端对端的区别" class="headerlink" title="1.4、点对点和端对端的区别"></a>1.4、点对点和端对端的区别</h2><p><em><strong>*点到点通信是针对数据链路层或网络层来说的，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受ip层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。*</strong></em> <em><strong>*点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。*</strong></em></p>
<p><em><strong>*端到端通信是针对传输层来说的，传输层为网络中的主机提供端到端的通信。*</strong>***</em>*因为无论tcp还是udp协议，都要负责把上层交付的数据从发送端传输到接收端，不论其中间跨越多少节点。只不过tcp比较可靠而udp不可靠而已。所以称之为端到端，也就是从发送端到接收端。它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据。****</p>
<h2 id="1-5、IP数据报传输的过程"><a href="#1-5、IP数据报传输的过程" class="headerlink" title="1.5、IP数据报传输的过程"></a>1.5、IP数据报传输的过程</h2><p><em><strong>*(无论怎么传，IP源和目的地址不变，但MAC目的和源地址会变)*</strong></em></p>
<p><em><strong>*IP数据报需从主机A上传送到主机B上，主机A首先查找路由表;*</strong></em></p>
<p><em><strong>*if(目的主机是与自己在同一个网段内)*</strong></em></p>
<p>​    <em><strong>*主机A查询自己的ARP表;如果存在目的IP地址到MAC的映射，将MAC地址作为目的MAC地址封装成帧，发*</strong></em>    <em><strong>*给主机B.如果没有，发送ARP请求广播给网段内的所有主机，来查询该目的IP地址的MAC地址*</strong></em></p>
<p><em><strong>*else if(发现了能与目的网络号相匹配的表目)*</strong></em></p>
<p>​    <em><strong>*则把报文发给该路由表目指定的下一站的路由器或直接连接的网络接口;*</strong></em></p>
<p>​    <em><strong>*报文发送到下一站时，数据帧的目的MAC地址是下一个站路由器或者网络接口的MAC地址，而IP头部的目的IP*</strong></em>    <em><strong>*地址是主机B的IP地址;*</strong></em></p>
<p><em><strong>*else*</strong></em></p>
<p>​    <em><strong>*寻找标为“默认”的表目，把报文发送给该表目指定的下一站路由器;*</strong></em></p>
<p><em><strong>*滑动窗口：*</strong></em></p>
<p>TCP通过滑动窗口的概念来进行流量控制，抑制发送端发送数据的速率，以便接收端来得及接收。</p>
<p>窗口：对应一段发送者可以发送的字节序列。这个序列是可以改变的。接收端发给发送端自己的接受能力。然后发送端根据已确认接受的序列号和接受能力滑动窗口，一下子全部发送，等待接收端确认。</p>
<p><em><strong>*拥塞控制：*</strong></em></p>
<p>和流量控制的区别：</p>
<p>****拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，****是一个全局性的过程。</p>
<p>流量控制是点对点通信量的控制,主要就是抑制发送端发送数据的速率，以便接收端来得及接收。</p>
<p>(设置拥塞控制窗口cwnd, 在发送数据时，将拥塞窗口的大小与接收端ack的窗口大小做比较，取较小者作为发送数据量的上限。)</p>
<p><em><strong>*慢开始*</strong></em>: 设置****拥塞控制窗口cwnd = 1*<em><strong>，没收到一个ACK,cwnd++;每过1RTT,cwnd = cwnd * 2;呈</strong></em>*指数增长****。</p>
<p><em><strong>*拥塞避免*<em><strong>：当拥塞窗口 cwnd 达到一个阈值时（cwnd &gt;= ssthresh），窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。</strong></em>*每当过了一个RTT，cwnd = cwnd + 1；*</strong></em></p>
<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络<em><strong>*出现拥塞*</strong></em>(没有收到确认ACK);拥塞窗口设置为1，阈值为****拥塞时发送窗口的一半，执行慢开始算法****。</p>
<p><em><strong>*快重传：当发送方连续收到三个重复确认时，就立即重传对方尚未收到的报文段。并执行快恢复算法*</strong></em></p>
<p><em><strong>*快恢复：将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。*</strong></em></p>
<h2 id="1-6、TCP三次握手"><a href="#1-6、TCP三次握手" class="headerlink" title="1.6、TCP三次握手"></a>1.6、TCP三次握手</h2><p>​    1、客户端向服务器发送TCP连接请求数据包，其中同步标志为SYN=1,ACK=0,初始序列号为x;( syn_sent,等待回复)</p>
<p>​    2、服务器收到请求后，发回连接确认包。SYN=1，ACK=1,ack=x+1,初始序列号为y;( syn_rcvd,收到请求，等待回复)</p>
<p>​    3、客户端收到确认报文后，还需发送确认数据包。ACK=1,ack=y+1,序列号为x+1;( ESTABLISHED,完成三次握手)</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps1.jpg" alt="img"> </p>
<p>三次握手是为了建立可靠的通信信道，双方都确认自己和对方的发送和接受都是正常的。SYN=1表示这是个连接请求或连接接受报文，不携带数据。不能变成两次，已失效的连接请求报文段突然又传送到了服务端，服务端误以为是正常的连接请求，直接发送连接确认报文，导致TCP建立，浪费资源，因而产生错误。</p>
<p>1、TCP握手协议</p>
<p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>在上述过程中，还有一些重要的概念：</p>
<p>未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p>
<p>2、SYN攻击原理</p>
<p>SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。</p>
<p>配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p>
<p>第一种是缩短SYN Timeout时间，由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下（过低的SYN Timeout设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷。</p>
<p>第二种方法是设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。</p>
<p>可是上述的两种方法只能对付比较原始的SYN Flood攻击，缩短SYN Timeout时间仅在对方攻击频度不高的情况下生效，SYN Cookie更依赖于对方使用真实的IP地址，如果攻击者以数万/秒的速度发送SYN报文，同时利用SOCK_RAW随机改写IP报文中的源地址，以上的方法将毫无用武之地。</p>
<p>net.ipv4.tcp_syncookies = 1</p>
<p>net.ipv4.tcp_max_syn_backlog = 8192</p>
<p>net.ipv4.tcp_synack_retries = 2</p>
<p>分别为启用SYN Cookie、设置SYN最大队列长度以及设置SYN+ACK最大重试次数。</p>
<p>SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。</p>
<p>net.ipv4.tcp_synack_retries是降低服务器SYN+ACK报文重试次数，尽快释放等待资源。</p>
<p>tcp_max_syn_backlog则是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。</p>
<p>SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。</p>
<h2 id="1-7、TCP四次挥手"><a href="#1-7、TCP四次挥手" class="headerlink" title="1.7、TCP四次挥手"></a>1.7、TCP四次挥手</h2><p>​    <img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps2.jpg" alt="img"></p>
<p>​    由于****TCP连接是全双工的，因此每个方向都必须单独关闭****。当一方数据发送任务完成之后，可以发送FIN来终止这个方向的连接。而另一方可以继续发送数据。</p>
<p>​    1、客户端发送请求释放连接报文，FIN=1,seq=u;客户端进入****FIN-WAIT-1****状态；</p>
<p>​    2、服务器收到请求，发送确认报文。ACK=1,seq=v,ack=u+1;服务器进入CLOSE-WAIT状态。客户端收到后进入终止等待2FIN-WAIT-2;</p>
<p>​    3、服务器发送完数据之后，向客户端发送请求释放连接报文，FIN=1,ACK=1,seq=w,ack=u+1;进入LAST-ACK状态</p>
<p>​    4、客户端收到请求后，发送确认报文，ACK=1,seq=u+1,ack=w+1。客户端进入TIME-WAIT状态，等待2MSL后进如CLOSED状态，服务器收到确认后进如CLOSED状态。</p>
<p>为什么关闭的时候是四次挥手，因为TCP连接时全双工的，每个方向都要发送关闭请求，而另一方向都要确认。</p>
<p>TIME_WAIT状态为什么要等待2MSL：因为第四次的确认报文可能丢失，这个状态是用来重发可能丢失的ACK报文。</p>
<p>为什么会有CLOSE_WAIT,因为服务器可能有数据未发送完毕，这段时间是继续发送数据的。</p>
<p>如果建立连接之后出现故障：TCP有个保活计时器，通常设置为2小时，两小时内没有收到客户端发送的数据，服务器发送探测报文，每75s发送一次，10次之后探测报文没有反应，认为出现故障，关闭连接。</p>
<p><em><strong>*TIME_WAIT存在的两个理由：*</strong></em></p>
<p><em><strong>*1*</strong></em> <em><strong>*可靠的实现TCP全双工连接的终止*</strong></em></p>
<p><em><strong>*2*</strong></em> <em><strong>*允许老的重复的分节在网络上的消逝*</strong>***</em>*（TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝。）****</p>
<p><em><strong>*netstat -an |grep “TIME_WAIT” 查看处于Time_wait状态的连接详细情况*</strong></em></p>
<p><em><strong>*netstat -ae|grep “TIME_WAIT” |wc -l 查看处于Time_wait状态的连接个数*</strong></em></p>
<p><em><strong>*在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。*</strong></em></p>
<p><em><strong>*正常的TCP客户端连接在关闭后，会进入一个TIME_WAIT的状态，持续的时间一般在1~4分钟，短时间内（例如1s内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的socket端口和句柄被用尽，系统无法再发起新的连接！*</strong></em></p>
<p><em><strong>*解决方法：*</strong></em></p>
<p>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p>
<p>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</p>
<p><em><strong>*简单来说，就是打开系统的TIMEWAIT重用和快速回收。*</strong></em></p>
<h2 id="1-8、浏览器输入url并回车的过程以及相关协议"><a href="#1-8、浏览器输入url并回车的过程以及相关协议" class="headerlink" title="1.8、浏览器输入url并回车的过程以及相关协议"></a>1.8、浏览器输入url并回车的过程以及相关协议</h2><p>​    1、根据域名查询域名的IP地址，DNS解析。2、TCP连接3、发送HTTP请求4、服务器处理请求并返回HTTP报文5、浏览器解析渲染页面6、连接结束。</p>
<p>​    使用的协议：DNS(获取域名的IP的地址);TCP(与服务器建立TCP连接)；IP(建立TCP协议时，需发送数据，在网络层用到IP协议)；OPSF(IP数据包在路由之间传送，路由选择使用OPSF协议)；ARP(路由器与服务器通信时，将IP地址转化为MAC地址，使用ARP协议)HTTP(TCP建立之后，使用HTTP协议访问网页)；</p>
<p>​    DNS寻址：先查找浏览器缓存，如果没命中，查询系统缓存，即hosts文件。如果没命中，查询路由器缓存。如果没命中，请求本地域名服务器解析域名，没有命中就进入根服务器进行查询。没有命中就返回顶级域名服务器IP给本地DNS服务器。本地DNS服务器请求顶级域名服务器解析，没有命中就返回主域名服务器给本地DNS服务器。本地DNS服务器请求主域名服务器解析域名，将结果返回给本地域名服务器。本地域名服务器缓存结果并反馈给客户端。</p>
<h2 id="1-9、HTTP1-0、1-1、2-0之间的区别"><a href="#1-9、HTTP1-0、1-1、2-0之间的区别" class="headerlink" title="1.9、HTTP1.0、1.1、2.0之间的区别"></a>1.9、HTTP1.0、1.1、2.0之间的区别</h2><p>​    HTTP1.1与1.0之间的区别:1、<em><strong>*HTTP1.1默认开启长连接*</strong>***</em>*，在一个TCP连接上可以传送多个HTTP请求和响应*<em><strong>。而1.0不支持长连接。客户端和服务器每进行一次HTTP操作，就建立一次连接。2、</strong></em>*缓存处理*<em><strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如</strong></em>*Entity tag*<strong><strong><strong>*，If-*</strong></strong></strong>*Unmodified-Since, If-Match, If-None-Match*<em><strong>等更多可供选择的缓存头来控制缓存策略。3、Host头处理：1.0请求的url并没有传递主机名(服务器与IP地址绑定)，1.1请求和响应都支持Host头域(虚拟主机共享IP地址)4、1.1新增24个错误状态响应码。409：请求的资源和资源的当前状态冲突，410：服务器资源永久性删除。5、带宽优化以及网络连接的使用：</strong></em>*1.1允许只请求资源的某个部分.****</p>
<p><em><strong>*HTTP2.0和HTTP1.X相比的新特性*</strong></em></p>
<p>​    1、<em><strong>*新的二进制格式：*</strong>***</em>*1.x的解析是基于文本的，而2.0的协议解析是采用二进制格式。2、多路复用*<em><strong>，即连接共享，即每一个request都是是用作连接共享机制的；。一个request对应一个id，这样一个连接上可以有多个request。</strong></em>*3、header压缩。4、服务端推送。****</p>
<h2 id="1-10、HTTP与HTTPS"><a href="#1-10、HTTP与HTTPS" class="headerlink" title="1.10、HTTP与HTTPS"></a>1.10、HTTP与HTTPS</h2><p>​    1、HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<p>​    2、HTTP协议运行在TCP之上，传输的内容都是明文。HTTPS运行在SSL/TLS(运行在TCP之上)之上，内容加密。</p>
<p>​    3、连接端口不一样，http是80，https是443.</p>
<p>​    4、http连接简单，没有状态，https是ssl加密的传输，身份认证的网络协议，更安全。</p>
<p>HTTPS在传统的HTTP和TCP之间加了一层用于<em><strong>*加密解密的SSL/TLS层*<em><strong>；</strong></em>*采用 对称加密和非对称加密结合的方式来保护浏览器和服务端之间的通信安全。对称加密：加密和解密都是同一个密钥。非对称加密：密钥成对出现，分为公钥和私钥，公钥和私钥之间不能互相推导，公钥加密需要私钥解密，私钥加密需要公钥解密。*</strong></em></p>
<p>浏览器使用Https的URL访问服务器，建立SSL链接；</p>
<p>1、发送非对称加密的公钥A给浏览器</p>
<p>2、****客户端(SSL/TLS)解析证书****（无效会弹出警告）</p>
<p>3<em><strong>*、生成随机值(这个相当于传送数据的密钥)，作为对称加密的密钥B。*</strong></em></p>
<p>4、<em><strong>*浏览器使用服务器返回的公钥A，对自己生成的对称加密密钥B进行加密，得到密钥C。*</strong></em></p>
<p>5、<em><strong>*浏览器将密钥C发送给服务器*</strong></em></p>
<p>6、<em><strong>*务器使用自己的私钥D对接受的密钥C进行解密，得到对称加密密钥B。*</strong></em></p>
<p>7、将信息和****密钥B****混合在一起进行对称加密</p>
<p>8、将加密的内容发送给客户端</p>
<p>9、客户端用****密钥B****解密信息</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps3.jpg" alt="img"> </p>
<p><em><strong>*加密过程使用了对称加密和非对称加密。*</strong></em></p>
<p><em><strong>*对称加密: 客户端和服务端采用相同的密钥经行加密*</strong></em></p>
<p>  encrypt(明文，秘钥) = 密文</p>
<p>  decrypt(密文，秘钥) = 明文</p>
<p><em><strong>*非对称加密：客户端通过公钥加密。服务端通过私钥解密*</strong></em></p>
<p>  encrypt(明文，公钥) = 密文</p>
<p>decrypt(密文，私钥) = 明文</p>
<p><em><strong>*验证证书：*</strong></em></p>
<p>客户端获取到了站点证书，拿到了站点的公钥</p>
<p>客户端找到其站点<em><strong>*证书颁发者的信息*</strong></em></p>
<p>站点证书的<em><strong>*颁发者验证服务端站点是否可信*</strong></em></p>
<p>   <em><strong>*非对称加密算法：*</strong>***</em>*RSA****<em><strong>*，DSA/DSS*</strong></em> </p>
<p>   <em><strong>*对称加密算法：*</strong>***</em>*AES****<em><strong>*，RC4，3DES*</strong></em> </p>
<p>   <em><strong>*HASH算法：MD5，SHA1，SHA256*</strong></em></p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps4.jpg" alt="img"> </p>
<h2 id="1-11、HTTP请求有哪些，get和post的差别"><a href="#1-11、HTTP请求有哪些，get和post的差别" class="headerlink" title="1.11、HTTP请求有哪些，get和post的差别"></a>1.11、HTTP请求有哪些，get和post的差别</h2><p>请求报文由请求行、请求头部，请求体三部分组成，请求行主要包括：请求方法、请求URL，协议三部分</p>
<p>响应报文由响应行、响应头部、响应体三部分组成，响应行主要包括协议、状态码，状态三部分</p>
<p><code>GET</code>：<strong>获取资源</strong>，用来请求访问已被URI识别的资源</p>
<p><code>POST</code>：用来<strong>传输实体的主体</strong></p>
<ul>
<li>请求参数长度限制：get最多1M，Post没有限制，这个不同浏览器有不同的规范</li>
<li>get不可以用请求体传数据，服务器不一定会接收</li>
<li>安全性：post比get高。get提交数据显示在URL上，会被浏览器缓存，其他人可以看到，而post是放在请求体里；此外get还可能遭到CSRF攻击</li>
<li>get产生一个TCP数据包，而post会产生两个</li>
</ul>
<p>*<strong>*状态码：*</strong></p>
<p>1xx：指示信息–表示请求已接收，继续处理 </p>
<p>​    100 –客户端必须继续发出请求 101-客户端要求服务器转换HTTP协议版本。</p>
<p>2xx：成功–表示请求已被成功接收、理解、接受</p>
<p>​    200—OK  204–请求收到，但返回信息为空 206–服务器已经完成了部分用户的GET请求</p>
<p>3xx：重定向–信息不完整需要进一步补充</p>
<p>​    300 — 请求资源在多处可得到。</p>
<p>​    301—永久重定向，隐式重定向。302 临时重定向，显示重定向。</p>
<p>​    304—请求的资源没有改变，可以使用缓存。</p>
<p>4xx：客户端错误–请求有语法错误或请求无法实现</p>
<p>​    401—未授权  403—禁止访问。 404 –找不到。409：对当前资源状态，请求不能完成</p>
<p>5xx：服务器端错误–服务器未能实现合法的请求</p>
<p>​    500内部服务器错误，501未实现， 502网关错误，503服务不可用，504 网关超时。</p>
<h2 id="1-12、转发和重定向的区别"><a href="#1-12、转发和重定向的区别" class="headerlink" title="1.12、转发和重定向的区别"></a>1.12、转发和重定向的区别</h2><p>​    <em><strong>*转发（forward）是服务器行为，重定向是客户端行为。*</strong></em></p>
<p>​    转发是服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。效率高，可用于用户登录之后将角色转发到相应的模块。</p>
<p>​    重定向是利用服务器返回的状态码来实现的，<em><strong>*如果服务器返回301或者302，*</strong>***</em>*浏览器到新的网址重新请求资源****。地址栏url会发生改变，而且不能共享数据。效率低，可用于用户注销之后，跳转到其他网站。</p>
<h2 id="1-13、Session和Cookie的区别"><a href="#1-13、Session和Cookie的区别" class="headerlink" title="1.13、Session和Cookie的区别"></a>1.13、Session和Cookie的区别</h2><ul>
<li><p>Cookie：是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<ul>
<li>用途<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</li>
</ul>
</li>
<li><p>Session：代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
</li>
</ul>
<ul>
<li><p>两者区别</p>
<ul>
<li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
</li>
<li><p>两者联系</p>
<p>说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210528164014567.png" alt="image-20210528164014567"></p>
</li>
</ul>
<p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>
<ul>
<li><p>cookie被浏览器禁用了怎么办？</p>
<ul>
<li>每次请求中都携带一个 SessionID 的参数，可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</li>
<li>Token 机制：当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</li>
</ul>
</li>
<li><p>如何考虑分布式 Session 问题？</p>
<p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。分布式 Session 一般会有以下几种解决方案：</p>
<ul>
<li><p>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</p>
</li>
<li><p>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</p>
</li>
<li><p><strong>共享 Session</strong>（建议的解决方案），服务端无状态话，将用户的 Session 等信息使用<strong>缓存中间件</strong>来统一管理，保障分发到每一个服务器的响应结果都一致。</p>
</li>
</ul>
</li>
<li><p>如何解决跨域请求？Jsonp 跨域的原理是什么？</p>
<p>说起跨域请求，必须要了解浏览器的同源策略，同源策略/SOP（Same origin policy）是一种约定，由 Netscape 公司 1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</p>
<p>解决跨域请求的常用方法是：</p>
<ul>
<li><p>通过代理来避免，比如使用 Nginx 在后端转发请求，避免了前端出现跨域的问题。</p>
</li>
<li><p>通过 Jsonp 跨域</p>
<ul>
<li><p>Jsonp跨域原理</p>
<ul>
<li><p>浏览器的同源策略把跨域请求都禁止了，但是页面中的 <code>&lt;script&gt;</code>标签是例外，不受同源策略限制。Jsonp 就是利用 <code>&lt;script&gt;</code> 标签跨域特性进行跨域数据访问。</p>
</li>
<li><p>JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。</p>
</li>
</ul>
</li>
<li><p>缺点：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="2、操作系统"><a href="#2、操作系统" class="headerlink" title="2、操作系统"></a>2、操作系统</h1><h2 id="2-1、进程线程区别"><a href="#2-1、进程线程区别" class="headerlink" title="2.1、进程线程区别"></a>2.1、进程线程区别</h2><p>进程：是并发执行的<em><strong>*程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。*</strong></em></p>
<p><em><strong>*线程：是进程的一个执行单元，是进程内部的调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。*</strong></em></p>
<p><em><strong>*一个程序至少一个进程，一个进程至少一个线程。*</strong></em></p>
<p><em><strong>*进程是程序运行的实例。运行一个Java程序的实质就是启动一个java虚拟机进程。进程是程序向操作系统申请资源的基本单位。线程是进程中可独立执行的最小单位。一个进程可以包括多个线程，同一个进程中的所有线程共享该进程的资源。*</strong></em></p>
<p>多线程编程的实质就是将任务的处理方式由串行改为并发。</p>
<p>进程是资源分配最小单位，线程是程序执行的最小单位；进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间。线程是进程的一个实体，一个进程至少有一个线程,同一个进程的所有线程，共享所属进程的资源。</p>
<p>线程占用的资源比线程少很多，所以创建线程和切换线程的开销相对来说很小。但多进程程序更安全，生命力更强。一个进程的死亡不会对其他进程造成影响。而一个线程死掉，（可能会锁住资源）造成整个进程都死掉了。</p>
<h2 id="2-2、多进程和多线程的对比"><a href="#2-2、多进程和多线程的对比" class="headerlink" title="2.2、多进程和多线程的对比"></a>2.2、多进程和多线程的对比</h2><p>多进程，****每个进程拥有自己的数据，互不干涉****，共享复杂需要IPC，同步简单。占用内存多，切换复杂，CPU利用率低，创建销毁、切换复杂，速度慢，    进程间不会相互影响。 </p>
<p>多线程，****共享所属进程的数据*<em><strong>，共享简单，</strong></em>*同步比较难*<em><strong>。</strong></em>*占用内存少，切换简单*<em><strong>，C</strong></em>*PU利用率高，创建销毁、切换简单****，速度快，一个线程挂掉将导致整个进程挂掉。</p>
<h2 id="2-3、协程"><a href="#2-3、协程" class="headerlink" title="2.3、协程"></a>2.3、协程</h2><p><em><strong>*协程*<em><strong>是一种用户态的轻量级线程，</strong></em>*协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈*<em><strong>。协程调度切换时，</strong></em>*将寄存器上下文和栈保存到其他地方。在切回来的时候，恢复先前保存的寄存器上下文和栈*<em><strong>，直接操作栈则</strong></em>*基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。进程线程都是同步机制，而协程则是异步。协程不需要多线程的锁机制。*</strong></em></p>
<h2 id="2-4、进程间通信（IPC，InterProcess-Communication）"><a href="#2-4、进程间通信（IPC，InterProcess-Communication）" class="headerlink" title="2.4、进程间通信（IPC，InterProcess Communication）"></a>2.4、进程间通信（IPC，InterProcess Communication）</h2><p>进程间通信方式：管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等</p>
<p>管道:无名管道, 半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。只能用于父子进程和兄弟进程。</p>
<p>FIFO，也称为命名管道，是一种文件类型。FIFO的通信方式类似于在进程中使用文件来传输数据，只不过****FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。****可用于任何进程。</p>
<p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列独立于发送与接收进程。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</p>
<p>信号量（semaphore）与已经介绍过的 IPC 结构不同，****它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。****信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</p>
<p><em><strong>*共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。*</strong></em></p>
<p>\1. 管道（pipe）：管道是一种****半双工的通信方式，数据只能单向流动****，而且只能在具有血缘关系的进程间使用。</p>
<p>进程的血缘关系通常指父子进程关系。<em><strong>*管道分为pipe（无名管道）和*</strong>***</em>*ﬁ********fo（命名管道）两种****，有名管道也是半双</p>
<p>工的通信方式，但是它允许无亲缘关系进程间通信。</p>
<p>​    管道是一个<em><strong>*固定大小的缓冲区。在Linux中，该缓冲区的大小为1页*<em><strong>，即4K字节，使得它的大小不象</strong></em>*文件那样不加检验地增长。从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃.*</strong></em></p>
<p>2****. 信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问****。它通常作为一种锁</p>
<p>机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同</p>
<p>线程之间的同步手段。</p>
<p>\3. <em><strong>*消息队列（message queue）：*</strong>***</em>*消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识****。消</p>
<p>息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件</p>
<p>接收特定类型的消息。</p>
<p>4****信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生****。</p>
<p>\5. <em><strong>*共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进*</strong></em></p>
<p>****程创建，但多个进程都可以访问，****共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专</p>
<p>门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</p>
<p>\6. <em><strong>*套接字（socke*</strong></em>. <em><strong>*t）：socket，*</strong>***</em>*即套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）****</p>
<p>****系统的开发工作既可以在本地单机上进行，也可以跨网络进行****。也就是说它可以让不在同一台计算机但通过网</p>
<p>络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。</p>
<h2 id="2-5、用户态与核心态"><a href="#2-5、用户态与核心态" class="headerlink" title="2.5、用户态与核心态"></a>2.5、用户态与核心态</h2><p>​    防止用户进程访问对操作系统的稳定运行造成破坏。对一些资源的访问进行了等级划分。<em><strong>*内核态和用户态是操作系统的两种运行级别，内核态权限高，用户态权限低。*</strong></em></p>
<p>​    <em><strong>*操作系统的很多操作会消耗系统的物理资源，*<em><strong>例如创建一个新进程时，要做很多底层的细致工作，如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录、页表等，这些操作显然不能随便让任何程序都可以做，</strong></em>*于是就产生了特权级别的概念，与系统相关的一些特别关键性的操作必须由高级别的程序来完成，这样可以做到集中管理，减少有限资源的访问和使用冲突*</strong></em></p>
<p>​    <em><strong>*当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，*<em><strong>大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的内核</strong></em>*地址空间，*<em><strong>包括代码和数据；</strong></em>*当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。*</strong></em></p>
<h2 id="2-6、用户态和内核态的切换"><a href="#2-6、用户态和内核态的切换" class="headerlink" title="2.6、用户态和内核态的切换"></a>2.6、用户态和内核态的切换</h2><p>​    <em><strong>*进程大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态*</strong>***</em>*。切换到内核的方式有：系统调用、发生异常、外围设备的中断。****</p>
<h2 id="2-7、进程空间"><a href="#2-7、进程空间" class="headerlink" title="2.7、进程空间"></a>2.7、进程空间</h2><p>​    <em><strong>*内核态内存空间、用户态的堆栈*</strong>***</em>*（一般8M，*<em><strong>从高地址向低地址增长</strong></em>*）、****<em><strong>*数据段、进程代码段、*</strong></em> </p>
<p><em><strong>*线程共享的有：进程代码段、进程共有数据、文件描述符、信号处理器、进程当前目录、进程用户ID、进程组ID.*</strong></em></p>
<p><em><strong>*线程私有的：线程ID、*</strong>***</em>*寄存器*<strong><strong><strong>*的值、*</strong></strong></strong>*线程的栈****<em><strong>*、线程优先级、错误返回码、线程信号屏蔽码。*</strong></em></p>
<h2 id="2-8、线程上下文切换开销"><a href="#2-8、线程上下文切换开销" class="headerlink" title="2.8、线程上下文切换开销"></a>2.8、线程上下文切换开销</h2><p>上下文切换的开销包括直接开销和间接开销。直接开销有如下几点：</p>
<p>​    操作系统<em><strong>*保存恢复上下文(CPU寄存器值，程序计数器值等)所需的开销*</strong></em></p>
<p>​    线程调度器<em><strong>*调度线程的开销*</strong></em></p>
<p>间接开销有如下几点：</p>
<p>​    处理器****高速缓存重新加载****的开销</p>
<p>​    ****上下文切换可能导致整个一级高速缓存中的内容被冲刷****，即被写入到下一级高速缓存或主存</p>
<h2 id="2-9、线程间的几种通信方式"><a href="#2-9、线程间的几种通信方式" class="headerlink" title="2.9、线程间的几种通信方式"></a>2.9、线程间的几种通信方式</h2><p>1、<em><strong>*锁机制*</strong></em></p>
<p>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。</p>
<p>读写锁：允许多个线程同时读共享数据，而对写操作互斥。</p>
<p>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行</p>
<p>的。条件变量始终与互斥锁一起使用。</p>
<p>2、****信号量机制****：包括无名线程信号量与有名线程信号量</p>
<p>3、****信号机制****：类似于进程间的信号处理。</p>
<p>****线程间通信的主要目的是用于线程同步****，所以线程没有象进程通信中用于数据交换的通信机制。</p>
<h2 id="2-10、死锁条件"><a href="#2-10、死锁条件" class="headerlink" title="2.10、死锁条件"></a>2.10、死锁条件</h2><p>互斥、不可剥夺、循环等待、请求与保持</p>
<h2 id="2-11、分页分段"><a href="#2-11、分页分段" class="headerlink" title="2.11、分页分段"></a>2.11、分页分段</h2><p>​    传统存储管理方式：作业必须一次全部加载到内存中，方可运行。当作业很大，就无法运行。而且多道作业运行时，内存不足容纳所有作业，导致多道程序性能下降。操作系统引入了虚拟内存的概念，利用计算机的空间局部性和时间局部性原理，将程序分的一部分装入内存运行，其余部分留在外存，等需要的时候再讲外村的程序装入内存继续运行。虚拟内存好像给用户提供了一个比实际内存大得多的存储器。叫，虚拟存储器，大小由计算机地址结构决定。</p>
<p>​    虚拟内存实现方式：请求分页，请求分段，请求段页式存储管理。请求分页存储管理中，将虚拟地址内存空间划分位大小相等的页块，同时内存地址空间，也划分位等大小的页块。系统维持一个页表，存储这虚拟页号到物理快块号的映射。程序中的逻辑地址由两部分组成：页号P和页内位移量W。相邻的页面在内存中不一定相邻，即分配给程序的内存块之间不一定连续。逻辑地址转化为物理地址时，根据页表将页号转化为块号，块号*块大小加上页内偏移得到物理地址。</p>
<p>如果程序执行时，调用到不再内存中的虚拟页面时，发生缺页中断，将页由外村调入内存。如果内存已满，采用页面置换算法将老的淘汰，载入新的。页面置换算法常见的有FIFO,LRU。</p>
<p>优点：没有外碎片，每个内碎片不超过页的大小。</p>
<p>缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。</p>
<p>​    请求分段存储管理：将用户程序地址空间分成若干个大小不等的段，每段能够定义一组相对完整的逻辑信息。存储分配时，以段为单位，段内地址连续，段间不连续。虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。 分页对程序猿而言是不可见的。而分段通常对程序猿而言是可见的，因而分段为组织程序和数据提供了方便。段页式存储组织是分段式和分页式结合的存储组织方法。这样可充分利用分段管理和分页管理的长处。</p>
<p>优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。</p>
<p>缺点：会产生碎片。</p>
<p>用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。用分页方法来分配和管理实存。</p>
<p>优点：段页式管理是段式管理和页式管理相结合而成，具有两者的优点。</p>
<p>缺点：由于管理软件的增加，复杂性和开销也增加。另外需要的硬件以及占用的内存也有所增加，使得执行速度下降。</p>
<p>操作系统虚拟内存换页的过程</p>
<p>在进程开始运行之前，不是全部装入页面，而是装入一个或者零个页面，之后根据进程运行的需要，动态装入其他页面；当内存已满，而又需要装入新的页面时，则根据某种算法淘汰某个页面，以便装入新的页面。</p>
<p>在使用虚拟页式存储管理时需要在页表中增加一些内容：</p>
<p><em><strong>*页号、驻留位（中断位）、内存块号、外存地址、访问号、修改位*</strong></em></p>
<p><em><strong>*驻留位：表示该页在外存还是内存；*</strong></em></p>
<p><em><strong>*访问位：表示该页在内存期间是否被访问过，又称R位；*</strong></em></p>
<p><em><strong>*修改位：表示该页在内存中是否被修改过，又称M位；*</strong></em></p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<p>1、保护CPU现场</p>
<p>2、分析中断原因</p>
<p>3、转入缺页中断处理程序进行处理</p>
<p>4、恢复CPU现场，继续执行</p>
<h2 id="2-12、虚拟内存换页的算法有哪些？"><a href="#2-12、虚拟内存换页的算法有哪些？" class="headerlink" title="2.12、虚拟内存换页的算法有哪些？"></a>2.12、虚拟内存换页的算法有哪些？</h2><p><em><strong>*最优页面置换算法*</strong>***</em>*、*<strong><strong><strong>*先进先出页面置换算法（FIFO）及其改进*</strong></strong></strong>*、*<strong><strong><strong>*最近最少使用页面置换算法（LRU）*</strong></strong></strong>*、*<strong><strong><strong>*时钟页面置换算法（clock）*</strong></strong></strong>*、*<strong><strong><strong>*最近未使用页面置换算法（NRU）*</strong></strong></strong>*;****</p>
<p>换页算法里面，FIFO有什么缺点？怎么改进？</p>
<p>先进先出实现简单，但并没有考虑局部性原理，最近访问过的数据不久之后很可能会再次被访问。性能可能会很差。还会发生Belady异常现象， 使用FIFO算法时，四个页框时缺页次数比三个页框时多。这种奇怪的情况称为Belady异常现象。</p>
<p>称为第二次机会算法。即给每个页面增加一个R位，表示最近访问过，每次先从链表头开始查找，如果R置1位，清除R位并且把该页面节点放到链表结尾；如果R是0，那么就是又老又没用到，替换掉。</p>
<h2 id="2-13、进程调度算法"><a href="#2-13、进程调度算法" class="headerlink" title="2.13、进程调度算法"></a>2.13、进程调度算法</h2><p><em><strong>*先来先服务调度算法、短作业(进程)优先调度算法、优先权调度算法的类型、高响应比优先调度算法、时间片轮转法、多级反馈队列调度算法、*</strong></em></p>
<h2 id="2-14、部分面试题"><a href="#2-14、部分面试题" class="headerlink" title="2.14、部分面试题"></a>2.14、部分面试题</h2><p>进程的内存空间是怎么样的？</p>
<p>堆快还是栈快？</p>
<p>​    JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低。</p>
<p>Java的同步机制有哪些：几种锁把。</p>
<p>Java中如果我有两个long数组，想要取他们的交集</p>
<p>Java有没有遇到过fullGC，触发fullGC的条件以及如何排查</p>
<p>网页跳转怎么实现，结合具体的场景 前端</p>
<p>301 和 302 什么区别？结合具体场景</p>
<p>​    301和302都是重定向状态码。说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取。301永久重定向，表示旧地址的资源永久性移除了，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。302临时重定向。表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。</p>
<p>​    网页目录结构调整，网页扩展名调整，网页被移动到一个新的地址，这些都要永久重定向301.</p>
<p>如果网页调整是临时的，之后会调整过来，就用临时重定向302；</p>
<p>504 什么意思？</p>
<p>​    网关超时。</p>
<p>怎么在前端实现网页跳转，用什么函数？</p>
<p><em><strong>*onclick跳转*</strong></em></p>
<p><em><strong>*设置window的location.href属性*</strong></em></p>
<p>  <em><strong>*οnclick=”window.location.href=’URL’”*</strong></em></p>
<p>  οnclick=”location=’URL’”</p>
<p><em><strong>*调用window的open方法*</strong></em></p>
<p>  ο<em><strong>*nclick=”window.open(‘URL’,’_blank’);” // 在新窗口打开*</strong></em></p>
<p>  οnclick=”window.open(‘URL’,’_self’);” // 覆盖当前页</p>
<p><em><strong>*a标签跳转*</strong></em></p>
<p>    <a href="URL" target="_blank">Preface</a> // 在新窗口打开</p>
<p><a href="URL" target="_self">Preface</a> // 覆盖当前页，target属性默认为_self，此处可省略</p>
<p>req.getRequestDispatcher(“ok.jsp”).forward(req,resp)</p>
<p>resp.sendRedirect(“ok.jsp”);//URL发生变化</p>
<p>任务处理时间 100ms，服务器 4 核 8G 如何设计线程池达到 1000qps？任务是 90ms 在 IO，10ms 在计算的情况下怎么弄？全在计算呢？</p>
<p>10G 数据，1G 内存，如何快速找到重复出现的数据？</p>
<p>10G 数据，1G 内存，如何快速找到重复出现次数最多的数据？</p>
<p>如何检测跳转页面的登录状态session,cookie</p>
<p>5.java 设计模式， jdk里用到了哪些设计模式。</p>
<p>6.NIO 讲一讲。</p>
<p>不用final还可以用什么办法使得这个类不被继承、</p>
<p>java初始化的顺序</p>
<p>自旋锁 是公平吗？不是</p>
<p>自旋锁 怎么才能公平。</p>
<p>客户抱怨你们网站太慢，怎么排查问题？</p>
<p>SDS优点，链表、跳表的实现与复杂度</p>
<p>内核态和用户态的切换</p>
<p>select poll epoll三连</p>
<p>虚拟内存的作用</p>
<p>CPU二级缓存</p>
<p>如何快速复用处于TIME_WAIT的连接</p>
<p>三种I/O多路复用</p>
<p>一个TCP报文从本机到对方主机的过程</p>
<p>路由表的结构是什么样的</p>
<p>海量数据(100亿)找最大的100w个数，时间复杂度nlogm，n时100亿，m是100w</p>
<p>衍生出堆排序过程讲一下</p>
<p>redis里几个常用命令？</p>
<p>linux常用命令？</p>
<p>解释XSS 和 CSRF，它们之间有什么区别，以及如何防范。</p>
<p>交换机和路由器区别</p>
<p>17、linux读文件的过程</p>
<p>18、ping 127.0.0.1经过哪些层</p>
<p>19、设置mtu有什么用</p>
<p>Linux 中能否删除一个正在运行的文件</p>
<p>Linux 常用的命令，如何排查 bug</p>
<h1 id="3、集合框架"><a href="#3、集合框架" class="headerlink" title="3、集合框架"></a>3、集合框架</h1><h2 id="3-1、ArrayList"><a href="#3-1、ArrayList" class="headerlink" title="3.1、ArrayList"></a>3.1、ArrayList</h2><p>​    底层实现是Object数组（transient Object[] elementData）;</p>
<p>​    默认长度是10, 扩容是变成1.5倍：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</p>
<p>​    扩容是创建新的数组，elementData = Arrays.copyOf(elementData, newCapacity)</p>
<p>​    增减元素，会造成数组元素的移动，使用System.arraycopy();</p>
<p>​    支持随机访问;     </p>
<h2 id="3-2、LinkedList"><a href="#3-2、LinkedList" class="headerlink" title="3.2、LinkedList"></a>3.2、LinkedList</h2><p>​    LinkedList 实际上是通过双向链表去实现的,内部类Node(val,next,pre)是链表的节点;</p>
<p>  它也可以被当作堆栈、队列或双端队列进行操作。</p>
<p>  不支持随机访问，但删除、插入元素时间不受元素位置影响，近似O(1),而ArryList是O(n);</p>
<h2 id="3-3、Vector"><a href="#3-3、Vector" class="headerlink" title="3.3、Vector"></a>3.3、Vector</h2><p>  底层实现也是Object数组，线程安全,支持随机访问</p>
<p>  默认长度是10， capacityIncrement增长系数，如果设置，每次扩展都是增加这个数，否则扩容为2倍。</p>
<p>​    (01) 对于需要快速插入，删除元素，应该使用LinkedList。</p>
<p>  (02) 对于需要快速随机访问元素，应该使用ArrayList。</p>
<p>  (03) 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。</p>
<p>对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。</p>
<p><em><strong>*Collections.synchronizedList(new ArrayList&lt;Map&lt;String,Object&gt;&gt;());*</strong></em></p>
<h2 id="3-4、快速失败（fail—fast）"><a href="#3-4、快速失败（fail—fast）" class="headerlink" title="3.4、快速失败（fail—fast）"></a>3.4、快速失败（fail—fast）</h2><p>​    在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception;</p>
<p>​    迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。<em><strong>*每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。*</strong></em></p>
<p>​    <em><strong>*当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。这个机制是防止多线程并发访问list可能带来错误，所以抛出异常提醒一下。*</strong></em></p>
<p>​    <em><strong>*Fail-Fast : List维护一个modCount变量，add、remove、clear等涉及了改变list元素的个数的方法都会导致modCount的改变。如果判断出modCount != expectedModCount,*</strong></em> <em><strong>*抛出ConcurrentModificationException 异常，从而产生fail-fast机制。*</strong></em></p>
<p>​    <em><strong>*并发安全的解决方案：*</strong></em></p>
<p>****1、****Collections.synchronizedList。或者每个访问操作sychronized加锁。</p>
<p><em><strong>*2*</strong></em> <em><strong>*CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。*</strong></em></p>
<p>CopyOnWriterArrayList所代表的核心概念就是****：任何对array在结构上有所改变的操作****（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。</p>
<h2 id="3-5、安全失败（fail—safe）"><a href="#3-5、安全失败（fail—safe）" class="headerlink" title="3.5、安全失败（fail—safe）"></a>3.5、安全失败（fail—safe）</h2><p>​    采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>​    <em><strong>*java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。*</strong></em></p>
<p><em><strong>*fail-safe机制有两个问题*</strong></em></p>
<p>（1）需要复制集合，产生大量的无效对象，开销大</p>
<p>（2）无法保证读取的数据是目前原始数据结构中的数据。</p>
<h2 id="3-6、HashMap"><a href="#3-6、HashMap" class="headerlink" title="3.6、HashMap"></a>3.6、HashMap</h2><p>​    HashMap底层是数组和链表结合在一起，也就是链表散列；  怎么更通顺的说出来？？？</p>
<p>​    hashMap底层是数组+链表+红黑树。首先是table数组，每个数组存放的是链表，链表的每一个节点都是&lt;Key,Value&gt;型的Node节点。</p>
<p>  JDK1.8之后，当链表长度超过阈值，默认为8时，为加快检索速度，将链表转化成红黑树。</p>
<p>默认加载因子是 0.75, 默认的初始容量是16，容量就是数组长度，如果size大于容量*加载因子，就进行rehash;</p>
<p>容量扩容成两倍;</p>
<p>  如果初始化时指定初始容量，要向上取到2的N次方。因为对key的hashCode进行扰动函数处理之后，是根据（n-1）&amp; hash判断元素在数组中的位置的。</p>
<p>  使用(n-1) &amp; hash是为了效率考虑，而只有数组长度为2的N次方，才能使n-1 &amp; hash起到取余操作的作用。</p>
<p>  hash(key) —-&gt; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);—–key的扰动函数;减少碰撞;</p>
<p>  (n-1) &amp; hash—判断元素在数组中的位置。数组中存放的是Node&lt;k,v&gt;节点。</p>
<p>  查询get(key)时，先判断在数组中的位置，key的hashCode无符号右移16，再异或，取余;然后在链表中搜索;</p>
<p>put,也是先查询在数组中的问题，然后判断链表中，key是否存在，存在就更新， 不存在头插法，插入链表;</p>
<p>​    红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。中间有个差值7可以防止链表和树之间频繁的转换。</p>
<p>​    而且理想情况下，<em><strong>*在随机哈希代码下，桶中的节点频率遵循泊松分布*<em><strong>，文中给出了桶长度k的频率表。<br>由频率表可以看出，</strong></em>*桶的长度超过8的概率非常非常小（千万分之一）。所以作者应该是根据概率统计而选择了8作为阀值。*</strong></em></p>
<p>​    <em><strong>*TreeMap是基于红黑树实现的一个保证有序性的Map 基于红黑树，所以TreeMap的时间复杂度是O(log n)，*</strong></em></p>
<p><em><strong>*Hash*</strong>***</em>*Map****<em><strong>*冲突解决方法：开发地址法，当冲突发生时，使用某种探查(亦称探测)技术（线性探测，随机探测，不同的关键字使用不同的探测距离）在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者找到空。*</strong></em></p>
<p><em><strong>*2、拉链法*</strong></em></p>
<p><em><strong>*多线程PUT可能发生的问题：*</strong></em></p>
<p><em><strong>*1、当多个线程同时执行addEntry(hash,key ,value,i)时，如果产生哈希碰撞，导致两个线程得到同样的bucketIndex去存储，就可能会发生元素覆盖丢失的情况*</strong></em></p>
<p><em><strong>*2、JDK*</strong>***</em>*1.7****<em><strong>*以前。在向HashMap put元素时，会检查HashMap的容量是否足够，如果不足，则会新建一个比原来容量大两倍的Hash表，然后把数组从老的Hash表中迁移到新的Hash表中，迁移的过程就是一个rehash()的过程，多个线程同时操作就有可能会形成循环链表。*</strong></em></p>
<p><em><strong>*扩容方式：遍历*</strong>***</em>*【】****尾插法将节点插入到新的hashmap中。</p>
<p>当然，他们都不是线程安全的，线程安全还是得用ConcurrentHashMap;</p>
<h2 id="3-7、红黑树的特性"><a href="#3-7、红黑树的特性" class="headerlink" title="3.7、红黑树的特性"></a>3.7、红黑树的特性</h2><p>  （1）每个节点或者是黑色，或者是红色。</p>
<p>  （2）根节点是黑色。</p>
<p>  （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p>
<p>  （4）如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>  （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。）</p>
<p>   它的时间复杂度是O(lgn)，一棵含有n个节点的红黑树的高度至多为2log(n+1).</p>
<h2 id="3-8、HashTable与hashMap的不同"><a href="#3-8、HashTable与hashMap的不同" class="headerlink" title="3.8、HashTable与hashMap的不同"></a>3.8、HashTable与hashMap的不同</h2><p>  HashTable线程安全，方法都是sychronized修饰;hashMap线程不安全；</p>
<p>  HashTable,Key和Value都不能为null;而hashMap可以有一个null可以，value是否为null无所谓;</p>
<p>  HashTable初始容量11，扩展2*n+1,HashMap,初始16，扩容加倍；初始容量向上取到2的N次方;</p>
<p>HashMap当链表长度大于阈值时，转化成红黑树，而HashTable没有。</p>
<h2 id="3-9、ConcurrentHashMap的底层实现！！！！！！！！！！！！！！！"><a href="#3-9、ConcurrentHashMap的底层实现！！！！！！！！！！！！！！！" class="headerlink" title="3.9、ConcurrentHashMap的底层实现！！！！！！！！！！！！！！！"></a>3.9、ConcurrentHashMap的底层实现！！！！！！！！！！！！！！！</h2><p>  HashMap多线程情况下，可能造成死循环，当扩容时，头插法+没有同步控制，很可能造成循环链表，造成死循环</p>
<p>  JDK1.8声明两对指针，维护两个链表，依次在末端添加新的元素,解决了死循环，但依然存在很多问题，例如数据丢失：</p>
<p>​    HashTable是线程安全的，使用synchronized来保证线程安全，锁住整个hash表，并发效率低下;</p>
<p>  JUC中的ConcurrentHashMap,1.5-1.7使用分段锁机制，将整个数组分割分段，每一把锁只锁定segment,</p>
<p>将整个Hash表切分多个Segment；而每个Segment元素，类似于一个Hashtable;</p>
<p><em><strong>*Segment的数量由所谓的concurrentcyLevel决定， 默认是16； 和HashMap的初始容量一致， 也可以在相应构造函数直接指定。 同样是2的幂数值;*</strong></em></p>
<p>  当一个线程占用锁访问其中一个segment的时候，其他segment也能被其他线程访问</p>
<p>  ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部</p>
<p>  JDK1.8之后，抛弃了segment的概念，直接用Node数组+链表+红黑树的数据结构实现，并发控制采用CAS+synchronize;</p>
<p>  <em><strong>*put的时候, 判断是否kv为null, hash定位桶位置之后，如果为空，cas写入，否则synchronize加锁写入(更新或插入)如果链表长度达到8，将链表转化成红黑树；*</strong></em></p>
<p>  get的时候，没有并发控制；在链表查询的时候，会判断是红黑树还是链表，两种查询方式；</p>
<p><em><strong>*synchronize只锁定当前链表或红黑二叉树的首节点。*</strong></em></p>
<p>　　<strong>①</strong> <strong>判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤****②</strong></p>
<p>　　<strong>②</strong> <strong>计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤****③</strong></p>
<p>　　<strong>③</strong> <strong>根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤****④</strong></p>
<p>　　<strong>④</strong> <strong>若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤****⑤</strong></p>
<p>　　<strong>⑤</strong> <strong>对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤****⑥</strong></p>
<p>　　<strong>⑥</strong> <strong>若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。</strong></p>
<h2 id="3-10、面试题"><a href="#3-10、面试题" class="headerlink" title="3.10、面试题"></a>3.10、面试题</h2><h3 id="3-10-1、常⽤的集合类有哪些？"><a href="#3-10-1、常⽤的集合类有哪些？" class="headerlink" title="3.10.1、常⽤的集合类有哪些？"></a>3.10.1、常⽤的集合类有哪些？</h3><p>主要分为三类，Map、Set、List</p>
<ul>
<li><p>Map: HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap</p>
</li>
<li><p>Set：HashSet、LinkedHashSet、TreeSet</p>
</li>
<li><p> List: ArrayList、LinkedList</p>
</li>
</ul>
<h3 id="3-10-2、-ArrayList和LinkedList内部实现⼤致是怎样的？他们之间的区别和优缺点？"><a href="#3-10-2、-ArrayList和LinkedList内部实现⼤致是怎样的？他们之间的区别和优缺点？" class="headerlink" title="3.10.2、 ArrayList和LinkedList内部实现⼤致是怎样的？他们之间的区别和优缺点？"></a>3.10.2、 ArrayList和LinkedList内部实现⼤致是怎样的？他们之间的区别和优缺点？</h3><ul>
<li> ArrayList</li>
<li>底层实现是Object数组（transient Object[] elementData），随机访问速度快</li>
<li>默认长度是10, 扩容是变成1.5倍：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);扩容⽅式是利⽤数组的复制，因此有⼀定的开销。</li>
<li>增减元素，会造成数组元素的移动，使用System.arraycopy();</li>
<li>LinkedList：<ul>
<li>LinkedList 实际上是通过双向链表去实现的,内部类Node(val,next,pre)是链表的节点;</li>
<li>属性first，last分别用来指向首尾节点，size用来记录链表长度</li>
<li>可以被当作堆栈、队列或双端队列进行操作</li>
</ul>
</li>
<li>ArrayList查找较快，插⼊、删除较慢，LinkedList查找较慢，插⼊、删除较快。</li>
</ul>
<h3 id="3-10-3、-Collections-工具类和-Arrays-工具类常见方法"><a href="#3-10-3、-Collections-工具类和-Arrays-工具类常见方法" class="headerlink" title="3.10.3、 Collections 工具类和 Arrays 工具类常见方法"></a>3.10.3、 Collections 工具类和 Arrays 工具类常见方法</h3><ul>
<li><p>Collections</p>
<ul>
<li><p>排序</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span>List list<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//反转</span>
<span class="token keyword">void</span> <span class="token function">shuffle</span><span class="token punctuation">(</span>List list<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//随机排序</span>
<span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>List list<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//按自然排序的升序排序</span>
<span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> Comparator c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//定制排序，由Comparator控制排序逻辑</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//交换两个索引位置的元素</span>
<span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> <span class="token keyword">int</span> distance<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>查找,替换操作</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//对List进行二分查找，返回索引，注意List必须是有序的</span>
<span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span>Collection coll<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span>
<span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span>Collection coll<span class="token punctuation">,</span> Comparator c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span>
<span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//用指定的元素代替指定list中的所有元素。 </span>
<span class="token keyword">int</span> <span class="token function">frequency</span><span class="token punctuation">(</span>Collection c<span class="token punctuation">,</span> Object o<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//统计元素出现次数</span>
<span class="token keyword">int</span> <span class="token function">indexOfSubList</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> List target<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//统计targe在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span>
<span class="token keyword">boolean</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span>List list<span class="token punctuation">,</span> Object oldVal<span class="token punctuation">,</span> Object newVal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//用新元素替换旧元素</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>同步控制</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token function">synchronizedCollection</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>T<span class="token operator">></span>  c<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回指定 collection 支持的同步（线程安全的）collection。</span>
<span class="token function">synchronizedList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回指定列表支持的同步（线程安全的）List。 </span>
<span class="token function">synchronizedMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回由指定映射支持的同步（线程安全的）Map。</span>
<span class="token function">synchronizedSet</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span>T<span class="token operator">></span> s<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回指定 set 支持的同步（线程安全的）set。 </span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合</strong></p>
</li>
</ul>
</li>
<li><p>Arrays</p>
<pre class="line-numbers language-java"><code class="language-java">排序 <span class="token operator">:</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
查找 <span class="token operator">:</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
比较<span class="token operator">:</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
填充 <span class="token operator">:</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
转列表<span class="token operator">:</span> <span class="token function">asList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
转字符串 <span class="token operator">:</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
复制 <span class="token operator">:</span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h1 id="4、JVM"><a href="#4、JVM" class="headerlink" title="4、JVM"></a>4、JVM</h1><h2 id="4-1、JVM内存"><a href="#4-1、JVM内存" class="headerlink" title="4.1、JVM内存"></a>4.1、JVM内存</h2><p>​    线程私有：PC程序计数器，虚拟机栈，本地方法栈   线程共享：堆，方法区，直接内存</p>
<p>  ****PC：****下一条执行字节码指令的地址，唯一不会发生OutOfMemory的地方；</p>
<p>  <em><strong>*虚拟机栈*<em><strong>：线程私有，</strong></em>*生命周期和线程一致；*<em><strong>存在</strong></em>*局部变量表（基本数据类型和引用类型变量），操作数栈，动态链接，方法出口信息。*</strong></em></p>
<p>  两种异常：当栈的深度超过最大申请申请深度时，StackOverFlowError;内存不够Java虚拟机栈动态扩展时，OutOfMemory;</p>
<p>  栈中存放的是栈帧，一个函+数一个栈帧;</p>
<p>​    ****本地方法栈****，存放本地方法的栈，其他和虚拟机栈一样。</p>
<p>​    ****堆****：唯一作用：存储对象内存；几乎所有的对象和数组都在这分配内存；是垃圾回收的主要地方；为更好的回收内存和分配内存，将对堆进行分代，分为新生代和老年代，不同的代采用不同的垃圾回收算法；老年代基本采用标记整理，只有cms采用标记清除。</p>
<p>  新生采用复制算法，为提高内存利用率，将新生代分为Eden（伊甸）区，survivor([səˈvaɪvə(r)]) s0, s1，比例为8:1:1。每次留1块s区作为复制的备份内存，同时将老年代作为分配担保区。</p>
<p>  <em><strong>*方法区*<em><strong>：</strong></em>*存储已被虚拟机加载*</strong>***</em>*的类信息、常量、静态变量、即时编译器编译后的代码等********数据****。线程共享。JDK1.8被元空间取代，元空间位于直接内存；</p>
<p>  替换的一个原因是，方法区有JVM设置固定大小上限，而元空间直接使用内容，只受限于直接内存，不会发生OutOfMemory;</p>
<p>  <em><strong>*常量池*<em><strong>，1.8之前，放在方法区，大小受限于方法区。</strong></em>*而1.8存放堆中*<em><strong>。主要有</strong></em>*字面量(字符串基本数据类型，final常量值)和符号引用.*</strong></em></p>
<p>  ****直接内存****，不是运行时数据区的一部分，也不是虚拟机规范定义的内存，也可能OutOfMemory;</p>
<h2 id="4-2、堆内存分配策略"><a href="#4-2、堆内存分配策略" class="headerlink" title="4.2、堆内存分配策略"></a>4.2、堆内存分配策略</h2><p>1、对象优先在新生代伊甸区分配内存。2、大对象直接进去老年代(长字符串和数组)3、长期存活的对象进入老年代。一次Minor[ˈmaɪnə(r)]GC，年龄加一，默认年龄15进入老年代。4、动态年龄判定。相同年龄所有对象大小的总和大于 Survivor 空间的一半，大于等于该年龄的对象进入老年代。</p>
<p>  新生代 GC（Minor GC）,发生在新生代的垃圾回收动作，频繁且快。 </p>
<p>  老年代 GC（Major GC/Full GC，发生在老年代的垃圾回收，通常伴随着至少一次的minor gc。速度慢。</p>
<h2 id="4-3、Full-GC触发"><a href="#4-3、Full-GC触发" class="headerlink" title="4.3、Full GC触发"></a>4.3、Full GC触发</h2><p><em><strong>*1、老年代空间不足2、方法区空间不足。3、调用System.gc(),建议JVM进行full gc. 4、没有足够的连续空间分配给大对象。5、长期存活的对象转入老年代，空间不足。6、新生代垃圾回收存活的对象太多，S1放不下，老年代担保空间不足。*</strong></em></p>
<h2 id="4-4、判断对象是否存活"><a href="#4-4、判断对象是否存活" class="headerlink" title="4.4、判断对象是否存活"></a>4.4、判断对象是否存活</h2><p>  1引用计算法，给对象添加一个引用计数器，每次被引用，计算器加一，引用失效，计算减一。当引用数为0时，表示对象不存活。但无法解决循环引用问题。</p>
<p>  2、可达性分析法。以****GC Roots****对象为起点，向下搜索，节点所走的路径成为引用链。当一个对象和引用链没有相连时，表示这个对象不可达。主要方法。GC Roots: 虚拟机栈引用的对象，本地方法栈引用的对象，方法区静态属性引用的对象，方法区常量引用的对象。</p>
<p>​    对象的存活都和引用有关，引用类型分为强引用，软引用，弱引用，虚引用。</p>
<p>  强引用，new的对象。垃圾回收器绝不会回收它。软引用，空间不足，回收这些对象的内存。弱引用，只要发现，马上回收。虚引用，形同虚设，任何时候都可能被回收</p>
<p>  很少用虚和弱，软引用很多，可以加快jvm对垃圾内存的回收速度。</p>
<h2 id="4-5、回收对象的两次标记过程"><a href="#4-5、回收对象的两次标记过程" class="headerlink" title="4.5、回收对象的两次标记过程"></a>4.5、回收对象的两次标记过程</h2><p>可达性分析的不可达对象，并不马上回收。真正死亡至少经过两次标记：对可达性分析不可达的对象进行第一次标记，并进行筛选。筛选条件是重写finalize方法且没有调用的对象，将其放入队列中，进行第二次标记。在执行finalize方法时，该对象依然没有被引用，才会被真正回收掉。finalize方法只能被调用一次。</p>
<p>  判断常量是否是****废弃常量****？  运行时常量池是主要的回收对象。常量不被引用，就可以被回收。</p>
<p>  判断一个类是否是****无用的类****？ 1，类的实例对象全被回收。2.加载类的ClassLoader被回收。3，堆中的Class对象(在运行时期提供或者获得某个对象的类型信息)没有被引用。</p>
<h2 id="4-6、垃圾回收算法"><a href="#4-6、垃圾回收算法" class="headerlink" title="4.6、垃圾回收算法"></a>4.6、垃圾回收算法</h2><p>标记-清除：先标记需清除的对象，统一回收—-效率不高，会产生大量不连续的碎片。</p>
<p>  复制算法：将内存分块，每次只使用一块，使用完后，将存活的对象复制到另一块上。</p>
<p>  标记整理：先标记存活对象，然后让所有存活对象向一端移动，直接清理端边界以外的内存。</p>
<p>  分代算法，堆分为新生代和老年代，新生代每次收集都会有大量的对象死去，选择复制算法。将新生代分为伊甸区，和s0,s1.大小比例为8:1:1</p>
<p>  老年代存活率比较高，且没有额外空间进行分配担保，选择标记清除或者标记整理算法。</p>
<h2 id="4-7、垃圾回收器"><a href="#4-7、垃圾回收器" class="headerlink" title="4.7、垃圾回收器"></a>4.7、垃圾回收器</h2><p>  serial[ˈsɪriəl],串行收集器。单线程，垃圾回收的时候，必须暂停其他工作。新生复制，老年标记整理。简单高效。</p>
<p>  ParNew 收集器。serial的多线程版本。</p>
<p>  Parallel Scavenge [ˈpærəlel] [ˈskævɪndʒ] 收集器,复制算法的多线程收集器。注重吞吐量，cpu运行代码时间/cpu耗时总时间。新生复制，老年标记整理</p>
<p>  Serial Old 收集器，老年代版本。</p>
<p>  Parallel Old 收集器，Parallel老年代版本。</p>
<p>  CMS 收集器，注重最短时间停顿。并发收集器，垃圾收集线程与用户线程（基本上）同时工作。  标记清除算法。</p>
<p>  ****初始标记：****暂停其他线程，标记与GC roots直接关联的对象。并发标记,可达性分析过程。重新标记，对并发标记过程中，用户线程修改的对象再次标记一下。并发清除：标记完成之后，和用户线程并发清除死亡对象。</p>
<p>  主要优点：<em><strong>*并发收集、低停顿。*</strong></em></p>
<p>  缺点，<em><strong>*无法处理浮动垃圾，使用标记清除算法，导致大量不连续碎片产生。对CPU资源敏感，可能导致用户线程变慢。*</strong></em></p>
<p><em><strong>*G1收集器，低停顿， 高吞吐。*</strong></em></p>
<p>可预测停顿（让使用者指定垃圾回收时间），空间整合（标记整理算法），分代收集：分代概念保留，但不需要和其他收集器配合就能独立管理整个堆。并行和并发：并行：利用多CPU、多核环境下的硬件优势。并发：两个阶段的垃圾回收能和用户线程并发。</p>
<p>  <em><strong>*垃圾回收时，*</strong>***</em>*对新生代和老年代一视同仁。将整个堆划分成多个大小相等的Region。G1能跟踪每个Region的回收价值和停顿时间成本*<strong><strong><strong>*。步骤，初始标记，标记与GC roots直接关联的对象，并发标记，可达性分析过程。最终标记，对并发标记过程中，用户线程修改的对象再次标记一下。*</strong></strong></strong>*筛选回收：对各个Region的回收价值和成本进行排序，然后根据用户所期望的GC停顿时间制定回收计划并回收。****</p>
<h2 id="4-8、创建一个对象的步骤"><a href="#4-8、创建一个对象的步骤" class="headerlink" title="4.8、创建一个对象的步骤"></a>4.8、创建一个对象的步骤</h2><p>  Step1,类加载检查，先检查对象所属类是否已被加载、解析、初始化过，如果没有，先进行类加载过程；</p>
<p>  Step2,分配内存，为对象分配内存(两种分配方式指针碰撞(标记整理)和空闲列表(标记清除))。</p>
<p>  Step3,初始化为0值，将内存空间除了对象头都初始化为0值。</p>
<p>  Step4,设置对象头，类的元数据信息，对象哈希码，对象年龄等</p>
<p>  Step5,执行init方法，对对象真正初始化。</p>
<h2 id="4-9、对象的内存布局"><a href="#4-9、对象的内存布局" class="headerlink" title="4.9、对象的内存布局"></a>4.9、对象的内存布局</h2><p>在内存中主要分为三部分：对象头，实例数据和对象对齐。实例数据时对象真正的有效信息，对其填充部分起占位作用。</p>
<p>  对象头一是<em><strong>*运行时数据（哈希码，GC年龄，锁状态等）二是类型指针，指向类元数据。*</strong></em></p>
<h2 id="4-10、对象访问形式"><a href="#4-10、对象访问形式" class="headerlink" title="4.10、对象访问形式"></a>4.10、对象访问形式</h2><p>1、使用句柄、2直接使用指针。使用句柄：在内存中开辟句柄池，栈中的引用变量，指向句柄池中的句柄地址，指向堆中的实例对象数据，和方法区的对象类型数据。</p>
<p>  直接指针，栈中的引用对象变量，直接指向堆中的对象，其中堆中的对象头又指向方法区中的对象类型数据。</p>
<h2 id="4-11、类加载过程"><a href="#4-11、类加载过程" class="headerlink" title="4.11、类加载过程"></a>4.11、类加载过程</h2><p>虚拟机将Class文件加载到虚拟机中，并初始化。主要三步，加载，链接，初始化。链接又分验证，准备，解析。</p>
<p>  <em><strong>*加载*<em><strong>：</strong></em>*主要完成三件事：通过全类名获取类的二进制字节流。2，将类的静态存储结构转化为方法区的运行时数据结构。3,在内存中生成类的Class对象，作为方法区数据的入口。*</strong></em></p>
<p>  ****验证****，对文件格式，元数据，字节码，符号引用等验证正确性。</p>
<p>  ****准备****，在方法区内为类变量分配内存并设置为0值。</p>
<p>  ****解析****，将符号引用转化为直接引用。</p>
<p>  ****初始化****，执行类构造器clinit方法，真正初始化。</p>
<p>类加载过程的加载的第一步，将.class文件加载到内存是由类加载器完成的。</p>
<h2 id="4-12、类加载器"><a href="#4-12、类加载器" class="headerlink" title="4.12、类加载器"></a>4.12、类加载器</h2><p>  BootstrapClassLoader启动类加载器,除了他其他类加载器都继承Java.lang.ClassLoader。  /lib下的jar包和类。</p>
<p>  ExtensionClassLoader扩展类加载器， /lib/ext目录下的jar包和类。</p>
<p>  AppClassLoader应用类加载器，当前classPath下的jar包和类。</p>
<h2 id="4-13、双亲委派机制"><a href="#4-13、双亲委派机制" class="headerlink" title="4.13、双亲委派机制"></a>4.13、双亲委派机制</h2><p>  一个类加载器收到类加载请求之后，首先判断当前类是否被加载过。已经被加载的类会直接返回，如果没有被加载，首先将类加载请求转发给父类加载器，一直转发到启动类加载器，只有当父类加载器无法完成时才尝试自己加载。</p>
<p>  ****好处****1、可以避免类的重复加载。(相同的类被不同的类加载器加载会产生不同的类)，双亲委派保证了java程序的稳定运行。2、保证核心API不被修改。</p>
<p>  自定义类加载器:（1）继承ClassLoader（2）重写findClass（）方法 （3）调用defineClass（）方法</p>
<p><em><strong>*破坏双亲委派机制，重载loadClass() 方法。*</strong></em></p>
<h2 id="4-14、创建对象的几种方式"><a href="#4-14、创建对象的几种方式" class="headerlink" title="4.14、创建对象的几种方式"></a>4.14、创建对象的几种方式</h2><p>​    用new关键字创建</p>
<p>​    调用对象的clone方法</p>
<p>​    利用反射，调用Class类的或者是Constructor类的newInstance（）方法</p>
<p>​    用反序列化，调用ObjectInputStream类的readObject（）方法</p>
<h2 id="4-15、jvm面试题"><a href="#4-15、jvm面试题" class="headerlink" title="4.15、jvm面试题"></a>4.15、jvm面试题</h2><h3 id="4-15-1、-jvm内存结构？为什么需要GC？"><a href="#4-15-1、-jvm内存结构？为什么需要GC？" class="headerlink" title="4.15.1、 jvm内存结构？为什么需要GC？"></a>4.15.1、 jvm内存结构？为什么需要GC？</h3><ul>
<li><p>内存结构</p>
<ul>
<li><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210528153133388.png" alt="image-20210528153133388"></li>
</ul>
</li>
<li><p>垃圾回收：垃圾回收可以有效的防⽌内存泄漏，有效的使⽤可以使⽤的内存。</p>
<ul>
<li>垃圾回收器通常是作为⼀个<strong>单独的低优先级的线程</strong>运⾏，<strong>不可预知</strong>的情况下对内存堆中<strong>已经死亡的或者⻓时间没有使⽤的对象</strong>进⾏清除和回收，程序员不能实时的调⽤垃圾回收器对某个对象或所有对象进⾏垃圾回收。</li>
<li>垃圾回收算法有标记-清除、  复制算法、标记-整理算法、分代回收算法等</li>
<li>垃圾收集器常见有CMS和G1<ul>
<li>CMS<ul>
<li>优点：并发收集、低停顿。</li>
<li>缺点：无法处理浮动垃圾，使用标记清除算法，导致大量不连续碎片产生。对CPU资源敏感，可能导致用户线程变慢。</li>
</ul>
</li>
<li>G1：  对新生代和老年代一视同仁。将整个堆划分成多个大小相等的Region。G1能跟踪每个Region的回收价值和停顿时间成本，优先处理回收价值收益最大的那些region<ul>
<li>优点：低停顿， 高吞吐</li>
<li>流程<ul>
<li>初始标记：标记与GC roots直接关联的对象</li>
<li>并发标记：从GC root开始对对堆中对象进行可达性分析</li>
<li>最终标记：对并发标记过程中，用户线程修改的对象再次标记一下</li>
<li>筛选回收：对各个Region的回收价值和成本进行排序，然后根据用户所期望的GC停顿时间制定回收计划并回收</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="5、多线程并发"><a href="#5、多线程并发" class="headerlink" title="5、多线程并发"></a>5、多线程并发</h1><p>​    多线程相关问题</p>
<p>​    <em><strong>*进程是程序运行的实例。运行一个Java程序的实质就是启动一个java虚拟机进程。进程是程序向操作系统申请资源的基本单位。线程是进程中可独立执行的最小单位。一个进程可以包括多个线程，同一个进程中的所有线程共享该进程的资源。*</strong></em></p>
<p>​    <em><strong>*竞态：多线程编程中一个问题，对于同样的输入，程序的输出有时是正确的，有时是错误的，这种计算结果的正确性与时间有关的现象被成为竞态。*</strong></em></p>
<p>​    <em><strong>*线程安全和非线程安全： 一个类在单线程环境下能够正常运行，并且在多线程环境下，使用方不做特别处理也能运行正常，我们就称其实线程安全的。反之，一个类在单线程环境下运行正常，而在多线程环境下无法正常运行，这个类就是非线程安全的。*</strong></em></p>
<h2 id="5-1、线程状态"><a href="#5-1、线程状态" class="headerlink" title="5.1、线程状态"></a>5.1、线程状态</h2><p>新建（new之后），就绪（start之后），运行（run之后），阻塞（等待，wait/sleep,阻塞IO/申请锁，有限等待），死亡。</p>
<h2 id="5-2、多线程实现方式"><a href="#5-2、多线程实现方式" class="headerlink" title="5.2、多线程实现方式"></a>5.2、多线程实现方式</h2><p>1、实现Runnable接口</p>
<p>2、继承Thread类。因为java不支持多重继承，但可以实现多个接口。所有实现Runnable有更好的扩展性；还可以实现资源个共享，即多个线程基于一个Runnable对象，和共享Runnable的资源。</p>
<p>3、实现Callable接口;将实现类当做线程中运行的任务，然后用Thread来调用。callable的call方法有返回值，通过FutureTask进行封装。</p>
<p>  A.<em><strong>*start*</strong></em>()是启动一个新线程A,进入就绪状态。start方法只能被调用一次。</p>
<p>  ****Run()****方法，是就绪状态的线程获取cpu之后调用的，线程进入运行状态。如果手动调用，相当于执行一个普通方法。</p>
<p>  Java中，每个对象有且只有一个同步锁。调用synchronized方法就获取了对象的锁。</p>
<p>  当一个线程访问对象的同步方法或者同步代码块，其他线程不能再访问该对象的同步方法或者同步代码块，但可以访问该对象的非同步方法或者非同步代码块。</p>
<p>t1.<em><strong>*wait*</strong></em>(),让当前线程进入阻塞状态，释放t1对象的锁，直到其他线程调用t1.notify()方法，当前运行线程才可能被唤醒。</p>
<p>****wait()和notify()****方法必须出现在同步代码块中，等待和唤醒是依赖于同步锁实现的，同步锁是对象持有，每个对象有且只有一个。所以wait要释放锁，因为之后他释放了该锁，其他对象才能获取该锁，然后进入同步代码中，notify该对象上等待的对象。所以这也就是wait和notify方法为什么出现在Object对象上。</p>
<p>  ****yield()****：Thread静态方法，表示当前线程从运行状态转入就绪状态，给其他线程竞争的机会。不会释放任何锁。</p>
<p>  ****sleep()：****Thread静态方法，当前线程从运行状态进入等待阻塞状态，不释放任何锁，休眠一段时间后，该线程进入就绪状态。单位毫秒</p>
<p>  A.****join()****：当前线程进入阻塞状态，等线程A执行完之后，当前线程从阻塞状态进入就绪状态。</p>
<p>  线程优先级，1-10，默认5.用户线程，<strong>守护线程，</strong>isDaemon() t1.setDaemon(true);用户线程运行时，jvm不得关闭。gc线程是守护线程。</p>
<p>  ****中断****：调用线程的A.interrupt()方法，会设置线程A的中断标记为true。如果线程A处于wait(),join(),sleep()等阻塞状态时（不是io阻塞和锁阻塞），清除中断标记，抛出InterruptedException,线程结束。</p>
<p>  A.interrupted()方法，查看线程是否处于中断状态。且清除中断标记，而isInterrupted则查看中断标记，不会清除。</p>
<p>  Executor的中断，shutdown()，不再接受新任务，等待线程池中所有的任务完成。shutdownNow(),不接受新的，和未处理的。调用每个正在执行线程的interrupt()；</p>
<p>   中断线程池中的一个线程：使用submit方法提交线程，会返回一个future对象，调用该对象的cancel(true)方法中断线程。</p>
<h2 id="5-3、锁机制"><a href="#5-3、锁机制" class="headerlink" title="5.3、锁机制"></a>5.3、锁机制</h2><p>​    <em><strong>*悲观锁和乐观锁*</strong></em></p>
<p>  ****乐观锁****：每次访问数据的时候都认为其他线程不会修改数据，所以直接访问数据，更新的时候再判断在此期间其他线程是否修改数据。CAS和版本号机制是乐观锁的实现。</p>
<p>  乐观锁适合多读场景，悲观锁适合多写情况。</p>
<p>  版本号机制:数据有个version字段，表示被修改的次数。</p>
<p><em><strong>*CAS*</strong></em>:无琐算法，非阻塞同步，需要读写的内存值V和旧的期望值A相同时，更新为B.一般都是自旋CAS,不断的重试。乐观锁缺点：1、ABA问题（加入版本号机制）。2、自旋CAS如果一直不成功，开销大。3、只对单变量有效，当涉及多个共享变量时，无效。</p>
<p>乐观锁就是，<em><strong>*每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。CAS 操作包含三个操作数 ——*</strong></em> <em><strong>*内存位置（V）、预期原值（A）和新值(B)。*</strong></em> <em><strong>*如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。*</strong>***</em>*CAS是通过硬件命令保证了原子性。****</p>
<p>​    ****悲观锁****：每次访问数据的时候都会认为其他线程会修改数据，所以先获取锁，再访问数据。synchronized和ReentrantLock都是悲观锁思想的实现。</p>
<h2 id="5-4、Synchronized关键字三种实现方式"><a href="#5-4、Synchronized关键字三种实现方式" class="headerlink" title="5.4、Synchronized关键字三种实现方式"></a>5.4、Synchronized关键字三种实现方式</h2><p>  修饰实例方法，对当前实例对象加锁，进入同步代码前要获取对象实例的锁。修饰静态方法，对当前类对象加锁，修饰代码块，指定加锁对象，给对象加锁。</p>
<p>  具体实例，<strong>双重校验锁实现对单例模式;</strong></p>
<p> ****Synchronized同步的实现*<em><strong>，是基于</strong></em>*进入退出监视器Monitor对象实现*<em><strong>的，无论是同步代码块还是同步方法，都是如此；</strong></em>*同步代码块，是根据monitorenter 和 monitorexit 指令实现的****，同步方法，是通过设置方法的 <em><strong>*ACC_SYNCHRONIZED 访问标志*</strong></em>;监视器Monitor对象存在于每个对象的对象头中。</p>
<h2 id="5-5、synchronized和ReenTrantLock的区别"><a href="#5-5、synchronized和ReenTrantLock的区别" class="headerlink" title="5.5、synchronized和ReenTrantLock的区别"></a>5.5、synchronized和ReenTrantLock的区别</h2><p>  两者都是可重入锁(自己可以再次获取自己的内部锁)，锁计数器加1;</p>
<p>  synchronized只能是是非公平锁，而ReenTrantLock默认实现非公平锁，也支持公平锁(先等先得)</p>
<p>  synchronized依赖于JVM实现，而ReenTrantLock是基于JDK实现的;</p>
<p>  ReenTrantLock功能加多：1、<em><strong>*等待可中断*<em><strong>，2、</strong></em>*支持公平锁*<em><strong>，3、</strong></em>*基于Condition实现选择性唤醒;*</strong></em></p>
<p>synchronized经过一系列的优化，性能已得到大大的提升，和ReenTrantLock相差无几。</p>
<p>ReentrantLock,可重入互斥锁，独占锁。互斥锁：同一时间只能被一个线程持有。可重入锁：可以被单个线程多次获取。ReentrantLock支持公平锁和非公平锁，Synchronized只支持非公平锁。公平锁：线程依次排队获取锁。非公平锁：不管是不是队头都能获取。公平锁和非公平锁，它们尝试获取锁的方式不同：公平锁在尝试获取锁时，即使“锁”没有被任何线程锁持有，它也会判断自己是不是CLH等待队列的表头；是的话，才获取锁。而非公平锁在尝试获取锁时，如果“锁”没有被任何线程持有，则不管它在CLH队列的何处，它都直接获取锁。</p>
<p>公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在 wait，如果有自己要挂起，加到队列后面，然后唤醒队列最前面的线程。这种情况下相比较非公平锁多了一次挂起和唤醒。</p>
<p>线程切换的开销，其实就是非公平锁效率高于公平锁的原因，因为非公平锁减少了线程挂起的几率，后来的线程有一定几率逃离被挂起的开销。</p>
<h2 id="5-6、JDK1-6引入了大量的锁优化"><a href="#5-6、JDK1-6引入了大量的锁优化" class="headerlink" title="5.6、JDK1.6引入了大量的锁优化"></a>5.6、JDK1.6引入了大量的锁优化</h2><p>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术减少开销。</p>
<p>  锁主要存在4种状态：<strong>无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态</strong> 。锁可升级不可降级，提供获取锁和释放锁的效率。</p>
<ul>
<li><p>自旋锁:进程进入阻塞的开销很大，为防止进入阻塞状态，在线程请求共享数据锁的时候循环自旋一段时间，如果在这段时间内获取到锁，就避免进入阻塞状态了。</p>
<ul>
<li>1.6引入****自适应自旋锁****，自旋次数不再固定：由锁拥有者状态和上次获取锁的自旋次数决定。</li>
</ul>
</li>
<li><p>锁消除：对于被检测出不可能存在竞争的共享数据的锁进行消除。(逃逸分析)</p>
</li>
</ul>
<ul>
<li>锁粗化:虚拟机探测到一系列连续操作都对同一个对象加锁解锁，就将加锁的范围粗化到整个操作系列的外部。</li>
</ul>
<ul>
<li>偏向锁：<em><strong>*当锁对象第一次被线程获取的时候，进入偏向状态，标记为101，同时CAS将线程ID进入到对象头的Mark Word中，如果成功，*</strong>***</em>*这个线程以后每次获取锁就不再需要进行同步操作，甚至CAS不都需要。*<strong><strong><strong>*当*</strong></strong></strong>*另一个线程尝试获取这个锁，偏向状态结束****<em><strong>*，恢复到未锁定状态或者轻量级状态。*</strong></em></li>
</ul>
<ul>
<li>轻量级锁：轻量级锁相对重量级锁而言，使用CAS去避免重量级锁使用互斥量的开销。线程尝试获取锁时，如果锁处于无琐状态，先采用CAS去尝试获取锁，如果成功，锁状态更新为轻量级锁状态。如果有两条以上的线程争用一个锁，状态重为重量级锁。</li>
</ul>
<h2 id="5-7、volatile"><a href="#5-7、volatile" class="headerlink" title="5.7、volatile"></a>5.7、volatile</h2><p>​    ****Volatile****变量在汇编阶段，会多出一条lock前缀指令，这会导致当前处理器缓存的数据写回到系统内存中，且让其他改数据的处理器缓存失效。这就保障了可见性</p>
<p>  Volatile的修饰的变量，<em><strong>*虚拟机会使用内存屏障禁止指令重排序保障其有序性。但volatile变量不能保证其原子性。所以volatile是线程同步的轻量级实现，性能好，多线程访问volatile变量不会发生阻塞，volatile变量主要用于变量在多线程之间的可见性。但并不能保障原子性，不可替代synchronized.synchronized解决的是多线程之间访问共享资源的同步性。*</strong></em></p>
<h2 id="5-8、ThreadLocal"><a href="#5-8、ThreadLocal" class="headerlink" title="5.8、ThreadLocal"></a>5.8、ThreadLocal</h2><p>线程本地存储，提供了一个线程局部变量，让访问某个变量的线程都拥有自己的线程局部变量，这样线程对变量的访问就不存在竞争问题，也不需要同步。每个线程都有一个ThreadLocal.ThreadLocalMap对象。map的键是ThreadLocal t = new ThreadLocal()，值是value。ThreadLocalMap的Entry节点的key指向ThreadLocal是弱引用，虚拟机只要发现就可以垃圾回收。</p>
<p>  Thread -&gt; ThreadLocalMap -&gt; Entry&lt;ThreadLocal,value&gt; —&gt; ThreadLocal(key弱引用到ThreadLocal);</p>
<p>  ThreadLocal只有弱引用，可以被回收，但value存在强引用，不能被回收。当回收时，会将key的ThreadLocal设置为null，但是value还是强引用，无法回收，从而导致ThreadLocal一直无法被回收，这时候就有可能造成内存泄漏。 </p>
<p>  如何避免内存泄漏？事实上，ThreadLocalMap的get,set方法中，会对key（ThreadLocal）进行null判断，如果为null,value也设置为null.也可以手动条调用ThreadLocal.remove()方法。</p>
<h2 id="5-9、AQS与JUC"><a href="#5-9、AQS与JUC" class="headerlink" title="5.9、AQS与JUC"></a>5.9、AQS与JUC</h2><p>AQS(AbstactQueuedSynchronizer<em><strong>*)*</strong>***</em>*同步队列器，是一个构建锁和同步器的框架****，使用AQS能够简单有效的构造出应用广泛的大量同步器。如ReentrantLock, Semphore&gt;</p>
<p>AQS原理：<em><strong>*如果被请求的共享资源空闲，则将当前请求线程设为有效的工作线程，并且将共享资源设置为锁定状态。如果请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的。即将暂时获取不到的线程放入队列中*<em><strong>。CLH,是虚拟的双向队列，即不存在队列实例，</strong></em>*仅存在节点与节点之间的pre和next关系。*</strong>***</em>*AQS将每条请求共享资源的线程封装成一个CLH锁队列的一个节点来实现锁的分配。****</p>
<p>​    AQS属性(Node head, Node tail, int ****state****（这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁）, Thread 持有独占锁的线程)；</p>
<p>​    等待队列中每个线程被封装为一个Node实例（thread + waitStatus(-1: 当前node的后继节点对应的线程需要被唤醒,) + pre + next）；</p>
<p>​    <em><strong>*State:表示当前锁的状态，等于0时，表示没有被线程占用。当大于0时，表示被线程占用。*</strong></em></p>
<p>​    <em><strong>*Node节点的属性 watiStatus:默认为0，*</strong>***</em>*当大于0时，表示放弃等待*<strong><strong><strong>*，ReentrantLock是可以指定timeouot的。*</strong></strong></strong>*等于-1，表示当前node的后继节点对应的线程需要被唤醒。当等于-2时，标志着线程在Condition条件上等待的线程唤醒。等于-3时，用于共享锁，标志着下一个acquireShared方法线程应该被允许。****</p>
<p><em><strong>*公平锁，只有处于队头的线程才被允许去获取锁。非公平性锁模式下线程上下文切换的次数少，因此其性能开销更小。公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。*</strong></em></p>
<h2 id="5-10、AQS组件"><a href="#5-10、AQS组件" class="headerlink" title="5.10、AQS组件"></a>5.10、AQS组件</h2><p>AQS类别：独占锁和共享锁。</p>
<p>​    共享锁有ReentrantReadWriteLock、CountDownLatch、CyclicBarrier、Semaphore:</p>
<p>  <strong>ReadWriteLock读写锁</strong>。维护了一对相关联的读取锁和写入锁。读取锁用于只读操作，共享。写入锁用于写入操作，是独占锁。不能同时存在读取锁和写入锁。</p>
<p>   <strong>闭锁***</strong>*CountDownLatch*<strong><strong><strong>*(*</strong></strong></strong>*lætʃ)****是通过共享锁实现的;CountDownLatch doneSignal = new CountDownLatch(LATCH_SIZE);</p>
<p>   <em><strong>*CountDownLatch对象维护一个count,执行一次doneSignal.countDown()时，count减一直到count为0时， doneSignal.await()的等待线程才能运行。所以countDownLatch可以让一个线程等待一组线程完成之后才执行。*</strong></em></p>
<p>​    <em><strong>*栅栏*</strong>***</em>*CyclicBarrier*<em><strong><em><strong>*(ˈsaɪklɪk  ˈbæriər)*</strong></em> cb = new CyclicBarrier(SIZE)</strong></em>*;调用线程创建N个齐头并进的CyclicBarrier对象。每个线程执行cb.await()时，参与者数量加一，当参与者数量达到SIZE，阻塞的参与线程继续运行。****</p>
<p>  (01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待,直到到达某个公共屏障点.</p>
<p>  (02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</p>
<p>  <em><strong>*信号量*</strong>***</em>*Semaphore****<em><strong>*(ˈseməfɔːr) sem = new Semaphore(SEM_MAX);建立N个信号量。 sem.acquire(count);获取count个信号量。如果有就给予，没有就阻塞。sem.release(count);释放信号量。*</strong></em></p>
<p>​    </p>
<h2 id="5-11、JUC原子类"><a href="#5-11、JUC原子类" class="headerlink" title="5.11、JUC原子类"></a>5.11、JUC原子类</h2><p>基本类型：[əˈtɒmɪk]<em><strong>*AtomicInteger*</strong></em>,<em><strong>*AtomicLong*</strong></em>,AtomicBoolean;数组类型AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray;引用类型AtomicReference，对象属性修改类型AtomicIntegerFieldUpdater。在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性；</p>
<p>​    原子类基本通过****自旋CAS****来实现，期望的值和现在的值是否一致，如果一致就更新。</p>
<p>​    public final boolean <em><strong>*compareAndSet*</strong></em>(long expect, long update) {</p>
<p>​      return unsafe.compareAndSwapLong(this, valueOffset, expect, update);</p>
<p>​    }</p>
<p>​    <em><strong>*主要利用CAS+volatile + native方法来保证操作的原子性，从而避免同步方法的高开销。CAS原理是那期望的值和现在的值进行比较，如果相同则更新成新的值。*</strong></em></p>
<p>​    </p>
<h2 id="5-12、集合框架的多线程实现类"><a href="#5-12、集合框架的多线程实现类" class="headerlink" title="5.12、集合框架的多线程实现类"></a>5.12、集合框架的多线程实现类</h2><p><em><strong>*CopyOnWriteArrayList*</strong></em>(volatile数组来保持数据、增删改会新建数组，然后copy到volatile数组。只有查找效率高)线程安全机制是通过volatile和互斥锁实现的。增删改时，先获取互斥锁，然后创建新数组，复制到volatile数组中，释放锁。</p>
<p>1、****CopyOnWriteArrayList****相当于线程安全的ArrayList，它实现了List接口。CopyOnWriteArrayList是支持高并发的。</p>
<p>2、****CopyOnWriteArraySet****相当于线程安全的HashSet，它继承于AbstractSet类。CopyOnWriteArraySet内部包含一个CopyOnWriteArrayList对象，它是通过CopyOnWriteArrayList实现的。</p>
<p><em><strong>*1、*</strong>***</em>*ConcurrentHashMap****是线程安全的哈希表(相当于线程安全的HashMap)</p>
<p>****2、ConcurrentSkipListMap****是线程安全的有序的哈希表(相当于线程安全的TreeMap)</p>
<p>****3、ConcurrentSkipListSet****是线程安全的有序的集合(相当于线程安全的TreeSet)</p>
<p>1、 ****ArrayBlockingQueu(kjuː)*<em><strong>是数组实现的线程安全的</strong></em>*有界****的阻塞队列。</p>
<p>2、 ****LinkedBlockingQueue*<em><strong>是</strong></em>*单向链表实现的(指定大小)阻塞队列****，该队列按 FIFO（先进先出）排序元素。</p>
<p>3、 ****LinkedBlockingDeque****是双向链表实现的(指定大小)双向并发阻塞队列，该阻塞队列同时支持FIFO和FILO两种操作方式。</p>
<p>4、 ****ConcurrentLinkedQueue*<em><strong>是单向链表实现的</strong></em>*无界队列****，该队列按 FIFO（先进先出）排序元素。</p>
<p>5、 ****ConcurrentLinkedDeque*<em><strong>是双向链表实现的</strong></em>*无界队列****，该队列同时支持FIFO和FILO两种操作方式。</p>
<h2 id="5-13、线程池"><a href="#5-13、线程池" class="headerlink" title="5.13、线程池"></a>5.13、线程池</h2><p>​    线程池则是为了<em><strong>*减少线程建立和销毁带来的性能消耗*<em><strong>。线程池的使用可以帮助我们</strong></em>*更合理的使用系统资源.*</strong></em></p>
<p>​    Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。</p>
<p>  Executor <em><strong>*ɪ*</strong>***</em>*ɡ********ˈzekjətər*<em><strong>只提供了execute()</strong></em>*ˈeksɪkjuːt****方法来执行已提交的 Runnable 任务的对象。</p>
<p>  ExecutorService接口，继承Executor；AbstractExecutorService抽象类实现了ExecutorService接口。   ThreadPoolExecutor，真正线程池实现类，继承自AbstractExecutorService。</p>
<p>  ****ThreadPoolExecutor****是线程池类。对于线程池，可以通俗的将它理解为”存放一定数量线程的一个线程集合。线程池允许若个线程同时运行;</p>
<p>  当添加的到线程池中的线程超过它的容量时，会有一部分线程阻塞等待。线程池会通过相应的调度策略和拒绝策略，对添加到线程池中的线程进行管理。</p>
<p>  关闭线程池：调用线程池的shutdown()接口时，线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。</p>
<p>   调用线程池的shutdownNow()接口时，线程池切换为STOP状态，不接收新任务，不处理已添加的任务，并且通过调用每个线程的interrupt()方法尝试中断正在处理的任务。</p>
<p><em><strong>*一定要通过 ThreadPoolExecutor(xx,xx,xx…) 来明确线程池的运行规则，指定更合理的参数。*</strong></em></p>
<h2 id="5-14、ThreadPoolExecutor线程池的7大参数"><a href="#5-14、ThreadPoolExecutor线程池的7大参数" class="headerlink" title="5.14、ThreadPoolExecutor线程池的7大参数"></a>5.14、ThreadPoolExecutor线程池的7大参数</h2><p>​    <em><strong>*kɔːr*</strong></em> <em><strong>*corePoolSize*</strong>***</em>*：核心池的大小：*<em><strong>创建线程池之后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；调用了prestartAllCoreThreads()或者prestartCoreThread()方法，可以在任务来之前预创建线程。</strong></em>*核心线程会一直存活，及时没有任务需要执行****；</p>
<p><em><strong>*设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭；*</strong></em></p>
<p><em><strong>*maximumPoolSize*</strong>***</em>*：线程池最大线程数****，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</p>
<p><em><strong>*keepAliveTime*</strong>***</em>*：非核心线程的最大空闲时间。****</p>
<p><em><strong>*TimeUnit*</strong>***</em>*：空闲时间的单位。****</p>
<p><em><strong>*BlockingQueue*</strong>***</em>*<Runnable>**** <em><strong>*workQueue*</strong></em> ****：等待执行的任务队列，队列分为有界队列和无界队列。****有界队列：队列的长度有上限，当核心线程满载的时候，新任务进来进入队列，当达到上限，有没有核心线程去即时取走处理，这个时候，就会创建临时线程。（警惕临时线程无限增加的风险）</p>
<p>无界队列：队列没有上限的，当没有核心线程空闲的时候，新来的任务可以无止境的向队列中添加，而永远也不会创建临时线程。（警惕任务队列无限堆积的风险）</p>
<p><em><strong>*ThreadFactory*</strong>***</em>*：线程工厂，用来创建线程****</p>
<p><em><strong>*RejectedExecutionHandler*</strong>***</em>*：队列已满，而且任务量大于最大线程的异常处理策略****</p>
<h2 id="5-15、线程池属性"><a href="#5-15、线程池属性" class="headerlink" title="5.15、线程池属性"></a>5.15、线程池属性</h2><p>****largestPoolSize，记录了曾经出现的最大线程个数****。因为setMaximumPoolSize()可以改变最大线程数。</p>
<p>****poolSize：线程池中当前线程的数量****。</p>
<p>当提交一个新任务时：</p>
<p><em><strong>*（1）如果poolSize&lt;corePoolSize，新增加一个线程处理新的任务。无论是否有空闲的线程新增一个线程处理新提交的任务；*</strong></em></p>
<p><em><strong>*（2）如果poolSize=corePoolSize，新任务会被放入阻塞队列等待。*</strong></em></p>
<p><em><strong>*（3）如果阻塞队列的容量达到上限，且这时poolSize&lt;maximumPoolSize，新增线程来处理任务。*</strong></em></p>
<p><em><strong>*（4）如果阻塞队列满了，且poolSize=maximumPoolSize，那么线程池已经达到极限，会根据饱和策略RejectedExecutionHandler拒绝新的任务。*</strong></em></p>
<p>* 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize</p>
<p>* 如果allowCoreThreadTimeout=true，则会直到线程数量=0</p>
<p>****workQueue：一个阻塞队列****：ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和SynchronousQueue；</p>
<p>workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：</p>
<p>　　1）****ArrayBlockingQueue****：基于数组的先进先出队列，此队列创建时必须指定大小；</p>
<p>　　2）****LinkedBlockingQueue****：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p>
<p>　　3）****synchronousQueue****：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p>
<p>​    4）<strong>PriorityBlockingQueue</strong>：优先级阻塞队列</p>
<p>线程拒绝策略：</p>
<p>ThreadPoolExecutor<em><strong>*.*</strong>***</em>*AbortPolicy*<strong><strong><strong>*（中止）*</strong></strong></strong>*:丢弃任务并抛出RejectedExecutionException异常。**** </p>
<p>ThreadPoolExecutor<em><strong>*.*</strong>***</em>*DiscardPolicy*<strong><strong><strong>*（抛弃）*</strong></strong></strong>*：也是丢弃任务****，但是不抛出异常。 </p>
<p>ThreadPoolExecutor.D<em><strong>*iscardOldestPolicy*</strong>***</em>*（抛弃最旧）********：丢弃队列最前面的任务****，然后重新尝试执行任务（重复此过程）</p>
<p>ThreadPoolExecutor.<em><strong>*CallerRunsPolicy*</strong>***</em>*（调用者运行）****：由调用线程处理该任务</p>
<p>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p>
<p>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</p>
<p>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p>
<p>动态调整大小：</p>
<p>setCorePoolSize：设置核心池大小</p>
<p>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</p>
<p>其他种类的：<em><strong>*Executor框架的工具类Execuors来实现。*</strong></em></p>
<p><em><strong>*newFixedThreadPool*<em><strong>：</strong></em>*建立一个*</strong>***</em>*线程数量固定的线程池****，规定的最大线程数量，超过这个数量之后进来的任务，会放到等待队列中，如果有空闲线程，则在等待队列中获取，遵循先进先出原则。corePoolSize 和 maximumPoolSize 要一致，Executors 默认使用的是 LinkedBlockingQueue 作为等待队列，这是一个无界队列。</p>
<p><em><strong>*newSingleThreadExecutor*<em><strong>：</strong></em>*建立一个*</strong>***</em>*只有一个线程的线程池****，如果有超过一个任务进来，只有一个可以执行，其余的都会放到等待队列中，如果有空闲线程，则在等待队列中获取，遵循先进先出原则。使用 LinkedBlockingQueue 作为等待队列。等待队列无限长的问题，容易造成 OOM。</p>
<p><em><strong>*newCachedThreadPool*<em><strong>：</strong></em>*缓存型线程池*</strong>***</em>*，在核心线程达到最大值之前，有任务进来就会创建新的核心线程，并加入核心线程池，即时有空闲的线程，也不会复用。达到最大核心线程数后，新任务进来，如果有空闲线程，则直接拿来使用，如果没有空闲线程，则新建临时线程****。并且线程的允许空闲时间都很短，如果超过空闲时间没有活动，则销毁临时线程。关键点就在于它使用 <em><strong>*SynchronousQueue*</strong></em> <em><strong>*作为等待队列，它不会保留任务，新任务进来后，直接创建临时线程处理。容易造成无限制的创建线程，造成 OOM。*</strong></em></p>
<p>****newScheduledThreadPool****：计划型线程池，可以设置固定时间的延时或者定期执行任务，同样是看线程池中有没有空闲线程，如果有，直接拿来使用，如果没有，则新建线程加入池。使用的是 DelayedWorkQueue 作为等待队列，这中类型的队列会保证只有到了指定的延时时间，才会执行任务。容易造成无限制的创建线程，造成 OOM。</p>
<h2 id="5-16、线程池大小如何设置？"><a href="#5-16、线程池大小如何设置？" class="headerlink" title="5.16、线程池大小如何设置？"></a>5.16、线程池大小如何设置？</h2><p>对于计算密集型的任务，一个有Ncpu个处理器的系统通常通过使用一个Ncpu + 1个线程的线程池来获得最优的利用率.</p>
<p>对于包含了 I/O和其他阻塞操作的任务，不是所有的线程都会在所有的时间被调度，因此你需要一个更大的池。2*Ncpu</p>
<p>　　Nthreads = Ncpu x Ucpu x (1 + W/C)，其中</p>
<p>　　Ncpu = CPU核心数</p>
<p>　　Ucpu = CPU使用率，0~1</p>
<p><em><strong>*W/C = 等待时间与计算时间的比率*</strong></em></p>
<p>****线程数****<strong>maxsize</strong> <em><strong>*= Ncpu /（1 - 阻塞系数）=*</strong></em> <em><strong>*Ncpu *(1 + W/C)*</strong></em></p>
<p>线程数设置过大有什么缺点：</p>
<p>​    如果maxsize过大会占****用更多资源****，cpu会频繁地进行上下文切换，会导致cpu缓存的数据失效和重新加载，结果就是上下文切换和reload的时间变多，也就是说cpu将更多的时间花费到对线程的管理上去了，这时候更多的线程反而更慢</p>
<h1 id="6、MySQL"><a href="#6、MySQL" class="headerlink" title="6、MySQL"></a>6、MySQL</h1><h2 id="6-1、事务相关"><a href="#6-1、事务相关" class="headerlink" title="6.1、事务相关"></a>6.1、事务相关</h2><p>数据库的<em><strong>*事务*</strong></em></p>
<p>  ****事务****：一组数据库操作，要么全都执行，要么都不执行;</p>
<p>  ****事务特性****：ACID. 原子性：事务是最小的执行单位，不可分割，保证事务要么都完成，要么都不完成。</p>
<p>一致性：？？？执行事务前后，数据保持一致。隔离性：并发访问数据库时：一个事务不被其他事务干扰。持久性：事务一    旦提交，对数据库的改变是持久的</p>
<h2 id="6-2、并发事务带来的问题"><a href="#6-2、并发事务带来的问题" class="headerlink" title="6.2、并发事务带来的问题"></a>6.2、并发事务带来的问题</h2><p>****脏读****：一个事务读取了另一个事务修改但未提交的数据。</p>
<p>****丢失修改****：数据被两个事务连续修改，第一个事务的修改丢失了。</p>
<p>  ****不可重复读****，一个事务连续读两次数据，但结果不一样。(两次读之间，数据被其他事务修改)。</p>
<p>****幻读****：一个事务连续读两次数据，读取数据量不一样。(两次读之前，数据被其他事务删除或新增)。</p>
<h2 id="6-3、事务隔离级别"><a href="#6-3、事务隔离级别" class="headerlink" title="6.3、事务隔离级别"></a>6.3、事务隔离级别</h2><p>​    ****1*<em><strong>、</strong></em>*读未提交****。可以读取尚未提交的数据。能导致脏读，不可重复读，幻读。</p>
<p>  ****2、读已提交****。允许读取并发事务已经提交的数据。导致不可重复读，幻读。</p>
<p><em><strong>*3、*</strong>***</em>*可重复读****。意义在哪？？？？对同一字段，多次读取结果一致。导致幻读。</p>
<p>不可重复读很容易让人陷入一个思维定式那就是 我干嘛需要多次读取一个值还要保证一致</p>
<p>要跳出这个思维看本质：我在事务中会不会受到其他事务的影响？</p>
<p>举个简单的例子 数据校对（只是举个例子体现意思 不用太在意具体的业务）</p>
<p>我要取当前的余额 当前的账单 上个月的余额 我要检验一下数据对不对</p>
<p>我在事务中取了当前的账单和上个月的余额，好嘛，这时候又有新的订单提交了，我再获取余额是不是就不一致了？</p>
<p>  <em><strong>*4、串行化*<em><strong>。所有事务，依次执行。没啥问题。</strong></em>*（这个串行化是针对行锁的，不同行的事务可以并发）*</strong></em></p>
<p>​    设置隔离级别之后，并不是不能并发，而是并发的时候，一个事务的修改数据(绝对读到，提交的才能读到。提交不提交，更新的数据都读不到。提交不提交，增删的数据都读不到)，什么时候才能被另一个事务读到。但彼此的逻辑操作没有影响。</p>
<p>​    MySQL InnoDB****默认支持可重复读*<em><strong>，但使用了</strong></em>*Next-Key Lock算法避免了幻读的发生****。完全达到了保保证事务的隔离要求。但在分布式事务下，一般可串行化。</p>
<h2 id="6-4、Innodb和Myisam的区别"><a href="#6-4、Innodb和Myisam的区别" class="headerlink" title="6.4、Innodb和Myisam的区别"></a>6.4、Innodb和Myisam的区别</h2><p>  1、MyISAM不支持事务，而Innodb支持事务。2、Myisam是表级锁，而Innodb是行级锁。3外键支持：mysiam表不支持外键，而InnoDB支持。4、count运算：myisam缓存有表的行数，这种缓存只是表行的总数，where筛选无效。而Innodb没有。</p>
<p>  MyISAM适合：(1)做很多count 的计算；(2)读密集；(3)没有事务。</p>
<p>InnoDB适合：(1)要求事务；(2)写密集（3）高并发</p>
<h2 id="6-5、锁机制"><a href="#6-5、锁机制" class="headerlink" title="6.5、锁机制"></a>6.5、锁机制</h2><p>​    三种并发控制机制：悲观并发控制、乐观并发控制和多版本并发控制。悲观并发控制其实是最常见的并发控制机制，也就是锁；乐观并发控制其实也有另一个名字：乐观锁. MVCC多版本并发控制机制，可以与前两者中的任意一种机制结合使用，以提高数据库的读性能。</p>
<p>​    ****乐观锁****：在访问数据之前，默认不会有其他事务对此数据进行修改，所以先访问数据，然后再查找在此期间是否有事务修改数据。这不是数据库自带的，需要我们自己去实现，一般基于版本去实现。</p>
<p>​    <em><strong>*悲观锁：*</strong></em></p>
<p>​    <em><strong>*按照锁的粒度把数据库锁分为表级锁和行级锁。*</strong></em></p>
<p>​    表级锁: 对当前操作的整张表加锁,实现简单，加锁快，不死锁，但并发能力低。</p>
<p>​    行级锁: ****只针对当前操作的行进行加锁*<em><strong>。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的</strong></em>*开销也最大，加锁慢，会出现死锁****。</p>
<p>​    <em><strong>*Record Lock*</strong>***</em>*记录锁****<em><strong>*:*</strong></em> ****锁住某一行*<em><strong>，如果表存在索引，</strong></em>*那么记录锁是锁在索引上的*<em><strong>，如果表没有索引，那么 InnoDB 会创建一个隐藏的</strong></em>*聚簇索引加锁****。</p>
<p>​    <em><strong>*Gap LocK*</strong>***</em>*间隙锁****: ****间隙锁是一种记录行与记录行之间存在空隙或在第一行记录之前或最后一行记录之后产生的锁****。间隙锁可能占据的单行，多行或者是空记录。 ****对索引项之间的“间隙”加锁，锁定记录的范围,不包含索引项本身*<em><strong>。</strong></em>*其他事务不能在锁范围内插入数据****，这样就防止了别的事务新增幻影行。</p>
<p>​    <em><strong>*Next-key Lock：*</strong></em> <em><strong>*锁定索引项本身和索引范围。*</strong>***</em>*NK 是一种记录锁和间隙锁的组合锁。既锁住行也锁住间隙。*<em><strong>即Record Lock和Gap Lock的结合。</strong></em>*可解决幻读问题。****</p>
<p>​    <em><strong>*根据是否独占，锁又可以分为*</strong>***</em>*共享锁和排他锁****。</p>
<p>​    <em><strong>*共享锁*<em><strong>（Share Locks，简记为S）又被称为读锁，</strong></em>*其他用户可以并发读取数据，*</strong>***</em>*但任何事务都不能获取数据上的排他锁*<em><strong>，</strong></em>*直到已释放所有共享锁。****</p>
<p>​    ****排它锁（(Exclusive lock,简记为X锁)）又称为写锁*<em><strong>，</strong></em>*若事务T对数据对象A加上X锁，则只允许T读取和修改A****，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。</p>
<p>​    <em><strong>*Innodb同时支持行锁和表锁。*</strong>***</em>*但行锁和表锁的同时存在会发生冲突，如A申请了行共享锁，而B再申请表互斥锁。*<strong><strong><strong>*这时B不仅需要查看是否已经存在其他表锁，以及逐个查看是否存在行锁，效率太低。于是又引入了意向锁。意*<em><strong>向锁是一种表级锁，用来指示</strong></em>*接下来的一个事务将要获取的是什么类型的锁（共享还是独占）。*</strong></strong></strong>*意向锁分为意向共享锁（IS）和意向独占锁（IX），依次表示接下来一个事务将会获得共享锁或者独占锁。****</p>
<p>意向共享锁（IS）：事务打算给数据行加共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</p>
<p>意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p>
<p><em><strong>*在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。而事务B发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。*</strong></em></p>
<p><em><strong>*而且，*</strong>***</em>*申请意向锁的动作是数据库自动完成的，不需要我们手动申请。****</p>
<p>​    </p>
<h2 id="6-6、MVCC多版本并发控制（Multiversion-Concurrency-Control）"><a href="#6-6、MVCC多版本并发控制（Multiversion-Concurrency-Control）" class="headerlink" title="6.6、MVCC多版本并发控制（Multiversion Concurrency Control）"></a>6.6、MVCC多版本并发控制（Multiversion Concurrency Control）</h2><p><em><strong>*多版本控制: 指的是一种提高并发的技术。最早的数据库系统，*</strong>***</em>*只有读读之间可以并发，读写，写读，写写都要阻塞。*<strong><strong><strong>*引入多版本之后，*</strong></strong></strong>*只有写写之间相互阻塞，其他三种操作都可以并行****<em><strong>*，这样大幅度提高了InnoDB的并发度。*</strong></em></p>
<p>​    <em><strong>*每一个*</strong>***</em>*写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回；****在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。</p>
<p>​    各数据库中MVCC实现并不统一，MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;</p>
<p>对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：(t<em><strong>*rx_id*</strong>***</em>*事务ID、roll_pointer上个版本指针********,****其实还有一个row_id的隐藏列但这里用不着); </p>
<p><em><strong>*每次对记录进行改动，都会把对应的事务id赋值给trx_id隐藏列，也会把旧的版本写入到undo日志中；*</strong></em></p>
<p><em><strong>*所以在并发情况下，*</strong>***</em>*一个记录可能存在多个版本，通过*<strong><strong><strong>*roll_pointer*</strong></strong></strong>*形成一个版本链*<strong><strong><strong>*。MVCC的核心任务就是：判断一下版本链中的哪个版本是当前事务可见的。这就有了*</strong></strong></strong>*ReadView*<strong><strong><strong>*的概念，这个ReadView中主要包含当前系统中还有哪些活跃的读写事务，把它们的*</strong></strong></strong>*事务id放到一个列表中，我们把这个列表命名为为m_ids****<em><strong>*；根据ReadView的活跃事务ID列表和版本链事务ID进行比较找出可见的事务ID最大的版本：*</strong></em></p>
<p><em><strong>*1、如果版本的trx_id属性值小于m_ids列表中最小的事务id，表明生成该版本的事务在生成ReadView前已经提交，所以该版本可以被当前事务访问。*</strong></em></p>
<p><em><strong>*2、如果版本的trx_id属性值大于m_ids列表中最大的事务id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。*</strong></em></p>
<p><em><strong>*3、被访问版本的trx_id属性值在m_ids列表中最大的事务id和最小事务id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。*</strong></em></p>
<p><em><strong>*MVCC只在读已提交和可重复读这两个隔离机制下运行。这*</strong>***</em>*两个隔离机制下MVCC实现方式的区别就在于：读已提交是每次读取数据前都生成一个ReadView；而可重复读，是在第一次读取数据时生成一个ReadView，后序的重复查询就不再生产ReadView了。****</p>
<p>​    <em><strong>*总结：*</strong></em></p>
<p>​    <em><strong>*多版本并发控制指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复这个ReadView就好了。*</strong></em></p>
<h2 id="6-7、Mysql死锁处理方式"><a href="#6-7、Mysql死锁处理方式" class="headerlink" title="6.7、Mysql死锁处理方式"></a>6.7、Mysql死锁处理方式</h2><p>1、等待，直到超时，事务自动回滚。2、发起死锁检测， 回滚一个事务，让其他事务执行。</p>
<p>死锁检测，构建一个以事务为起点，锁为边的有向图，看是否存在环。</p>
<h2 id="6-8、索引相关"><a href="#6-8、索引相关" class="headerlink" title="6.8、索引相关"></a>6.8、索引相关</h2><p>​    ****索引优缺点****：(1) 优点：加快检索速度(2)缺点：(a)创建索引和维护索引需要耗费时间(b)索引需要占用空间 (c)进行数据的增删改时候需要动态维护索引</p>
<p>​    ****索引类型****：主键索引，唯一索引，全文索引，普通索引，复合索引。</p>
<p>​    ****哈希索引****就是采用一定的哈希算法，把键值换算成新的哈希值，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。但是有缺点。1、不能使用范围查询。2、无法利用索引的数据来避免任何排序运算；3、不支持多列联合索引的最左匹配规则；4、任何时候都不能避免表扫描。5、存在所谓的哈希碰撞问题。</p>
<p>​    所以我们都用****B+树****，只有叶子节点存储数据，其他的节点只是起到索引的作用。平衡，性能稳定，每次查询的次数都是树的高度。</p>
<p>​    索引是一种数据结构。<em><strong>*索引本身很大，不可能全部存储在内存中，因此索引以索引表的形式存储在磁盘中*<em><strong>。这样的话，</strong></em>*索引查找过程中就要产生磁盘I/O消耗*<em><strong>，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为</strong></em>*索引的优劣最重要的指标就是在查找过程中*</strong>***</em>*磁盘I/O操作次数的渐进复杂度*<em><strong>。换句话说，索引的结构组织要尽量</strong></em>*减少查找过程中磁盘I/O的存取次数。****</p>
<h2 id="6-9、M阶B树"><a href="#6-9、M阶B树" class="headerlink" title="6.9、M阶B树"></a>6.9、M阶B树</h2><p>1、 ****树中每个结点至多有m个子结点****（即M阶）； </p>
<p>2、 ****若根结点不是叶子结点,则至少有2个子结点****；</p>
<p>3、 除根结点和叶子结点外,<em><strong>*其*</strong>***</em>*它每个结点至少有ceil(m/2)个子结点；即中间节点最少有ceil(m/2)个子结点。****</p>
<p>4、 <em><strong>*所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息；*</strong></em></p>
<p>5、 <em><strong>*有k个子结点的非终端结点恰好包含有k-1个关键字*</strong>***</em>*(单节点里元素).****</p>
<p>每个节点中元素个数n必须满足： <em><strong>*[ceil(m / 2)-1]&lt;= n &lt;= m-1。*</strong></em>(即M阶树单节点最多有M-1个元素)</p>
<p>每个结点中关键字从小到大排列，并且当该结点的孩子是非叶子结点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划.</p>
<p>​    B+树的不同之处：<em><strong>*非叶子节点只存储键值信息。数据记录都存放在叶子节点中。所有叶子节点之间都有一个链指针。*</strong></em></p>
<h2 id="6-10、B-树的优点"><a href="#6-10、B-树的优点" class="headerlink" title="6.10、B+树的优点"></a>6.10、B+树的优点</h2><p>​    1、B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，IO次数更少。</p>
<p>​    2、B+树的查询必须最终找到叶子节点，而B-树只需要找到匹配的元素即可。B+树性能稳定。</p>
<p>​    3、范围查询方便。B-树只能依靠繁琐的中序遍历，而B+树只需要在链表上遍历即可。</p>
<p><em><strong>*磁盘数据地址：*</strong>***</em>*柱面号、盘面号、块号****</p>
<p><em><strong>*因为普通的全表查询时间复杂度是O(n);如果是平衡二叉树，或者红黑树，查找时间变成*<em><strong>O(log2N)，但他们依然不适合做索引。因为索引通常比较大，存于磁盘中，无法一次将全部的索引加载到内存中，每次只能从磁盘中读取一个页到内存中，而平衡二叉树底层实现是数组，逻辑上相邻的节点在物理结构上可能相差很远，因此磁盘IO次数可能很大，平衡二叉树没能充分利用磁盘预读功能。</strong></em>*磁盘往往不是严格按需读取，而是每次都会*</strong>***</em>*预读********，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存****。这样做的理论依据是计算机科学中著名的局部性原理。红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。    </p>
<p>B树的每个节点可以存储多个关键字，<em><strong>*它将节点大小设置为磁盘页的大小，充分利用了*</strong>***</em>*磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。********也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少****，更多的是在内存中对读取进来的数据进行查找。</p>
<p>logm(n+1)&lt;= h &lt;=log(ceil(m/2)) (n+1)/2 + 1</p>
<p>B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高区间访问的性能。而正是这个特性决定了B+树更适合用来存储外部数据。</p>
<p>****二叉查找树BST：*<em><strong>查找最好时间复杂度</strong></em>*O(logN)，最坏时间复杂度O(N)。****插入删除的实现简单，时间复杂度一致。</p>
<p>平衡二叉查找树AVL：查找的时间复杂度维持在O(logN)，不会出现最差情况 .AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。 AVL树在执行删除时代价稍大，一次删除操作最多需要O(logN)次旋转,执行每个删除操作的时间复杂度需要O(2logN)。</p>
<p>查找 效率最好情况下时间复杂度为O(logN).</p>
<p>插<em><strong>*入和删除操作改变树的平衡性的概率要远远小于AVL*<em><strong>（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，</strong></em>*而且一旦需要旋转，*</strong>***</em>*插入一个结点最多只需要旋转2次，删除最多只需要旋转3次****<em><strong>*(*<em><strong>小于AVL的删除操作所需要的旋转次数)。</strong></em>*虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。*</strong></em></p>
<p>​    <em><strong>*聚簇索引的解释是:聚簇索引的顺序就是数据的物理存储顺序；*</strong></em></p>
<p>​    <em><strong>*非聚簇索引的解释是:索引顺序与数据物理排列顺序无关；*</strong></em></p>
<p>​    MyISAM使用的是非聚簇索引：非聚簇索引的数据表和索引表是分开存储的。主索引和辅助索引几乎是一样的，叶子节点存储的是指向数据的物理地址。</p>
<p>​    Innodb使用的是聚簇索引。<em><strong>*聚簇索引的主键索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。*</strong></em></p>
<p>​     B+树有主键索引和辅助索引两种；；主键索引就是按照表中主键的顺序构建一颗B+树，并在叶节点中存放表中的行记录数据，一个表只能有一个主键索引。<em><strong>*而辅助索引，叶节点并不存储行记录数据，仅仅是主键。通过辅助索引查找到对应的主键，最后在聚集索引中使用主键获取对应的行记录。（这个叫回表查询？？?）*</strong></em></p>
<p>​    </p>
<p>​    </p>
<p>****最左前缀原则*<em><strong>：mysql索引可以引用多列，叫联合索引，如果查询条件精确匹配联合索引的左边连续一列或者多列，则查询命中索引。a,b,c的联合索引，(a,c)可以</strong></em>*命中a,c不能命中****。</p>
<p>联合索引并不是全部不中，或者全部中。可以只命中一部分，例如单单命中A.</p>
<p><em><strong>*MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，不过建议 where 后的字段顺序和联合索引保持一致，养成好习惯。*</strong></em></p>
<p><em><strong>*组合索引*</strong>***</em>*(*<strong><strong><strong>*大于等于2小于等于3*</strong></strong></strong>*)****<em><strong>*也是建立一个B+树，只不过非叶子节点存储的是第一个列。叶子节点组合的列都有，中了第一列之后，然后安装其他的列索引搜查。*</strong></em></p>
<p><em><strong>*联合索引的好处：利用覆盖索引，避免回表操作。*</strong></em></p>
<p><em><strong>*而且对于两个单列查询返回行较多，同时查返回行较少，联合索引更高效。*</strong></em></p>
<h2 id="6-11、Explain语句的字段"><a href="#6-11、Explain语句的字段" class="headerlink" title="6.11、Explain语句的字段"></a>6.11、Explain语句的字段</h2><p>​    ID: SELECT的查询序列号;</p>
<p>​    <em><strong>*select_type:*<em><strong>示查询中</strong></em>*每个select子句的类型*</strong></em></p>
<p>(1) SIMPLE(简单SELECT，****不使用UNION或子查询****等)</p>
<p>(2) PRIMARY(****子查询中最外层查询****，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p>
<p>(3) UNION(UNION中的第二个或后面的SELECT语句)</p>
<p>(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p>
<p>(5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p>
<p>(6) ****SUBQUERY(子查询中的第一个SELECT****，结果不依赖于外部查询)</p>
<p>(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p>
<p>(8) DERIVED(派生表的SELECT, FROM子句的子查询)</p>
<p>(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p>
<p>​    ****Table:****显示这一步所访问数据库中表名称,</p>
<p><em><strong>*Type*<em><strong>对表访问方式</strong></em>*，表示MySQL在表中找到所需行的方式，又称“访问类型”。*</strong></em></p>
<p>ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）</p>
<p>All:全表扫描。index: full index scan,遍历索引树。range:只检索给定范围的行，使用一个索引来选择行</p>
<p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p>
<p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p>
<p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p>
<p>****possible_keys：*<em><strong>指出MySQL能使用哪个索引在表中找到记录</strong></em>*，查询涉及到的字段上若存在索引，则该索引将被列出，****但不一定被查询使用</p>
<p>****Key：显示MySQL实际决定使用的键（索引），****必然包含在possible_keys中</p>
<p>****key_len：表示索引中使用的字节数，*<em><strong>可通过该列计算查询中使用的索引的长度</strong></em>*（key_len显示的值为索引字段的最大可能长度****，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</p>
<p><em><strong>*ref：列与索引的比较，*<em><strong>表示上述表的连接匹配条件，</strong></em>*即哪些列或常量被用于查找索引列上的值*</strong></em></p>
<p>****rows：估算出结果集行数，*<em><strong>表示MySQL根据表统计信息及索引选用情况，</strong></em>*估算的找到所需的记录所需要读取的行数****、</p>
<p><em><strong>*xtra: 含MySQL解决查询的详细信息,有以下几种情况：*</strong></em></p>
<p>****Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据****，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p>
<p>Using temporary：表示MySQL需要使用****临时表来存储结果集，常见于排序和分组查询****，常见 group by ; order by</p>
<p>****Using filesort****：当Query中包含 <em><strong>*order by 操作*<em><strong>，而且无法利用索引完成的排序操作称为“</strong></em>*文件排序”*</strong></em></p>
<p>Using join buffer****：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果****。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p>
<p>Impossible where：这个值强调了****where语句会导致没有符合条件的行****（通过收集统计信息不可能存在结果）。</p>
<p>Select tables optimized away：这个值意味着仅通过使用索引，<em><strong>*优化器可能仅从聚合函数结果中返回一行*</strong></em></p>
<p>No tables used：Query语句中使用from dual <em><strong>*或不含任何from子句*</strong></em></p>
<h2 id="6-12、其他优化地方"><a href="#6-12、其他优化地方" class="headerlink" title="6.12、其他优化地方"></a>6.12、其他优化地方</h2><p><em><strong>*强制类型转换会全表扫描。Varchar 的 phone = ‘123344’，别用 123345数字。*</strong></em></p>
<p><em><strong>*使用短索引（又叫前缀索引）来优化索引。*</strong></em></p>
<p><em><strong>*存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。*</strong></em></p>
<p><em><strong>*利用覆盖索引来进行查询操作，避免回表。*</strong></em></p>
<h2 id="6-13、什么时候要使用索引？"><a href="#6-13、什么时候要使用索引？" class="headerlink" title="6.13、什么时候要使用索引？"></a>6.13、什么时候要使用索引？</h2><p>​    主键自动建立唯一索引；</p>
<p>​    ****经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引****；</p>
<p>​    作为<em><strong>*排序的列*<em><strong>要建立索引；</strong></em>*(单纯的order by 不会用到索引，但如果在where中出现，就可以用索引了。)*</strong></em></p>
<p>​    查询中与其他<em><strong>*表关联的字段，外键关系建立索引*</strong></em></p>
<p>​    高并发条件下倾向****组合索引****；</p>
<p>​    用于****聚合函数的列可以建立索引****，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引</p>
<h2 id="6-14、什么时候不要使用索引？"><a href="#6-14、什么时候不要使用索引？" class="headerlink" title="6.14、什么时候不要使用索引？"></a>6.14、什么时候不要使用索引？</h2><p>​    ****经常增删改的列****不要建立索引；</p>
<p>​    有****大量重复的列****不建立索引；</p>
<p>​    <em><strong>*表记录太少不要建立索引。*<em><strong>只有当 数据库里已经有了足够多的测试数据时，它的性能测试结果才有实际参考价值。如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快–不管有没有使用索引。</strong></em>*只有当数据库里的记录超过了1000条*<em><strong>、</strong></em>*数据总量也超过了MySQL服务器上的内存总量时，数据库的性能测试结果才有意义。*</strong></em></p>
<h2 id="6-15、覆盖索引"><a href="#6-15、覆盖索引" class="headerlink" title="6.15、覆盖索引"></a>6.15、覆盖索引</h2><p>​    <em><strong>*如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称 之为“覆盖索引”。*</strong>***</em>*我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。SQL只需要通过索引就可以返回查询所需要的数据，而不必通过二级索引查到主键之后再去查询数据。****</p>
<p><em><strong>*解释一：*</strong></em> <em><strong>*就是select的数据列只用从索引中就能够取得，不必从数据表中读取，*</strong>***</em>*换句话说查询列要被所使用的索引覆盖。****</p>
<p><em><strong>*解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。*</strong></em></p>
<p><em><strong>*解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。*</strong></em></p>
<h2 id="6-16、聚集索引"><a href="#6-16、聚集索引" class="headerlink" title="6.16、聚集索引"></a>6.16、聚集索引</h2><p>​    <em><strong>*聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据。*</strong></em></p>
<h2 id="6-17、辅助索引"><a href="#6-17、辅助索引" class="headerlink" title="6.17、辅助索引"></a>6.17、辅助索引</h2><p>​    <em><strong>*辅助索引，也叫非聚集索引。和聚集索引相比，叶子节点中并不包含行记录的全部数据。*</strong></em></p>
<h2 id="6-18、SQL优化的一些部分"><a href="#6-18、SQL优化的一些部分" class="headerlink" title="6.18、SQL优化的一些部分"></a>6.18、SQL优化的一些部分</h2><h3 id="6-18-1、SQL优化的30条建议"><a href="#6-18-1、SQL优化的30条建议" class="headerlink" title="6.18.1、SQL优化的30条建议"></a>6.18.1、SQL优化的30条建议</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486461&amp;idx=1&amp;sn=60a22279196d084cc398936fe3b37772&amp;chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&amp;token=1987003517&amp;lang=zh_CN%23rd">https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486461&amp;idx=1&amp;sn=60a22279196d084cc398936fe3b37772&amp;chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&amp;token=1987003517&amp;lang=zh_CN%23rd</a></p>
<h2 id="6-19、数据库相关操作语句"><a href="#6-19、数据库相关操作语句" class="headerlink" title="6.19、数据库相关操作语句"></a>6.19、数据库相关操作语句</h2><p>​    <em><strong>*数据库范式：1NF:每个关系的属性都是原子的，不可能分割。每一个列只有一个值。*</strong></em></p>
<p>​    <em><strong>*2NF:*</strong></em> 如果关系模式R是1NF，且每一个<em><strong>*非主属性*</strong>***</em>*完全依赖********(而不能部分依赖)于候选建****，那么就称R是第二范式。</p>
<p>​    <em><strong>*3NF：如果关系模式R是2NF，且关系模式R（U,F）中的所有*</strong>***</em>*非主属性对任何候选关键字都不存在传递依赖****<em><strong>*，则称关系R是属于第三范式。*</strong></em></p>
<p>​    <em><strong>*BCNF:*</strong></em> <em><strong>*BC范式（BCNF）：符合3NF，并且，*</strong>***</em>*主属性不依赖于主属性****</p>
<p>​    </p>
<p>​    <em><strong>*内连接NNER JOIN：*</strong>***</em>*内连接是一种一一映射关系，就是两张表都有的才能显示出来****</p>
<p>​    <em><strong>*左连接LEFT JOIN:*</strong></em> <em><strong>*左连接是左边表的所有数据都有显示出来*</strong>***</em>*，右边的表数据只显示共同有的那部分，没有对应的部分只能补空显示.****</p>
<p>​    <em><strong>*右连接RIGHT JOIN:右连接，*</strong>***</em>*右边表的所有数据都会显示出来****<em><strong>*，左边的只会出现共同的那部分，其他的空。*</strong></em></p>
<p>​    <em><strong>*全连接、外连接Outer Join :*</strong></em> <em><strong>*查询出左表和右表所有数据，但是去除两表的重复数据*</strong></em></p>
<h2 id="6-20、MySQL中一条SQL语句的执行过程"><a href="#6-20、MySQL中一条SQL语句的执行过程" class="headerlink" title="6.20、MySQL中一条SQL语句的执行过程"></a>6.20、MySQL中一条SQL语句的执行过程</h2><p>​    <em><strong>*查询sql的执行语句：*</strong></em></p>
<p>1、客户端通过TCP连接发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配。</p>
<p>2、建立连接后客户端发送一条语句，mysql收到该语句后，通过命令分发器判断其是否是一条select语句，如果是，在开启查询缓存的情况下，先在查询缓存中查找****该SQL是否完全匹配*<em><strong>，如果完全匹配，</strong></em>*验证当前用户是否具备查询权限****，如果权限验证通过，直接返回结果集给客户端，该查询也就完成了。如果不匹配继续向下执行。</p>
<p>3、如果在查询缓存中未匹配成功，则将语句交给****分析器作语法分析****，MySQL需要知道到底要查哪些东西，如果语法不对，就会返回语法错误中断查询。</p>
<p>4、分析器的工作完成后，****将语句传递给预处理器，检查数据表和数据列是否存在****，解析别名看是否存在歧义等。</p>
<p>5、语句解析完成后，MySQL就知道要查什么了，之后会将<em><strong>*语句传递给优化器进行优化*<em><strong>（通过索引选择最快的查找方式），</strong></em>*并生成执行计划。*</strong></em></p>
<p>6、****之后交给执行器去具体执行该语句，在执行之前，会先检查该用户是否具有查询权限，如果有，继续执行该语句。****执行器开始执行后，会逐渐将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。</p>
<p>group by语法可以根据给定数据列的每个成员对查询结果进行分组统计，最终得到一个分组汇总表。</p>
<p>SELECT DEPT, <em><strong>*MAX(SALARY)*</strong></em> AS MAXIMUM FROM STAFF <em><strong>*GROUP BY DEPT ：每个部分的最高薪水*</strong></em></p>
<p>SELECT DEPT, <em><strong>*sum( SALARY )*</strong></em> AS total FROM STAFF <em><strong>*GROUP BY DEPT，每个部门的总薪水*</strong></em></p>
<p>having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。我的理解就是真实表中没有此数据，这些数据是通过一些函数生存。</p>
<p>SELECT region, SUM(population), SUM(area) FROM bbc GROUP BY region <em><strong>*HAVING SUM(area)&gt;1000000*</strong></em></p>
<p>SELECT DEPT, MAX( SALARY ) AS MAXIMUM, MIN( SALARY ) AS MINIMUM FROM staff GROUP BY DEPT</p>
<p><em><strong>*HAVING COUNT( * ) &gt;2*</strong></em> ORDER BY DEPT</p>
<p>查询最近N天(不超过30天)某一款产品的订单。从第10条开始取5条，ID从大到小倒序。</p>
<p>select * from table limit 9,5;#从0开始</p>
<p>写代码 创建索引</p>
<p>CREATE (UNIQUE/FULLTEXT/) INDEX indexName ON mytable(username(length)); </p>
<p>ALTER table tableName ADD INDEX indexName(columnName)</p>
<p>CREATE TABLE mytable(  </p>
<p>ID INT NOT NULL,  </p>
<p>username VARCHAR(16) NOT NULL,  </p>
<p>INDEX [indexName] (username(length)) );</p>
<h2 id="6-21、主从复制架构相关"><a href="#6-21、主从复制架构相关" class="headerlink" title="6.21、主从复制架构相关"></a>6.21、主从复制架构相关</h2><p><em><strong>*数据库主从复制：*</strong></em></p>
<p><em><strong>*复制的用途：*<em><strong>1、</strong></em>*读写分离，提供数据库性能和并发能力。2、实时备灾，用于故障切换。*</strong></em></p>
<p><em><strong>*复制存在的问题：*<em><strong>1、主库宕机后，数据可能丢失。2、主库写压力大时，复制可能延时。</strong></em>*复制延迟怎么解决？？？*</strong></em></p>
<p><em><strong>*复制原理：*<em><strong>主从复制是myql内带功能，是一个异步的过程，</strong></em>*把主库的二进制日志文件binlog,复制到从库上，然后从库在本地完全顺序的执行日志中的各种操作。*</strong></em></p>
<p>****复制过程*<em><strong>：1、</strong></em>*主节点log dump线程：*<em><strong>当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。</strong></em>*在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。2、从节点I/O线程：*<em><strong>当从节点上执行<code>start slave</code>命令之后，从节点会</strong></em>*创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点bin log dump 进程发来的更新之后，保存在本地relay-log中*<em><strong>。</strong></em>*3、从节点SQL线程：SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性****。</p>
<p>从节点上的I/O 进程连接主节点，****并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容*<em><strong>；主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还</strong></em>*包括本次返回的信息的bin-log file 的以及bin-log position；****从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。</p>
<p>MySQL <em><strong>*主从复制默认是异步的模式：*</strong></em></p>
<p>****异步复制：主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理****；主节点不会主动push bin log到从节点；</p>
<p><em><strong>*半同步模式*</strong>***</em>*：这种模式下主节点只需要接收到其中一台从节点的返回信息，就会commit****；否则需要等待直到超时时间然后切换成异步模式再提交；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性。半同步模式不是mysql内置的，需要装插件开启半同步模式。</p>
<p><em><strong>*全同步模式*<em><strong>：</strong></em>*全同步模式是指主节点和从节点全部执行了commit并确认才会向客户端返回成功。*</strong></em></p>
<p>****binlog记录格式：1、基于SQL语句的复制：*<em><strong>记录会修改数据的sql语句到binlog中，减少了binlog日志量，节约IO,提高性能。某些情况：会导致主从节点中数据不一致。</strong></em>*2、基于行的复制*<em><strong>：将SQL语句分解为基于Row更改的语句并记录在bin log中，也就是只记录哪条数据被修改了，修改成什么样。优点</strong></em>*：解决了特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点日志量太大。3、混合方式****：能语句就语句，不能语句就切换行。</p>
<p>数据库用到了****读写分离****，那你知不知道这样做会有什么问题：</p>
<p>在从库上会读到系统的一个过期状态”的现象，暂且称之为“过期读”。</p>
<p><em><strong>*强制走主库方案*<em><strong>其实就是，将查询请求做分类，</strong></em>*对于必须要拿到最新结果的请求，强制将其发到主库上。*</strong></em></p>
<p><em><strong>*sleep 方案*<em><strong>：</strong></em>*主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 select sleep(1) 命令。*</strong></em></p>
<p><em><strong>*mysql主从复制存在的问题：*</strong></em></p>
<p>​    主库宕机后，数据可能丢失</p>
<p>​    从库只有一个sql Thread，主库写压力大，<em><strong>*复制很可能延时*</strong></em></p>
<p><em><strong>*解决方法：*</strong></em></p>
<p>​    <em><strong>*半同步复制—解决数据丢失的问题*</strong></em></p>
<p>​    <em><strong>*并行复制—-解决从库复制延迟的问题（并行是指从库多线程apply binlog库级别并行应用binlog，同一个库数据更改还是串行的(5.7版并行复制基于事务组)设置）*</strong></em></p>
<p>Mysql逻辑架构可以分为两层：服务层和存储引擎。服务层：Mysql的核心服务功能，查询语句解析，缓存，词法语法分析。</p>
<h1 id="7、Redis"><a href="#7、Redis" class="headerlink" title="7、Redis"></a>7、Redis</h1><p>​    常见问题</p>
<p>​    Redis,key-Value类型的内存数据库，整个数据库系统在内存中操作，定期异步flush到硬盘上进行保存。常用于缓存，也可以作分布式锁。redis提供多种数据类型，支持事务，两种持久化方式，多种集群方案。</p>
<h2 id="7-1、Redis为什么要作为缓存？-高性能和高并发"><a href="#7-1、Redis为什么要作为缓存？-高性能和高并发" class="headerlink" title="7.1、Redis为什么要作为缓存？ 高性能和高并发"></a>7.1、Redis为什么要作为缓存？ 高性能和高并发</h2><p>  ****高性能****：用户第一次访问数据库时，是从硬盘上读取的，过程比较慢，效率比较低。redis作为缓存，将用户访问的诗句存在缓存中，下一次再访问这些数据时就可以直接从缓存中读取了，操作缓存就是直接存在内存，速度特别快。</p>
<p>  ****高并发:****直接操作缓存所能承受的请求远远大于直接访问数据库的。把数据库的部分数据存在缓存中，可提供并发能力。</p>
<h2 id="redis-memcached分布式缓存和map-guava本地缓存的区别"><a href="#redis-memcached分布式缓存和map-guava本地缓存的区别" class="headerlink" title="*redis/memcached分布式缓存和map/guava本地缓存的区别:*"></a><em><strong>*redis/memcached分布式缓存和map/guava本地缓存的区别:*</strong></em></h2><p>  缓存分为本地缓存和分布式缓存，使用map或guava的是本地缓存，轻量而快速，随着jvm的销毁而结束，<em><strong>*多实例情况下，每个实例都保存一份缓存，缓存不具有一致性。*</strong></em></p>
<p>  ****分布式缓存，多实例情况下，各实例共用一份缓存数据，缓存具有一致性****。缺点，架构复杂，要保证服务的高可用。</p>
<h2 id="7-2、redis和memcached的区别"><a href="#7-2、redis和memcached的区别" class="headerlink" title="7.2、redis和memcached的区别"></a>7.2、redis和memcached的区别</h2><p>  1、****redis支持更丰富的数据类型****：redis不仅仅支持简单的k/v类型的数据，同时还提供list,set,zset,hash等数据结构的存储，memcached仅支持简单的数据类型，string.</p>
<p>  2、****reids支持数据的持久化，****可以将内存中的数据保存到磁盘中，重启的时候可以再次加载使用，而memcached不支持持久化。</p>
<p>  3、集群模式，memcached没有原生的集群模式，****redis目前是原生支持cluster模式的****。</p>
<p>  4、memcached<em><strong>*是多线程*<em><strong>，非阻塞IO复用的网络模型;</strong></em>*Redis使用单线程的多路IO复用模型。*</strong></em></p>
<h2 id="7-3、redis常用数据结构以及场景"><a href="#7-3、redis常用数据结构以及场景" class="headerlink" title="7.3、redis常用数据结构以及场景"></a>7.3、redis常用数据结构以及场景</h2><p>  string,hash,list,set,zset;key都是string,但value是多种数据结构的。</p>
<p>​    数据类型：</p>
<p>​    <em><strong>*String*</strong></em>:  <em><strong>*set、get、*</strong>***</em>*decr、incr、****</p>
<p>​    <em><strong>*hash*</strong></em>(将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在redis里);<em><strong>*hget,hset,*</strong>***</em>*hgetall****</p>
<p>​    <em><strong>*List*</strong></em>,粉丝列表；存储一些列表型的数据结构，类似粉丝列表了、文章的评论列表。<em><strong>*以通过lrange命令，就是从某个元素开始读取多少个元素*<em><strong>，可以基于list实现分页查询。）</strong></em>*lpush,rpush,lpop,rpop*</strong>***</em>*,lrange****</p>
<p>​    <em><strong>*Set：无序集合，自动去重set玩儿交集、并集、差集的操作*<em><strong>，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁。</strong></em>*Sadd, Spop, Sunion, sinterstore*</strong>***</em>*(交集)****</p>
<p>​    <em><strong>*Sorted Se*<em><strong>t，</strong></em>*去重但是可以排序*<em><strong>；最大的特点是有个分数可以自定义排序规则。</strong></em>*Zadd,Zrange,zcard*</strong></em></p>
<p>​    底层实现：</p>
<p>​    <em><strong>*简单动态字符串SDS:char[]数组加len属性和free属性（记录数组中未使用的字节数）；直接获取长度，防止溢出，*</strong></em></p>
<p>​    <em><strong>*Redis还实现了双端链表，双端，无环，带长度属性len;*</strong></em></p>
<p>​    ****Redis 的字典使用哈希表作为底层实现。链地址法解决冲突的哈希表实现的****。</p>
<p>​    跳跃表（skiplist）是一种有序数据结构，<em><strong>*它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序。*</strong></em></p>
<p>  1、<em><strong>*由很多层结构组成；*</strong></em></p>
<p>　　    2、<em><strong>*每一层都是一个有序的链表*</strong>***</em>*，****排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</p>
<p>　　3、<em><strong>*最底层的链表包含了所有的元素*</strong>***</em>*；****</p>
<p> 　4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</p>
<p>　　5、<em><strong>*链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；*</strong></em></p>
<h2 id="7-4、跳跃表的操作过程"><a href="#7-4、跳跃表的操作过程" class="headerlink" title="7.4、跳跃表的操作过程"></a>7.4、跳跃表的操作过程</h2><p>​    ①、搜索：从最高层的链表节点开始，****如果比当前节点要大和比当前层的下一个节点要小，那么则往下找****，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</p>
<p>　　②、插入：<em><strong>*首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，*</strong>***</em>*则需要将新元素插入到从底层到k层。****</p>
<p>　　<em><strong>*③*</strong>***</em>*、删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。****</p>
<p>​    ziplist编码的有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存****score****。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。</p>
<p>​    skiplist编码的有序集合底层是一个命名为zset的结构体，而一个<em><strong>*zset结构同时包含一个字典和一个跳跃表*<em><strong>。跳跃表</strong></em>*按score从小到大保存所有集合元素。而字典则保存着从member到score的映射*<em><strong>，</strong></em>*这样就可以用O(1)的复杂度来查找member对应的score值。*<em><strong>虽然同时使用两种结构，但它们会通过</strong></em>*指针来共享相同元素的member和score，因此不会浪费额外的内存。跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度。*</strong></em></p>
<p>  redis可以为key设置过期时间,对过期的key,采用定期删除和惰性删除的方式。</p>
<p>  定期****删除*<em><strong>：每100ms，</strong></em>*随机抽取一些设置过期时间的key,检查是否过期，****如过期，则删除。</p>
<p>惰性删除：一些过期的key,并没有被定性删除删除掉，****只有当系统使用并检查其过期了****，才会将其删除。</p>
<p>  大量key到内存中，达到redis内存最大值，会进行内存****淘汰机制****。</p>
<h2 id="7-5、Redis数据淘汰策略"><a href="#7-5、Redis数据淘汰策略" class="headerlink" title="7.5、Redis数据淘汰策略"></a>7.5、Redis数据淘汰策略</h2><p><em><strong>*noeviction,内存达到最大值，直接返回错误*<em><strong>。</strong></em>*allkeys-lru:所有键里最近最少使用;*</strong></em></p>
<p>  <em><strong>*allkeys-random:所有键随机回收*<em><strong>；</strong></em>*volatile-lru:设置过期时间的键中，回收最近最少使用的*<em><strong>，</strong></em>*volatile-random:设置过期集合键中，随机回收。*</strong></em></p>
<p>  <em><strong>*volatile-ttl:设置过期时间的键中，回收存活时间较短的键。*</strong></em></p>
<h2 id="7-6、redis持久化机制"><a href="#7-6、redis持久化机制" class="headerlink" title="7.6、redis持久化机制"></a>7.6、redis持久化机制</h2><p>redis持久化就是将内存中的数据写入到硬盘中，为了备份重用数据。支持两种持久化方式，快照RDB和只追加文件AOF;</p>
<p>  快照RDB,通过创建快照获得某个时间点的数据副本，可以对快照进行备份，或者复制到其他机器重用数据。默认的持久化方式。<em><strong>*save 900 20,在15分钟之后，有20个key变化，触发快照。*</strong></em></p>
<p>****AOF,实时性更好*<em><strong>，</strong></em>*主流方案，默认没有开启****。开启后，每执行一条更改redis数据的命令，都将该命令写入磁盘的AOF中。三种AOF方式， always,每次修改都写入AOF; everysec,每秒钟同步一次，多个命令一次写入。 no,操作系统决定何时同步。</p>
<p><em><strong>*RDB优缺点：每个RDB都代表了某一时刻redis的数据，适合做冷备份，且恢复数据速度快。缺点：实时性不好，可能会丢失部分数据，如果文件过大， 可能会导致提供的服务暂停几秒。*</strong></em></p>
<p><em><strong>*AOF优缺点：实时性好，一般1s一写入，而且写入性能比较好。缺点:AOF文件更大，开启后QDS相对来说比较低，恢复速度慢。*</strong></em></p>
<p>​    综合AOF和RDB两种持久化方式，用AOF来保证数据不丢失，作为恢复数据的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，可以使用RDB进行快速的数据恢复。</p>
<h2 id="7-7、redis事务"><a href="#7-7、redis事务" class="headerlink" title="7.7、redis事务"></a>7.7、redis事务</h2><p>redis使用MULTI、EXEC、WATCH等命令实现事务功能。MULTI开始事务，EXEC，执行事务。DISCARD取消事务，WATCH监视key;</p>
<p>  <em><strong>*单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以*</strong></em> <em><strong>*Redis 事务的执行并不是原子性的。*</strong></em></p>
<p>  事务可以理解为一<em><strong>*个打包的批量执行脚本，但批量指令并非原子化的操作*</strong>***</em>*，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。****</p>
<h2 id="7-8、缓存雪崩和缓存穿透"><a href="#7-8、缓存雪崩和缓存穿透" class="headerlink" title="7.8、缓存雪崩和缓存穿透"></a>7.8、缓存雪崩和缓存穿透</h2><p>  缓存雪崩，缓存在同一时间内大面积失效，所有的请求都落在数据库中，数据库短时间内承受大量请求而崩掉。</p>
<p>  缓存同一时间内失效课可能是****服务器宕机或者设置了相同时间过期的key同时失效****。</p>
<p>  事前，****尽量保证redis集群的高可用性，key的过期时间尽可能错开****。</p>
<p>  事中，本地ehcache缓存(先查本地缓存再查redis,然后数据库)+hystrix限流(每秒就接受一定量的请求)&amp;降级(多余的请求走降级组件);</p>
<p>  <em><strong>*事后，*</strong>***</em>*利用持久化机制恢复缓存。****</p>
<p>  <em><strong>*缓存穿透，查询一个根本不存在的数据，缓存层和数据库都不命中，失去了缓存的意义。*</strong></em></p>
<p>  解决方案1、<em><strong>*对空结果作缓存*</strong>***</em>*，****意味着设置更多的键，占用更多的内存，所以要过期时间设置很短。</p>
<p>  <em><strong>*2*</strong>***</em>*、布隆过滤器****：将所有可能存在数据哈希到一个bitMap中，拦截不存在的数据访问，缺点有一定的误识别率。</p>
<h2 id="7-9、并发竞争key问题"><a href="#7-9、并发竞争key问题" class="headerlink" title="7.9、并发竞争key问题"></a>7.9、并发竞争key问题</h2><p>多个系统同时对一个key进行操作,执行顺序不同导致与期望结果不同。使用分布式锁解决。</p>
<p>  redis实现分布式锁。</p>
<p>  zookeeper实现分布式锁。</p>
<h2 id="7-10、如何保证缓存和数据库双写时的数据一致性？"><a href="#7-10、如何保证缓存和数据库双写时的数据一致性？" class="headerlink" title="7.10、如何保证缓存和数据库双写时的数据一致性？"></a>7.10、如何保证缓存和数据库双写时的数据一致性？</h2><p>  当发生数据修改时，是先更新数据库还是先更新缓存。缓存的更改是更新缓存还是直让原有缓存失效。</p>
<p><em><strong>*一般来说是先更新数据库，然后让缓存失效，将失效信息发送到mq中，mq不断的重试让缓存失效，保证缓存和数据库的数据一致性。*</strong></em></p>
<p><em><strong>*先删除缓存，再更新数据库：A写然后删除缓存，然而B查询缓存不存在，查询数据库得到旧值，然后缓存旧值。然后A更新数据库。这就造成了数据库和缓存不一致。*</strong>***</em>*这时采用延时双删策略：先删除缓存，然后更新数据库，然后休眠一段时间内如1s，再删除缓存。淘汰这一段时间的缓存脏数据。****</p>
<p>​    <em><strong>*如果mysql采用了读写分离：也会造成数据不一致。A想写，先删缓存，然后写入数据库。B读请求，没有缓存，读取从库旧值，然后缓存旧值，数据库主从同步。还可以采用延时双删的策略，延时的时间长点，完成主从同步。*</strong></em></p>
<p>采用这种同步淘汰策略，吞吐量降低怎么办？第二步的删除作为异步，启动一个线程去删除。</p>
<p><em><strong>*第二次删除,如果删除失败怎么办？*</strong></em></p>
<p><em><strong>*先更新数据库，再删除缓存*</strong></em></p>
<p><em><strong>*缓存更新套路：*</strong></em></p>
<p>​    失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</p>
<p>命中：应用程序从cache中取数据，取到后返回。</p>
<p><em><strong>*更新：先把数据存到数据库中，成功后，再让缓存失效。*</strong></em></p>
<p>缓存刚好失效，<em><strong>*A做查询，得到旧值，B做更新，让缓存失效。A将旧值缓存。但由于B是更新然后让缓存失效，这一耗时明显大于A查询然后缓存旧值，所以出现不一致的概率很低。如果非要解决，就用延时双删，再删除一次呗。*</strong></em></p>
<p><em><strong>*所以，如果删除缓存失败怎么办？*</strong></em></p>
<p>​    <em><strong>*提供一个保障的重试机制即可。一、将需要删除的key发送给消息队列，保证其删除成功。*</strong></em></p>
<p>二、降低耦合性的方案：（1）更新数据库数据（2）数据库会将操作信息写入****binlog日志*<em><strong>当中（3）</strong></em>*订阅程序提取出所需要的数据以及key*<em><strong>（4）</strong></em>*另起一段非业务代码，获得该信息****（5）尝试删除缓存操作，发现删除失败（6）将这些信息发送至消息队列（7）重新从消息队列中获得该数据，重试操作。</p>
<h2 id="7-11、redis是单线程的，为什么还那么快？"><a href="#7-11、redis是单线程的，为什么还那么快？" class="headerlink" title="7.11、redis是单线程的，为什么还那么快？"></a>7.11、redis是单线程的，为什么还那么快？</h2><p>  <em><strong>*1、操作完全基于内存，速度快。*</strong></em></p>
<p>  <em><strong>*2、数据结构简单，对数据的操作也简单。*</strong></em></p>
<p>  <em><strong>*3、采用单线程，避免了不必要的上下文切换开销。*</strong></em></p>
<p>  <em><strong>*4、使用非阻塞的多路IO复用模型。*</strong></em></p>
<p>​    I/O 多路复用模型是****利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力*<em><strong>，在空闲的时候，会把当前线程阻塞掉，</strong></em>*当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流*<em><strong>（epoll是只轮询那些真正发出了事件的流），</strong></em>*并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。*<em><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong></em>*采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快****（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>
<p>​    <em><strong>*I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），*</strong>***</em>*让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。****<em><strong>*与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。*</strong></em></p>
<h2 id="7-12、Select、poll、epoll"><a href="#7-12、Select、poll、epoll" class="headerlink" title="7.12、Select、poll、epoll"></a>7.12、Select、poll、epoll</h2><p>​    <em><strong>*select缺点：每次调用select，都需要把fd_set集合从用户态拷贝到内核态，都需要在内核遍历传递进来的所有fd_set，且内核对被监控的fd_set集合大小做了限制，为1024。*</strong></em></p>
<p>​    <em><strong>*poll缺点：poll没有最大文件描述符数量的限制，其他缺点和select一样。数据结构变成了pollfd*</strong></em></p>
<p>​    <em><strong>*epoll:*</strong></em> <em><strong>*最大连接数没有限制，采用事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面*</strong></em></p>
<h2 id="7-13、Unix五种IO模型"><a href="#7-13、Unix五种IO模型" class="headerlink" title="7.13、Unix五种IO模型"></a>7.13、Unix五种IO模型</h2><p><em><strong>*阻塞IO*</strong>***</em>*,**** <em><strong>*网络编程中，读取客户端的数据需要调用recvfrom。在默认情况下，这个调用会一直阻塞直到数据接收完毕，就是一个同步阻塞的IO方式。内核准备数据，并将数据从内核拷贝到用户内存，内核返回结果，用户进程再解除阻塞状态，重新运行起来。*</strong>***</em>*非阻塞IO*<strong><strong><strong>*：用户进程调用recvfrom之后，如果内核数据没有准备好，并不会阻塞用户进程，而是立即返回数据未准备好的结果，*</strong></strong></strong>*用户进程以后不断调用recvfrom来轮询内核是否准备好数据*<strong><strong><strong>*。*</strong></strong></strong>*信号驱动IO,*<strong><strong><strong>*调用之后，不等待数据就绪立即返回，*</strong></strong></strong>*等内核准备好数据之后，发送信号给用户进程*<strong><strong><strong>*。异步IO,**</strong> *<strong>*读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。对比信号驱动IO，异步IO的主要区别在于*</strong></strong></strong>*：信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)****<em><strong>*。IO多路复用：可以处理多个连接。这里的select相当于一个“代理”，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于select可以监听多个socket，我们可以用它来处理多个连接。*</strong></em></p>
<p>​    </p>
<h2 id="7-14、redis热key问题"><a href="#7-14、redis热key问题" class="headerlink" title="7.14、redis热key问题"></a>7.14、redis热key问题</h2><p><em><strong>*某个key被大量访问，对redis服务器造成了很大的压力。*</strong></em></p>
<p><em><strong>*解决方案：*</strong></em></p>
<p>1、服务端缓存：即将热点数据缓存至服务端的内存中，利用 ehcache ，或者一个 HashMap 都可以。在你发现热key以后，把热key加载到系统的JVM中。针对这种热key请求，会直接从jvm中取，而不会走到redis层。这个可能发生缓存和redis数据不一致的情况。利用Redis自带的消息通知机制，对于热点Key建立一个监听，当热点Key有更新操作的时候，缓存也随之更新。</p>
<p>2、备份热key, 即将热点Key+随机数，随机分配至Redis其他节点中。这样访问热点key的时候就不会全部命中到一台机器上了。（Redis集群中包含了****16384*<em><strong>个哈希槽(Hash slot)，集群使用公式</strong></em>*CRC16(key) % 16384来计算Key属于哪个槽。*<em><strong>那么同一个Key计算出来的值应该都是一样的，如何将Key分到其他机器上呢？</strong></em>*只要再后面加上随机数就行了****，这样就能保证同一个Key分布在不同机器上）</p>
<h2 id="7-15、如何发现热key"><a href="#7-15、如何发现热key" class="headerlink" title="7.15、如何发现热key?"></a>7.15、如何发现热key?</h2><p><em><strong>*1*</strong>***</em>*、经验预估****<em><strong>*。*</strong></em></p>
<p>****2、R****edis自带命令查询：Redis4.0.4版本提供了redis-cli –hotkeys就能找出热点Key.</p>
<p>****3、****客户端收集：在操作Redis之前对数据进行统计。</p>
<h2 id="7-16、redis集群数据迁移方式"><a href="#7-16、redis集群数据迁移方式" class="headerlink" title="7.16、redis集群数据迁移方式"></a>7.16、redis集群数据迁移方式</h2><p>  redis集群并没有使用一致性hash,<em><strong>*而是使用数据分片引入哈希槽来实现。*</strong></em></p>
<p>  <em><strong>*redis集群共有16384个哈希槽，所有的键都将映射到哈希槽中，使用CRC16(key)%16384=哈希槽，集群按槽分片，每个节点指派不同数量的槽。*</strong></em></p>
<p>一致性hash,是<em><strong>*将整个hash值空间0-2^32-1组成一个虚拟圆环，key的哈希函数对2^32取模得到哈希值，在圆环上顺时针转，遇到的第一个服务器就是定位到的服务器。这样即使增加或减去一个服务器，对数据的影响比较小，数据迁移也比较简单。缺点：在某些极端情况下，可能数据扎堆分布在一个服务器上，当这个服务器出现问题，对整个系统的影响依然很大。*</strong>***</em>*针对分配不均的情况下，提出了虚拟节点，将服务器后面的ip或主机名后面增加编号，生成多个虚拟节点，分配到虚拟节点的数据实际上是分配到了该服务器上。****</p>
<p><em><strong>*普通的分布式缓存策略是：hash(obj)%N。当其中一个服务器宕机或者需要新增一个服务器时，缓存策略变为hash(obj)%(N-1);就意味着，所有的缓存都将失效。必定会造成缓存数据的丢失，会去向后端的服务器去请求。*</strong>***</em>*增加删除服务器时，代价比较大，所有的数据不得不根据id再次计算哈希值，然后%N*<strong><strong><strong>*,*</strong></strong></strong>*进行重新分配和大规模数据迁移。****</p>
<h2 id="7-17、分布式与集中式"><a href="#7-17、分布式与集中式" class="headerlink" title="7.17、分布式与集中式"></a>7.17、分布式与集中式</h2><p>​    ****CAP:C一致性，A可用性，P分区容错性****。这三个基本需求，最多能满足两个。</p>
<p><em><strong>*BASE: 基本可用，软状态，最终一致性。*</strong></em></p>
<p>​    </p>
<h2 id="7-18、分布式锁"><a href="#7-18、分布式锁" class="headerlink" title="7.18、分布式锁"></a>7.18、分布式锁</h2><p><em><strong>*惯用关系数据库固有的排他性实现不同进程之间的互斥，但关系数据库瓶颈所在，别啥都交给人家。*</strong></em></p>
<p><em><strong>*redis的SETNX命令可以方便的实现分布式锁。*</strong></em>  <em><strong>*setNX（SET if Not eXists）+ expire;*</strong></em></p>
<p>如果是为了效率(efficiency)而使用分布式锁，允许锁的偶尔失效，那么使用单Redis节点的锁方案就足够了，简单而且效率高；****如果是为了正确性(correctness)在很严肃的场合使用分布式锁，那么不要使用Redlock****；应该考虑类似Zookeeper的方案，或者支持事务的数据库。</p>
<p><em><strong>*1.获取当前时间戳*</strong></em></p>
<p>****2.client尝试按照顺序使用相同的key,value获取所有redis服务的锁****，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的redis服务。并且试着获取下一个redis实例。</p>
<p>比如：TTL为5s,设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁</p>
<p><em><strong>*3.client通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于TTL时间并且至少有3个redis实例成功获取锁，才算真正的获取锁成功*</strong></em></p>
<p><em><strong>*4.如果成功获取锁，则锁的真正有效时间是 TTL减去第三步的时间差 的时间；比如：TTL 是5s,获取所有锁用了2s,则真正锁有效时间为3s(其实应该再减去时钟漂移);*</strong></em></p>
<p><em><strong>*5.如果客户端由于某些原因获取锁失败，便会开始解锁所有redis实例；因为可能已经获取了小于3个锁，必须释放，否则影响其他client获取锁*</strong></em></p>
<h2 id="7-19、Zookeeper分布式锁"><a href="#7-19、Zookeeper分布式锁" class="headerlink" title="7.19、Zookeeper分布式锁"></a>7.19、Zookeeper分布式锁</h2><p><em><strong>*竞争分布式锁，在一个节点下，创建临时序列节点，找出最小的序列节点，获取分布式锁，程序执行完成之后此序列节点消失，通过watch来监控节点的变化，从剩下的节点的找到最小的序列节点，获取分布式锁，执行相应处理，依次类推……*</strong></em></p>
<h2 id="7-20、架构相关"><a href="#7-20、架构相关" class="headerlink" title="7.20、架构相关"></a>7.20、架构相关</h2><p><em><strong>*主从+哨兵：*</strong></em></p>
<p>​    <em><strong>*通过持久化功能，Redis能把内存中数据保存到硬盘上，保证了即使在服务器重启的情况下也不会损失（或少量损失）数据。数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上。Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库[1] （slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。*</strong></em></p>
<p>​    <em><strong>*当从数据库启动时，*</strong>***</em>*会向主数据库发送sync命令****<em><strong>*，主数据库接收到sync后开始在后台保存快照rdb，在保存快照期间受到的命令缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从数据库。从数据库依据快照和命令和主节点保持同步。之后，主每受到1个命令就同步发送给从数据库。*</strong></em></p>
<p><em><strong>*当出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库、增量复制。*</strong></em></p>
<p><em><strong>*master每次接收到写命令之后，先在内部写入数据，然后异步发送给slave node*</strong></em></p>
<p><em><strong>*如果采用了主从架构，那么建议必须开启master node的持久化！否则重启之后，认为自己没有数据，会把从节点清空，丢失数据。*</strong></em></p>
<p><em><strong>*slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量。*</strong></em></p>
<p><em><strong>*Slave node不会设置过期key，如果主节点一个key过期了，或者通过LRU淘汰了一个key,发送del命令给从节点。*</strong></em></p>
<p><em><strong>*master和slave都要知道各自的数据的offset，才能知道互相之间的数据不一致的情况。*</strong></em></p>
<p><em><strong>*哨兵：*</strong></em></p>
<p><em><strong>*Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。*</strong></em></p>
<p><em><strong>*哨兵的作用就是监控redis主、从数据库是否正常运行，主出现故障自动将从数据库转换为主数据库。*</strong></em></p>
<p>  <em><strong>*（1）监控主数据库和从数据库是否正常运行。*</strong></em> </p>
<p><em><strong>*（2）主数据库出现故障时自动将从数据库转换为主数据库。*</strong></em></p>
<p><em><strong>*主从切换过程：*</strong></em></p>
<p><em><strong>*（1） slave leader升级为master*</strong></em> </p>
<p><em><strong>*（2） 其他slave修改为新master的slave*</strong></em> </p>
<p><em><strong>*（3） 客户端修改连接*</strong></em> </p>
<p><em><strong>*（4） 老的master如果重启成功，变为新master的slave*</strong></em></p>
<p><em><strong>*1、两种数据丢失的情况*</strong></em></p>
<p><em><strong>*（1）异步复制导致的数据丢失，数据还没复制到slave，master就宕机了。*</strong></em></p>
<p><em><strong>*（2）脑裂导致的数据丢失。集群里就会有两个master，*</strong></em></p>
<p><em><strong>*解决方法：要求至少有1个slave，数据复制和同步的延迟不能超过10秒*</strong></em></p>
<p><em><strong>*如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求。*</strong></em></p>
<p><em><strong>*哨兵：*</strong>***</em>*sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，那么就是主观宕机****</p>
<p>​     <em><strong>*odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，那么就是客观宕机。*</strong></em></p>
<p><em><strong>*如果一个master被认为odown了，*</strong>***</em>*而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，****</p>
<p><em><strong>*接下来会对slave进行排序*</strong></em></p>
<p><em><strong>*（*</strong>***</em>*1）按照slave优先级进行排序，slave priority越低，优先级就越高****</p>
<p><em><strong>*（2）如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高*</strong></em></p>
<p><em><strong>*（3）如果上面两个条件都相同，那么选择一个run id比较小的那个slave*</strong></em></p>
<p><em><strong>*集群：*</strong></em></p>
<p><em><strong>*主从架构+哨兵机制虽然保证了Redis的高可用性，但每个Redis实例都是全量保存，浪费内存。为了最大化的利用内存，可以使用集群，也就是分布式存储，每台redis存储不同的内容。*</strong></em></p>
<p><em><strong>*Reids分布式数据存储算法不是一致性哈希，而是哈希槽算法。*</strong></em></p>
<p><em><strong>*redis cluster有固定的16384个hash slot，对每个key计算CRC16值，然后对16384取模，可以获取key对应的hash slot。*</strong></em></p>
<p><em><strong>*redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot。*</strong></em></p>
<p><em><strong>*hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去。移动成本很低。*</strong></em></p>
<p><em><strong>*Redis集群集成了主从复制和哨兵的功能。集群支撑N个redis master node，每个master node都可以挂载多个slave node*</strong></em></p>
<p><em><strong>*读写分离的架构，对于每个master来说，写就写到master，然后读就从mater对应的slave去读。*</strong></em></p>
<p><em><strong>*高可用，因为每个master都有salve节点，那么如果mater挂掉，redis cluster这套机制，就会自动将某个slave切换成master。redis cluster（多master + 读写分离 + 高可用）；*</strong></em></p>
<p><em><strong>*在redis cluster架构下，每个redis要放开两个端口号，比如一个是6379，另外一个就是加10000的端口号，比如16379。16379端口号是用来进行节点间通信的，也就是cluster bus的东西，集群总线。cluster bus的通信，用来进行故障检测，配置更新，故障转移授权。*</strong></em></p>
<p><em><strong>*集群是如何判断是否有某个节点挂掉：*</strong></em></p>
<p>​    每一个节点都存有这个集群所有主节点以及从节点的信息。它们之间通过互相的ping-pong判断是否节点可以连接上。****如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机了****，然后去连接它的备用节点。</p>
<p><em><strong>*集群进入fail状态的必要条件：*</strong></em></p>
<p>​    <em><strong>*1、*</strong>***</em>*某个主节点和所有从节点全部挂掉，我们集群就进入faill状态。****</p>
<p>​    <em><strong>*2、如果集群*</strong>***</em>*超过半数以上master挂掉****<em><strong>*，无论是否有slave，集群进入fail状态.*</strong></em></p>
<p>​    <em><strong>*3、如果集群*</strong>***</em>*任意master挂掉,且当前master没有slave.集群进入fail状态****<em><strong>*。*</strong></em></p>
<p>​    主节点宕机之后，从节点发起投票，投票过程是集群中所有master参与。选举的依据依次是：网络连接正常-&gt;5秒内回复过INFO命令-&gt;10*down-after-milliseconds内与主连接过的-&gt;从服务器优先级-&gt;复制偏移量-&gt;运行id较小的。</p>
<h1 id="8、Java-框架"><a href="#8、Java-框架" class="headerlink" title="8、Java 框架"></a>8、Java 框架</h1><h2 id="8-1、Spring-IOC"><a href="#8-1、Spring-IOC" class="headerlink" title="8.1、Spring IOC"></a>8.1、Spring IOC</h2><p>​    IOC（Inversion Of Controll，控制反转）是一种设计思想，将原本在程序中手动创建对象的控制权，交由给Spring框架来管理。IOC容器是Spring用来实现IOC的载体，IOC容器实际上就是一个Map(key, value)，Map中存放的是各种对象。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。IOC容器就像是一个工厂，当需要创建一个对象，只需要配置好配置文件/注解即可，不用考虑对象是如何被创建出来的，大大增加了项目的可维护性且降低了开发难度。</p>
<p>​    IOC就是控制反转，指创建对象控制权的转移，原本创建对象的主动权和时机由自己把控，而现在这种权利转移到Spring容器中。Spring根据配置文件或注解创建实例和管理实例之间的依赖关系，在程序运行时动态的创建对象以及管理对象之间的依赖应用。Spring的IOC有三种注入方式：<em><strong>*构造器注入、setter方法注入、接口注入。*</strong></em></p>
<h2 id="8-2、Spring-AOP"><a href="#8-2、Spring-AOP" class="headerlink" title="8.2、Spring AOP"></a>8.2、Spring AOP</h2><p>​    AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量，提高了系统的扩展性。</p>
<p>​    <em><strong>*Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。*</strong></em></p>
<p>​    <em><strong>*Spring AOP / AspectJ AOP 的区别？*</strong></em></p>
<p>​    Spring AOP属于运行时增强，而AspectJ是编译时增强。</p>
<p>​    Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。</p>
<p>​    AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。如果切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。</p>
<h2 id="8-3、AOP相关概念"><a href="#8-3、AOP相关概念" class="headerlink" title="8.3、AOP相关概念"></a>8.3、AOP相关概念</h2><p>​    <em><strong>*1.通知（Advice）*</strong></em></p>
<p>　　就是你想要的功能，也就是上面说的安全，事物，日志等。</p>
<p>  2.连接点（JoinPoint）</p>
<p>　　<em><strong>*spring允许你使用通知的地方，*</strong></em> <em><strong>*spring只支持方法连接点*</strong></em>.<em><strong>*只要记住，和方法有关的前前后后（抛出异常），都是连接点。*</strong></em></p>
<p>  <em><strong>*3.切入点（Pointcut）*</strong></em></p>
<p>　　<em><strong>*在连接点中选取几个点作为切入点，真正的放入通知*<em><strong>。</strong></em>*让切点来筛选连接点，选中那几个你想要的方法。*</strong></em></p>
<p>  4.切面（Aspect）</p>
<p>　　****切面是通知和切入点的结合*<em><strong>。</strong></em>*通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），****这就是一个完整的切面定义。</p>
<p>  5.引入（introduction）</p>
<p>　　****允许我们向现有的类添加新方法属性。****把切面引用到新方法。</p>
<p>  6.目标（target）</p>
<p>　　引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑。 </p>
<p>  7.代理(proxy)</p>
<p>　　怎么实现整套aop机制的，都是通过代理，这个一会给细说。</p>
<p>  8.织入(weaving)</p>
<p>　　<em><strong>*把切面应用到目标对象来创建新的代理对象的过程。*</strong></em></p>
<p>****前置通知[Before advice]****：在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。 </p>
<p>****正常返回通知[After returning advice]****：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。 </p>
<p>****异常返回通知[After throwing advice]****：在连接点抛出异常后执行。 </p>
<p>****返回通知[After (finally) advice]：****在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。 </p>
<p>****环绕通知[Around advice]：****环绕通知围绕在连接点前后，比如一个方法调用的前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。</p>
<h2 id="8-4、Bean的生命周期"><a href="#8-4、Bean的生命周期" class="headerlink" title="8.4、Bean的生命周期"></a>8.4、Bean的生命周期</h2><p>​    1、根据配置情况调用Bean构造方法或者工厂方法实例化bean对象;</p>
<p>​    2、利用依赖注入完成Bean中所有属性值的配置注入。</p>
<p>​    3、如果Bean实现了BeanNameAware接口，则调用Bean的setBeanName()方法传递Bean的ID。</p>
<p>​    4、如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory()方法传入当前工厂实例的引用。</p>
<p>​    5、如果Bean实现了ApplicationContextAware接口，则调用setApplicationContex ()方法传入当前ApplicationContex的引用。    </p>
<p>​    6、如果有BeanPostProcessor 和Bean关联，则调用该接口的预初始化方法postProcessBeforeInitialzation()bean进行加工操作。</p>
<p>​    7、如果bean 实现了 InitializingBean 接口，将调用 afterPropertiesSet()方法。</p>
<p>​    8、如果Bean 指定了 init-method 方法，它将被调用。</p>
<p>​    9、如果有BeanPsotProcessor 和 Bean 关联，则该接口的后置初始化方法 postProcessAfterInitialization() 方法将被调用。</p>
<p>​    10、如果bean的作用域scope=”prototype”,则调用者管理该 bean 的生命周期。如果作用范围为单例模型，将bean放入IOC缓存池，触发 spring 对该 bean 的生命周期管理。</p>
<p>​    11、程序使用bean</p>
<p>​    12、如果 Bean 实现了 DisposableBean 接口，Spring会调用destory()方法将bean销毁。如果配置文件中指定了destory-method，那将调用该方法销毁bean.</p>
<h2 id="8-5、Spring中的bean的作用域有哪些"><a href="#8-5、Spring中的bean的作用域有哪些" class="headerlink" title="8.5、Spring中的bean的作用域有哪些?"></a>8.5、Spring中的bean的作用域有哪些?</h2><p>​    <em><strong>*singleton:[*</strong>***</em>*ˈ*<strong><strong><strong>*s*</strong></strong></strong>*ɪ*<strong><strong><strong>*ŋɡlt*</strong></strong></strong>*ə********n]单例模式****，在整个Spring IoC容器中，只有一个bean实例，默认都是单例。</p>
<pre><code>  ***\*prototype:原型模式\****，每次从容器中请求bean,都会产生一个新的bean实例。
  
  ***\*request\****:每次HTTP请求，都会创建一个新的bean;
  
  ***\*session\****:同一个HTTP session共享一个bean,不同的session使用不同的bean.
  
  ***\*globalSessi\****on:同一个全局Session共享一个bean.   &lt;后面这三个只用应用到web应用时，作用域才有效&gt;
</code></pre>
<p><em><strong>*Spring MVC中的controller是默认单例的，为啥还线程安全？*</strong></em></p>
<p>  因为controller基本不定义属性(成员变量)，****属于无状态Bean，线程安全****。如果定义属性的话，最好scope=prototype;</p>
<p>  <em><strong>*Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身;*</strong></em></p>
<p>  对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法,比如RequestContextHolder; 它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。</p>
<h2 id="8-6、spring的事务管理方式"><a href="#8-6、spring的事务管理方式" class="headerlink" title="8.6、spring的事务管理方式"></a>8.6、spring的事务管理方式</h2><p>1、编程式事务，代码中硬编码 2、声明式事务。推荐使用。</p>
<p>  声明式事务，有基于xml的声明式事务，基于注解的声明式事务。</p>
<h2 id="8-7、Spring的事务隔离级别-5种"><a href="#8-7、Spring的事务隔离级别-5种" class="headerlink" title="8.7、Spring的事务隔离级别:5种"></a>8.7、Spring的事务隔离级别:5种</h2><p>  1:TransactionDefinition.ISOLATION_<em><strong>*DEFAULT*</strong></em>: 后端数据库默认隔离级别.Mysql-REPEATABLE_READ。Oracle-READ_COMMITTED;</p>
<p>  2:ISOLATION_<em><strong>*READ*</strong></em>_<em><strong>*UNCOMMITTED*</strong></em>:读未提交，允许读取未提交的数据变更。可能导致脏读、幻读或不可重复读。</p>
<p>  3:ISOLATION_<em><strong>*READ*</strong></em>_<em><strong>*COMMITTED*</strong></em>:读已提交，允许读取并发事务已经提交的数据。阻止脏读，可能导致幻读，或不可重复读。</p>
<p>  4:ISOLATION_<em><strong>*REPEATABLE*</strong></em>_<em><strong>*READ*</strong></em>:可重复读：可重复读，对同一字段的读取结果是一致的。可能发生幻读。</p>
<p>  5:ISOLATION_<em><strong>*SERIALIZABLE*</strong></em>:串行化，事务依次执行，不并发，但影响性能。</p>
<p><em><strong>*Spring的事务传播行为*<em><strong>：事务传播行为（propagation behavior）</strong></em>*指*</strong>***</em>*的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。****</p>
<p>  <em><strong>*支持当前事务的情况：*</strong></em></p>
<p>  PROPAGATION_REQUIRED：****当前存在事务就加入事务****，没有就创建。</p>
<p>  PROPAGATION_SUPPORTS：  ****当前存在事务就加入事务****，没有就以非事务的方式继续运行。</p>
<p>  PROPAGATION_MANDATORY：****当前存在事务就加入事务****，没有就抛出异常。</p>
<p>  不支持当前事务的情况：</p>
<p>  PROPAGATION_REQUIRES_NEW：创建一个新事务，<em><strong>*如果当前存在事务，把当前事务挂起。*</strong></em></p>
<p>  PROPAGATION_NOT_SUPPORTED：以非事务的情况继续运行，****如果当前存在事务，挂起当前事务****。</p>
<p>PROPAGATION_NEVER：以非事务的方式运行，<em><strong>*如果当前存在事务，抛出异常*</strong></em> </p>
<p>  PROPAGATION_NESTED： <em><strong>*如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行*<em><strong>；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED,</strong></em>*创建一个事务自己运行？*</strong></em></p>
<h2 id="8-8、将一个类声明spring-bean的注解有哪些"><a href="#8-8、将一个类声明spring-bean的注解有哪些" class="headerlink" title="8.8、将一个类声明spring bean的注解有哪些"></a>8.8、将一个类声明spring bean的注解有哪些</h2><p>  将类标识成可用于****@Autowired注解自动装配的bean,****注解的方式有：</p>
<p>  1、@<em><strong>*component*</strong></em>:通用注解，不知道是哪一层就用这个。</p>
<p>  2、@****Repository****：对应持久层，主要用于数据库相关操作。</p>
<p>  3、@<em><strong>*Service*</strong></em>:对应服务层，主要涉及操作持久层，进行逻辑;</p>
<p>  4、@****Controller****：对应控制层，主要用户接受用户请求并调用Service层返回数据给前端页面；</p>
<p><em><strong>*@Component 和 @Bean 的区别是什么？*</strong></em></p>
<p>  两者的目的一样，都是注册bean到Spring容器中</p>
<p>  1、作用对象不同: <em><strong>*@Component 注解作用于类，而@Bean注解作用于方法。*</strong></em></p>
<p>  2、@Component注解表明一个类会作为<em><strong>*组件类，并告知Spring要为这个类创建bean。*</strong></em></p>
<p>  ****@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean****。通常方法体中包含了最终产生bean实例的逻辑。</p>
<p>  3、<em><strong>*@Bean 注解比Component注解的自定义性更强。*</strong></em></p>
<h2 id="8-9、Spring-MVC的理解"><a href="#8-9、Spring-MVC的理解" class="headerlink" title="8.9、Spring MVC的理解"></a>8.9、Spring MVC的理解</h2><p>  Model1时代：jsp+javaBean,jsp既是控制层又是表现层， 前后端依赖严重，控制逻辑和表现逻辑混杂，代码重用率第，开发效率低。</p>
<p>  Model2时代：JavaBean+JSP+Servlet,这就是早期的 JavaWeb MVC开发模式,但抽象和封装程度还远远不够，程度可维护性和复用性低。</p>
<p>  Spring MVC 可以帮助我们进行更简洁的Web层的开发,天然与Spring集成，一般把后端项目分为Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p>
<h2 id="8-10、Spring-MVC工作原理"><a href="#8-10、Spring-MVC工作原理" class="headerlink" title="8.10、Spring MVC工作原理"></a>8.10、Spring MVC工作原理</h2><p>​    （1）客户端（浏览器）发送请求，直接请求到****DispatcherServlet****。(前端控制器本质是一个servlet,是SPringMVC提供的所有请求的的统一入口)</p>
<p>​    （2）DispatcherServlet根据请求信息<em><strong>*调用HandlerMapping，解析请求对应的Handler。*</strong></em></p>
<p>  （3）解析到对应的Handler后，开始由HandlerAdapter适配器处理。</p>
<p>  （4）****HandlerAdapter会根据Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑****。</p>
<p>  （5）处理器处理完业务后，会返回一个M<em><strong>*odelAndView对象，Model是返回的数据对象，View是个逻辑上的View。*</strong></em></p>
<p>  （6）<em><strong>*ViewResolver会根据逻辑View查找实际的View。*</strong></em></p>
<p>  （7）<em><strong>*DispaterServlet把返回的Model传给View。*</strong></em></p>
<p>（8）通过View返回给请求者（浏览器）</p>
<p>DispatcherServlet,前端控制器本质是一个servlet,是SPringMVC提供的所有请求的的统一入口;</p>
<h2 id="8-11、mybatis中-的区别"><a href="#8-11、mybatis中-的区别" class="headerlink" title="8.11、mybatis中$#的区别"></a>8.11、mybatis中$#的区别</h2><p>​    <em><strong>*#{} 这种取值是编译好SQL语句再取值,*</strong></em> <em><strong>*解析成一个参数标记符?*</strong></em></p>
<p>​    <em><strong>*${}会直接进行字符串替换。*</strong></em></p>
<p>​    <em><strong>*#{}是编译好SQL中有一个占位符，然后将参数值填充到SQL*</strong></em></p>
<p><em><strong>*所以：*</strong></em></p>
<p>​    <em><strong>*#{}方式能够很大程度防止sql注入。*</strong></em></p>
<p>​    <em><strong>*$方式无法防止Sql注入。*</strong></em></p>
<p>​    <em><strong>*$方式一般用于传入数据库对象，例如传入表名.*</strong></em></p>
<p>​    <em><strong>*一般能用#的就别用$.*</strong></em></p>
<h2 id="8-12、常用的spring注解"><a href="#8-12、常用的spring注解" class="headerlink" title="8.12、常用的spring注解"></a>8.12、常用的spring注解</h2><p>@Component , @Repository , @ Controller ,@Service , @Configration，@Bean  注册类</p>
<p>@<em><strong>*Autowired*</strong></em> ,  <em><strong>*@Resource默认安照名称进行装配，名称可以通过name属性进行指定，*</strong></em> </p>
<p>如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找</p>
<p><em><strong>*@autowired和@resource的区别，一个接口有两个类实现时怎么指定注入哪一个*</strong></em></p>
<p>@Autowired按<em><strong>*byType*<em><strong>自动注入, 而</strong></em>*@Resource默认按 byName自动注入罢了*</strong></em>;</p>
<p>如果当Spring上下文中存在不止一个UserDao类型的bean时，就会抛出****BeanCreationException*<em><strong>异常;如果Spring上下文中不存在UserDao类型的bean，也会抛出</strong></em>*BeanCreationException*<em><strong>异常。我们可以使用</strong></em>*@Qualifier配合@Autowired****来解决这些问题.</p>
<p>SpringMVC注解：</p>
<p>​    @RequestMapping、</p>
<p>​    @****PathVariable****：用于将请求URL中的模板变量映射到功能处理方法的参数上</p>
<p>​    @<em><strong>*ResponseBody*</strong></em> ：</p>
<p>​    @****RequestHeader****：</p>
<p>​    @<em><strong>*RequestParam*</strong></em></p>
<h1 id="9、Java基础知识"><a href="#9、Java基础知识" class="headerlink" title="9、Java基础知识"></a>9、Java基础知识</h1><h2 id="9-1、ThreadLocal"><a href="#9-1、ThreadLocal" class="headerlink" title="9.1、ThreadLocal"></a>9.1、ThreadLocal</h2><p>​    ThreadLocal类用来提供线程内部的局部变量，这种变量在多线程环境下访问时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static 类型，用于关联线程。static的ThreadLocal变量是一个与线程相关的静态变量，即一个线程内，static变量是被各个实例共同引用的，但是不同线程内，static变量是隔开的。</p>
<p>​    使用方法：一个class中定义了一个ThreadLocal变量。通过重写方法initialValue()初始化值。然后设置get()方法得到threadLocal.get();通过设置set()方法设置threadLoca.set(threadLocal.get()+10);然后一个线程任务对这个类的变量进行修改或者查找时，每个线程的变量使用的都是线程局部变量，互不影响。</p>
<p>​    </p>
<p>​    每个线程对象：Thread t = Thread.currentThread();每个线程对象都有自己的ThreadLocalMap的变量，Map变量，key值为ThreadLocal，value为值。所以每个线程都有自己的一个ThreadLocal变量，且各自的值独立。</p>
<p>Get的时候，先获取线程的ThreadLocalMap对象，如果存在的话，就获取他的值。</p>
<p>Set的时候，先获取线程的ThreadLocalMap对象，如果存在，就更新。不存在，就新建Map,key为ThreadLocal,值为value;</p>
<p>​    <em><strong>*总的来说，每个线程对象，都有自己的ThreadLocalMap变量，这个map变量，key就是自己维持的ThreadLocal对象,值为ThreadLocal的值。*</strong></em></p>
<p>​    因为线程必然要访问threadLocal变量，然后调用threadLocal.get()方法，这个方法的实现就是：先获取当前线程，然后获取当前线程的ThreadLocalMap对象，map对象的key就是维持的ThreadLocal对象，value就是变量的值。</p>
<p>public T get() {</p>
<p>​    <em><strong>*Thread t = Thread.currentThread();//获取当前线程*</strong></em></p>
<p>​    <em><strong>*ThreadLocalMap map = getMap(t);//获取当前线程的ThreadLocalMap对象*</strong></em></p>
<p>​    if (map != null) {</p>
<p>​      <em><strong>*ThreadLocalMap.Entry e = map.getEntry(this); //当前线程Map对象，是否含有此TreadLocal对象实例最为key,如果有，取值。*</strong></em></p>
<p>​      if (e != null) {</p>
<p>​        @SuppressWarnings(“unchecked”)</p>
<p>​        T result = (T)e.value;</p>
<p>​        return result;</p>
<p>​      }</p>
<p>​    }</p>
<p>​    return setInitialValue();</p>
<p>  }</p>
<h2 id="9-2、内存溢出是怎么回事？举个例⼦。"><a href="#9-2、内存溢出是怎么回事？举个例⼦。" class="headerlink" title="9.2、内存溢出是怎么回事？举个例⼦。"></a>9.2、内存溢出是怎么回事？举个例⼦。</h2><ul>
<li>内存溢出 out of memory，是指程序在申请内存时，没有⾜够的内存空间供其使⽤，出现out of memory。</li>
</ul>
<pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>Object<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>内存溢出可能的原因</p>
<ul>
<li><p>程序中存在死循环</p>
</li>
<li><p>静态变量和静态⽅法太多了</p>
</li>
<li><p> 内存泄漏：⽐如说⼀个静态的list，⼀直往⾥放值，⼜因为静态变量不会被释放，所以迟早是要内存溢出的</p>
</li>
<li><p>⼤对象过多：java中的⼤对象是直接进⼊⽼年代的，然后当多个⼤对象同时⼯作时造成程序的可⽤内存⾮常⼩，⽐如我</p>
<p>list中原本最多可以放1000个对象，因为可⽤内存太⼩，放了500个就放不下了。</p>
</li>
<li><p>程序分配内存过⼩：还有⼀种很常⻅的情况，在把⼀个很⼤的程序直接导⼊，直接就内存溢出了，原因就是内存相对这</p>
<p>个程序就是太⼩了，需要⼿动增加内存。</p>
</li>
</ul>
</li>
<li><p>内存泄漏：是指程序在申请内存后，⽆法释放已申请的内存空间，⼀次内存泄漏危害可以忽略，但内存泄漏堆</p>
<p>积后果很严重，⽆论多少内存,迟早会被占光。</p>
<ul>
<li>内存泄露的场景<ul>
<li><strong>使用静态的集合类</strong>：静态的集合类的生命周期和应用程序的生命周期一样长；</li>
<li><strong>单例模式可能会造成内存泄露</strong>：实例对象的生命周期和应用程序的生命周期一样长，如果单例对象中拥有另一个对象的引用的话，这个被引用的对象就不能被及时回收；</li>
<li><strong>数据库、网络、输入输出流，这些资源没有关闭</strong></li>
<li>非静态内部类对象的构建依赖于其外部类，内部类对象会持有外部类对象的this引用，即时外部类对象不再被使用了，其占用的内存可能不会被GC回收，因为内部类的生命周期可能比外部类的生命周期要长，从而造成外部类对象不能被及时回收。<ul>
<li>解决办法：尽量使用静态内部类</li>
</ul>
</li>
<li><strong>变量不合理的作用域</strong>：能声明局部变量，就不要整成成员变量。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="9-3、反射"><a href="#9-3、反射" class="headerlink" title="9.3、反射"></a>9.3、反射</h2><p>​    定义：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能成为Java反射机制。</p>
<p>​    提供的功能：在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；</p>
<p>​    原理：获取类的Class对象，然后反向获取类或对象的各种信息。（class对象和.class文件的构造？？？）</p>
<p>​    获取class对象的三种方法：Class.forName(“全类名”)；类名.class；对象.getClass()；</p>
<p>​    <em><strong>*然后根据class对象获取类的各种信息*</strong></em>    <em><strong>*:*</strong></em> ****getMethods()获取所有public方法，getConstructors()获取构造方法，获取getDeclaredFields()获取所有的属性。class.newInstance() ,并强转类型，然后就可以操作对象了。对私有方法和属性，可以setAccessible(true)，然后进行操作。****所以反射是能够改变单例模式的，只需要获取私有的构造方法，然后setAccessible(true),然后通过构造方法创建对象就行。但并不破坏封装。封装的含义和单例的含义不一样，封装是将一组程序封装起来，对外提供接口，让外部调用人员不必在意里面的实现环节，直接调用即可。而外部人员及时通过反射获取到了里面的一些私有，仍然是不能窥探其实现逻辑的，单纯的调用其私有方法， 没有任何的意义。</p>
<p>​    反射的应用场景：</p>
<p>​    我们在使用<em><strong>*JDBC连接数据库时使*</strong>***</em>*用Class.forName()通过反射加载数据库的驱动程序*<em><strong>；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。</strong></em>*Spring 通过 XML 配置模式装载 Bean 的过程*<em><strong>：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)</strong></em>*使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性。****</p>
<p>String是怎么扩容的（不知道，后来查的：2倍扩容，超出1M后每次扩大1M）</p>
<p>为什么会出现 4.0-3.6=0.40000001 这种现象？</p>
<p>​    <em><strong>*2进制的小数无法精确的表达10进制小数，*</strong>***</em>*计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。****</p>
<h2 id="9-4、面向对象特性"><a href="#9-4、面向对象特性" class="headerlink" title="9.4、面向对象特性"></a>9.4、面向对象特性</h2><p>​    ****抽象****：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。</p>
<p>​    ****封装****：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。封装分为属性的封装和方法的封装。核心思想就是“隐藏细节”、“数据安全”：将对象不需要让外界访问的成员变量和方法私有化，只提供符合开发者意愿的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定。好处：良好的封装能减少耦合，对成员变量更精确的控制。</p>
<p>​    ****继承：****子类可以继承父类的非私有方法和属性(默认属性和方法也不行)，达到复用代码的效果。Java是单继承，一个类只能继承一个父类。</p>
<p>​    <em><strong>*多态:*</strong></em> <em><strong>*不同类的对象对同一消息作出不同的响应叫做多态。同一消息可以根据发送对象的不同而采用多种不同的行为方式。*<em><strong>可以用于消除类型之间的耦合关系，Spring 的核心就是多态和面向接口编程。多态的分类，编译时多态，方法的重载，运行时多态，方法的覆盖。</strong></em>*多态存在的条件：存在继承关系，子类重写父类的方法，父类引用指向子类。*</strong></em></p>
<p>​    <em><strong>*Java 里对象方法的调用是依靠类信息里的方法表实现的。*</strong></em></p>
<p>重载：<em><strong>*发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。*</strong></em></p>
<p><em><strong>*重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。*</strong></em></p>
<h2 id="9-5、抽象类和接口"><a href="#9-5、抽象类和接口" class="headerlink" title="9.5、抽象类和接口"></a>9.5、抽象类和接口</h2><ul>
<li>语法层次<ul>
<li>抽象类可以有构造函数，接口不可以有构造函数 </li>
<li>抽象类中可以有普通成员变量，接口中没有普通成员变量，只能有常量</li>
<li>抽象类中可以有普通方法和抽象方法，接口中的方法全是抽象方法–&gt; <strong>jdk 1.8 接口中的方法还有default和static修饰的方法</strong></li>
<li>一个类只能继承一个抽象类，接口可以被多实现</li>
</ul>
</li>
<li>设计层次<ul>
<li>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</li>
<li>抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</li>
</ul>
</li>
<li>何时使用 <ul>
<li>如果要实现的类和该抽象类是同一类事物，则用继承抽象类的方法；不是同一类事物，就用接口；</li>
<li>要设计较小的功能模块，用接口，要设计较大的功能单元，用抽象类</li>
<li>如果大部分方法都不确定，用接口抽象所有方法；如果只有少部分方法不确定，另有部分方法是确定的，用抽象类，实现部分确定的方法，抽象部分不确定的方法</li>
</ul>
</li>
</ul>
<h2 id="9-6、static关键字和final关键字"><a href="#9-6、static关键字和final关键字" class="headerlink" title="9.6、static关键字和final关键字"></a>9.6、static关键字和final关键字</h2><p>static关键字：****static的主要作用在于创建独立于具体对象的域变量或者方法****。类变量随着类的加载而存在于方法区中。实例变量随着对象的建立而存在于堆内存中。类变量生命周期最长，随着类的消失而消失。实例变量生命周期随着对象的消失而消失。</p>
<p>​    ****static修饰方法****：静态方法。不依赖于对象就可以访问，可以直接类名.静态方法访问。静态方法不可以访问对象的非静态方法和非静态变量。</p>
<p>​    ****static变量****：静态变量被所有的对象所共享，在内存中只有一个副本，存在方法区中，当且仅当在类初次加载时会被初始化。</p>
<p>​    ****static静态代码块****：在类被初次加载时执行，且执行一次，通常将只需要进行一次的初始化操作都放在static代码块中进行。</p>
<p>​    <em><strong>*static静态内部类*</strong></em>:内部类：定义在类内部的类叫做内部类，内部类持有外部类的引用，所以能够访问外部类的所有变量和方法，内部类一般只为外部类使用，且内部类能够独立的继承接口。外部类对象通过‘外部类名.this.xxx’的形式访问内部类的属性与方法。static修饰之后就叫做静态内部类，或嵌套类 [1]要创建静态内部类的对象，并不需要其外部类的对象；也没有持有外部类的引用。 [2]不能够从静态内部类的对象中访问外部类的非静态成员。</p>
<p>​    每个类会产生一个.class文件，文件名即为类名。同样，内部类也会产生这么一个.class文件。内部类也会有class文件，文件名为外部类$内部类名称。</p>
<p>​    ****static静态导包***<em>：import static myClass.</em>;导入类的所有静态    方法或者调用特定静态方法。使用时直接使用方法名称就可以。</p>
<p>​    <em><strong>*final:*</strong></em></p>
<p>​    final修饰变量表示常量，只能被赋值一次，赋值后值不再改变.这里的不可变，是指引用不可变，如果修饰list,随便增删。如果修饰的类的成员变量，必须显示初始化，要么直接赋值，要么构造方法中初始化。否则就会报编译错误</p>
<p>​    final修饰方法，表示方法不可被重写。final方法编译的时候静态绑定，所以比非final方法快。private方法其实也是final的。final方法在编译阶段绑定，称为静态绑定(static binding)。</p>
<p>​    final修饰类，表示不可被继承。final类中的所有方法都是final方法。</p>
<p>​    不用final还可以用什么办法使得这个类不被继承、</p>
<p>​    将我们的类的构造器声明为private类型的。然后继承的子类，必须得调用父类的构造方法， 因为他是私有的构造函数，不能调用，出错。</p>
<h2 id="9-7、Java基础面试题"><a href="#9-7、Java基础面试题" class="headerlink" title="9.7、Java基础面试题"></a>9.7、Java基础面试题</h2><h3 id="9-7-1、-和equals的区别"><a href="#9-7-1、-和equals的区别" class="headerlink" title="9.7.1、==和equals的区别"></a>9.7.1、==和equals的区别</h3><ul>
<li>==是运算符，⽤于基本类型的数据的⽐较，或者是⽐较两个对象的引⽤是否相同；</li>
<li>⽽equals是Object的基本⽅法，⽤于⽐较两个对象的值是否相等，例如字符串的⽐较。</li>
</ul>
<h3 id="9-7-2、hashCode⽅法的作⽤"><a href="#9-7-2、hashCode⽅法的作⽤" class="headerlink" title="9.7.2、hashCode⽅法的作⽤"></a>9.7.2、hashCode⽅法的作⽤</h3><ul>
<li><p>hashCode是在散列存储结构中确定对象的存储地址的，主要是⽤于查找的快捷性，为了配合基于散列的集合正常运⾏，如Hashtable，HashMap等； </p>
</li>
<li><p>如果两个对象相同，就是适⽤于equals(java.lang.Object) ⽅法，那么这两个对象的hashCode⼀定要相同，即equals⽅法被重写，那么对象的hashCode也需要重写；</p>
</li>
<li><p>两个对象的hashCode相同，并不⼀定表示两个对象就相同，也就是不⼀定适⽤于equals(java.lang.Object) ⽅法，只能够说</p>
<p>明这两个对象在散列存储结构中，它们存放在<strong>同⼀个桶</strong>⾥⾯。</p>
</li>
</ul>
<h3 id="9-7-3、NIO是什么？适⽤于何种场景？"><a href="#9-7-3、NIO是什么？适⽤于何种场景？" class="headerlink" title="9.7.3、NIO是什么？适⽤于何种场景？"></a>9.7.3、NIO是什么？适⽤于何种场景？</h3><ul>
<li><p>NIO是为了弥补IO操作的不⾜⽽诞⽣的，NIO的⼀些新特性有：⾮阻塞I/O，选择器，缓冲以及管道。</p>
</li>
<li><p>如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候⽤NIO处理数据可</p>
<p>能是个很好的选择。(适⽤于<strong>⼩数据多连接</strong>)</p>
</li>
<li><p>⽽如果只有少量的连接，⽽这些连接每次要发送⼤量的数据，这时候传统的IO更合适。使⽤哪种处理数据，需要在数据的响</p>
<p>应等待时间和检查缓冲区数据的时间上作⽐较来权衡选择。</p>
</li>
<li><p>​    常见IO模型</p>
<ul>
<li><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210528145003817.png" alt="image-20210528145003817"></li>
</ul>
</li>
<li><p>Java IO分类</p>
<ul>
<li><p>BIO（Blocking IO）</p>
<ul>
<li><p>通信模型</p>
<ul>
<li><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210528145335341.png" alt="image-20210528145335341"></li>
</ul>
</li>
<li><p>采用 <strong>BIO 通信模型</strong> 的服务队，通常由一个独立的 <code>Acceptor</code> 线程负责监听客户端的连接。我们一般通过在 <code>while(true)</code> 循环中服务端会调用 <code>accept()</code> 方法等待客户端连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待当前连接的客户端的操作执行完成，不过可以通过多线程来支持多个客户端的连接</p>
</li>
<li><p>代码实例</p>
<ul>
<li><p>服务端</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niuh<span class="token punctuation">.</span>bio<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ServerSocket<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SocketServer</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        ServerSocket serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">9000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待连接。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//阻塞方法</span>
            <span class="token keyword">final</span> Socket socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有客户端连接了。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 多线程处理</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        <span class="token function">handler</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 单线程处理</span>
            <span class="token comment" spellcheck="true">//handler(socket);</span>

        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handler</span><span class="token punctuation">(</span>Socket socket<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread id = "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"准备read。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//接收客户端的数据，阻塞方法，没有数据可读时就阻塞</span>
        <span class="token keyword">int</span> read <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"read完毕。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>read <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到客户端的数据："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> read<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread id = "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"HelloClient"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>客户端</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niuh<span class="token punctuation">.</span>bio<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>Socket<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SocketClient</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        Socket socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">9000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//向服务端发送数据</span>
        socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"HelloServer"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"向服务端发送数据结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//接收服务端回传的数据</span>
        socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到服务端的数据："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>NIO</p>
<ul>
<li><p>由⼀个专⻔的线程来处理所有的 IO 事件，并负责分发</p>
</li>
<li><p>事件驱动机制：事件到的时候触发，⽽不是同步的去监视事件。</p>
</li>
<li><p>线程通讯：线程之间通过 wait,notify 等⽅式通讯。保证每次上下⽂切换都是有意义的。减少⽆谓的线程切换。</p>
</li>
<li><p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210528151822391.png" alt="image-20210528151822391"></p>
</li>
<li><p>三大核心组件</p>
<ul>
<li><strong>Channel</strong>（<strong>通道</strong>）</li>
<li><strong>Buffer</strong>（<strong>缓冲区</strong>）</li>
<li><strong>Selector</strong>（<strong>选择器</strong>）</li>
</ul>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210528145856316.png" alt="image-20210528145856316"></p>
<ul>
<li><p>channel 类似于流，每个 channel 对应一个 buffer 缓冲区，buffer 底层就是个数组；</p>
</li>
<li><p>channel 会注册到 selector 上，由 selector 根据 channel 读写事件的发生将其交由某个空闲的线程处理；</p>
</li>
<li><p>selector 可以对应一个或多个线程</p>
</li>
<li><p>NIO 的 Buffer 和 channel 既可以读也可以写</p>
</li>
</ul>
</li>
<li><p>与IO的区别</p>
<ul>
<li>IO流是阻塞的，NIO流不是阻塞的</li>
<li>IO 面向流（Stream oriented），NIO 面向缓冲区（Buffer oriented）</li>
<li>NIO 通过 Channel（通道）进行读写<ul>
<li><strong>通道是双向的，可读也可以写</strong>，而流的读写是单向的。无论读写，<strong>通道只能和 Buffer 交互</strong>。因为 Buffer，通道可以异步地读写。</li>
<li>NIO读写数据<ul>
<li>从通道读数据：创建一个缓冲区，然后请求通道读取数据；</li>
<li>从通道写数据：创建一个缓冲区，填充数据，并要求通道写入数据。</li>
</ul>
</li>
</ul>
</li>
<li>NIO 有选择器，而 IO 没有<ul>
<li><strong>选择器用于使用单线程处理多个通道</strong>。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。因此，为了提供系统效率选择器是有用的。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码实例</p>
<ul>
<li><p>服务端</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niuh<span class="token punctuation">.</span>nio<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetSocketAddress<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>ByteBuffer<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>SelectionKey<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>Selector<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>ServerSocketChannel<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>SocketChannel<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NIOServer</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//public static ExecutorService pool = Executors.newFixedThreadPool(10);</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 创建一个在本地端口进行监听的服务Socket通道.并设置为非阻塞方式</span>
        ServerSocketChannel ssc <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//必须配置为非阻塞才能往selector上注册，否则会报错，selector模式本身就是非阻塞模式</span>
        ssc<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ssc<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">9000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 创建一个选择器selector</span>
        Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span>
        ssc<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待事件发生。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 轮询监听channel里的key，select是阻塞的，accept()也是阻塞的</span>
            <span class="token keyword">int</span> select <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有事件发生了。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 有客户端请求，被轮询监听到</span>
            Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> it <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                SelectionKey key <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//删除本次已处理的key，防止下次select重复处理</span>
                it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">handle</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>SelectionKey key<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有客户端连接事件发生了。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ServerSocketChannel ssc <span class="token operator">=</span> <span class="token punctuation">(</span>ServerSocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//NIO非阻塞体现：此处accept方法是阻塞的，但是这里因为是发生了连接事件，所以这个方法会马上执行完，不会阻塞</span>
            <span class="token comment" spellcheck="true">//处理完连接请求不会继续等待客户端的数据发送</span>
            SocketChannel sc <span class="token operator">=</span> ssc<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sc<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//通过Selector监听Channel时对读事件感兴趣</span>
            sc<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">selector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有客户端数据可读事件发生了。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            SocketChannel sc <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//NIO非阻塞体现:首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定是发生了客户端发送数据的事件</span>
            <span class="token keyword">int</span> len <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取到客户端发送的数据："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            ByteBuffer bufferToWrite <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">"HelloClient"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bufferToWrite<span class="token punctuation">)</span><span class="token punctuation">;</span>
            key<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span>SelectionKey<span class="token punctuation">.</span>OP_READ <span class="token operator">|</span> SelectionKey<span class="token punctuation">.</span>OP_WRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            SocketChannel sc <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"write事件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// NIO事件触发是水平触发</span>
            <span class="token comment" spellcheck="true">// 使用Java的NIO编程的时候，在没有数据可以往外写的时候要取消写事件，</span>
            <span class="token comment" spellcheck="true">// 在有数据往外写的时候再注册写事件</span>
            key<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span>SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//sc.close();</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>客户端</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niuh<span class="token punctuation">.</span>nio<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetSocketAddress<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>ByteBuffer<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>SelectionKey<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>Selector<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>SocketChannel<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Iterator<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NioClient</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//通道管理器</span>
    <span class="token keyword">private</span> Selector selector<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 启动客户端测试
     *
     * @throws IOException
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        NioClient client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        client<span class="token punctuation">.</span><span class="token function">initClient</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">9000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        client<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 获得一个Socket通道，并对该通道做一些初始化的工作
     *
     * @param ip   连接的服务器的ip
     * @param port 连接的服务器的端口号
     * @throws IOException
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initClient</span><span class="token punctuation">(</span>String ip<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 获得一个Socket通道</span>
        SocketChannel channel <span class="token operator">=</span> SocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 设置通道为非阻塞</span>
        channel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 获得一个通道管理器</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 客户端连接服务器,其实方法执行并没有实现连接，需要在listen（）方法中调</span>
        <span class="token comment" spellcheck="true">//用channel.finishConnect() 才能完成连接</span>
        channel<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_CONNECT事件。</span>
        channel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_CONNECT<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理
     *
     * @throws IOException
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 轮询访问selector</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 获得selector中选中的项的迭代器</span>
            Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> it <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                SelectionKey key <span class="token operator">=</span> <span class="token punctuation">(</span>SelectionKey<span class="token punctuation">)</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 删除已选的key,以防重复处理</span>
                it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 连接事件发生</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isConnectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    SocketChannel channel <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// 如果正在连接，则完成连接</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">isConnectionPending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        channel<span class="token punctuation">.</span><span class="token function">finishConnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// 设置成非阻塞</span>
                    channel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">//在这里可以给服务端发送信息哦</span>
                    ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">"HelloServer"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    channel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">//在和服务端连接成功之后，为了可以接收到服务端的信息，需要给通道设置读的权限。</span>
                    channel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            <span class="token comment" spellcheck="true">// 获得了可读的事件</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token function">read</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 处理读取服务端发来的信息 的事件
     *
     * @param key
     * @throws IOException
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span>SelectionKey key<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//和服务端的read方法一样</span>
        <span class="token comment" spellcheck="true">// 服务器可读取消息:得到事件发生的Socket通道</span>
        SocketChannel channel <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 创建读取的缓冲区</span>
        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端收到信息："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>Redis 就是典型的 NIO 线程模型，selector 收集所有的事件并且转给后端线程，线程连续执行所有事件命令并将结果写回客户端。</p>
</li>
</ul>
</li>
<li><p>AIO</p>
<ul>
<li><p>异步非阻塞， 由操作系统完成后回调通知服务端程序启动线程去处理， 一般适用于连接数较多且连接时间较长（重操作）的应用。</p>
</li>
<li><p>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作</p>
</li>
<li><p>代码实例</p>
<ul>
<li><p>服务端</p>
<ul>
<li><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niuh<span class="token punctuation">.</span>aio<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetSocketAddress<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>ByteBuffer<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>AsynchronousServerSocketChannel<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>AsynchronousSocketChannel<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>CompletionHandler<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AIOServer</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> AsynchronousServerSocketChannel serverChannel <span class="token operator">=</span>
                AsynchronousServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">9000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        serverChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CompletionHandler</span><span class="token operator">&lt;</span>AsynchronousSocketChannel<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span><span class="token keyword">final</span> AsynchronousSocketChannel socketChannel<span class="token punctuation">,</span> Object attachment<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// 再此接收客户端连接，如果不写这行代码后面的客户端连接连不上服务端</span>
                    serverChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>attachment<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>socketChannel<span class="token punctuation">.</span><span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CompletionHandler</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> ByteBuffer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                        <span class="token annotation punctuation">@Override</span>
                        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span>Integer result<span class="token punctuation">,</span> ByteBuffer buffer<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                            buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            socketChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>ByteBuffer<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">"HelloClient"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

                        <span class="token annotation punctuation">@Override</span>
                        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span>Throwable exc<span class="token punctuation">,</span> ByteBuffer buffer<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                            exc<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">failed</span><span class="token punctuation">(</span>Throwable exc<span class="token punctuation">,</span> Object attachment<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                exc<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>客户端</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>niuh<span class="token punctuation">.</span>aio<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetSocketAddress<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>ByteBuffer<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>AsynchronousSocketChannel<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AIOClient</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        AsynchronousSocketChannel socketChannel <span class="token operator">=</span> AsynchronousSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        socketChannel<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">9000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        socketChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>ByteBuffer<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">"HelloServer"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Integer len <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端收到信息："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对比</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210528151504732.png" alt="image-20210528151504732"></p>
</li>
</ul>
<blockquote>
<p>AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的）</p>
</blockquote>
<h3 id="9-7-4、Hashmap实现原理？如何保证HashMap线程安全？"><a href="#9-7-4、Hashmap实现原理？如何保证HashMap线程安全？" class="headerlink" title="9.7.4、Hashmap实现原理？如何保证HashMap线程安全？"></a>9.7.4、Hashmap实现原理？如何保证HashMap线程安全？</h3><ul>
<li><p>HashMap简单说就是它根据键的hashCode值存储数据，⼤多数情况下可以直接定位到它的值，因⽽具有很快的访问速度，</p>
<p>但遍历顺序却是不确定的。</p>
</li>
<li><p> HashMap基于哈希表，底层结构由数组来实现，存储时根据key的hash算法来决定其存储位置并以Entry形式保存到数组中</p>
</li>
<li><p>数组扩容需要重新计算扩容后每个元素在数组中的位置很耗性能，因此一般建议在初始化时指定初始容量；</p>
</li>
<li><p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210528152232130.png" alt="image-20210528152232130"></p>
</li>
<li><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">transient</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
     <span class="token keyword">final</span> K key<span class="token punctuation">;</span> 
     V value<span class="token punctuation">;</span> 
     Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
     ……
 <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>put方法</p>
<ul>
<li><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210528152455299.png" alt="image-20210528152455299"></li>
</ul>
</li>
<li><p> ConcurrentHashMap是HashMap的线程安全实现</p>
</li>
<li><p>允许多个修改操作同时进⾏(使⽤了锁分离技术)，它使⽤了多个锁来控制，对hash表的不同段进⾏的修改，每个段其实就是⼀个⼩的hashtable，它们有⾃⼰的锁。</p>
</li>
<li><p>允许多个读操作并发进⾏，读操作并不需要锁，因为它的HashEntry⼏乎是不可变的</p>
</li>
</ul>
<h3 id="9-7-5、NIO模型，select-epoll的区别，多路复⽤的原理？"><a href="#9-7-5、NIO模型，select-epoll的区别，多路复⽤的原理？" class="headerlink" title="9.7.5、NIO模型，select/epoll的区别，多路复⽤的原理？"></a>9.7.5、NIO模型，select/epoll的区别，多路复⽤的原理？</h3><ul>
<li><p>IO多路复⽤</p>
<ul>
<li>概念：IO多路复⽤是指内核⼀旦发现进程指定的⼀个或者多个IO条件准备读取，它就通知该进程。</li>
<li>优势：与多进程和多线程技术相⽐，I/O多路复⽤技术的最⼤优势是<strong>系统开销⼩</strong>，系统不必创建新进程/线程，也不必维护这些进程/线程，从⽽⼤⼤减⼩了系统的开销。</li>
<li>系统：⽬前⽀持I/O多路复⽤的系统调⽤有 select，pselect，poll，epoll。</li>
</ul>
</li>
<li><p>select： 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<ul>
<li><p>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描</p>
<p>述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的</p>
<p>描述符集合。</p>
</li>
<li><p>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过timeout。</p>
</li>
<li><p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">fd_set fd_in<span class="token punctuation">,</span> fd_out<span class="token punctuation">;</span> 
<span class="token keyword">struct</span> timeval tv<span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// Reset the sets </span>
<span class="token function">FD_ZERO</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>fd_in <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">FD_ZERO</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>fd_out <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// Monitor sock1 for input events </span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span> sock1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_in <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// Monitor sock2 for output events </span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span> sock2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_out <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// Find out which socket has the largest numeric value as select requires it </span>
<span class="token keyword">int</span> largest_sock <span class="token operator">=</span> sock1 <span class="token operator">></span> sock2 <span class="token operator">?</span> sock1 <span class="token operator">:</span> sock2<span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// Wait up to 10 seconds </span>
tv<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> 
tv<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Call the select </span>
<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span> largest_sock <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_in<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_out<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tv <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// Check if select actually succeed </span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// report error and abort </span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// timeout; no event detected </span>
<span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span> sock1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_in <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// input event on sock1 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span> sock2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fd_out <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// output event on sock2 </span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>poll：功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> pollfd <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* file descriptor */</span> 
    <span class="token keyword">short</span> events<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* requested events */</span> 
    <span class="token keyword">short</span> revents<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* returned events */</span> 
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// The structure for two events</span>
<span class="token keyword">struct</span> pollfd fds<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Monitor sock1 for input </span>
fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> sock1<span class="token punctuation">;</span> 
fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLIN<span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// Monitor sock2 for output</span>
fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> sock2<span class="token punctuation">;</span> 
fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLOUT<span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// Wait 10 seconds</span>
<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>fds<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Check if poll actually succeed </span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// report error and abort</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// timeout; no event detected </span>
<span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">// If we detect the event, zero it out so we can reuse the structure </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLIN <span class="token punctuation">)</span> 
        fds<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
        <span class="token comment" spellcheck="true">// input event on sock1 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLOUT <span class="token punctuation">)</span> 
        fds<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
            <span class="token comment" spellcheck="true">// output event on sock2 </span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>select和poll比较</p>
<ul>
<li><p>select 会修改描述符，而 poll 不会；</p>
</li>
<li><p>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024个描述符。如果要监听更多描述符的话，需要修改FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</p>
</li>
<li><p>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高；</p>
</li>
<li><p>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</p>
</li>
</ul>
</li>
<li><p>epoll</p>
<ul>
<li><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用epoll_wait() 便可以得到事件完成的描述符。</p>
</li>
<li><p>epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符、</p>
</li>
<li><p>仅适用于Linux</p>
</li>
<li><p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>
</li>
<li><p>epoll对多线程编程友好，一个线程调用了epoll_wait，另一个线程关闭了同一个描述符也不会产生像select和poll那样不确定的情况</p>
</li>
<li><p>工作模式</p>
<ul>
<li><p>LT（level trigger）：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用</p>
<p>epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
</li>
<li><p>ET（edge trigger）：通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>
<ul>
<li>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。</li>
<li>只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++"><code class="language-c++">int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； 
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>应用场景比较<ul>
<li>select：适用于实时性要求比较高的场景，比如核反应堆的控制；可移植性比较好，几乎被所有主流平台所支持</li>
<li>poll：没有最大描述符数量限制，如果平台支持且对实时性要求不高，建议用poll而非select</li>
<li>epoll：运行在Linux平台，且有大量描述符需要同时轮询，并且这些连接最好是长连接时</li>
</ul>
</li>
</ul>
<h3 id="9-7-6、-java中⼀个字符占多少个字节？int，long，double占多少个字节？"><a href="#9-7-6、-java中⼀个字符占多少个字节？int，long，double占多少个字节？" class="headerlink" title="9.7.6、 java中⼀个字符占多少个字节？int，long，double占多少个字节？"></a>9.7.6、 java中⼀个字符占多少个字节？int，long，double占多少个字节？</h3><ul>
<li>1字节： byte , boolean</li>
<li>2字节： short , char</li>
<li>4字节： int , float</li>
<li>8字节： long , double</li>
</ul>
<h3 id="9-7-7、创建⼀个类的实例都有哪些⽅法？"><a href="#9-7-7、创建⼀个类的实例都有哪些⽅法？" class="headerlink" title="9.7.7、创建⼀个类的实例都有哪些⽅法？"></a>9.7.7、创建⼀个类的实例都有哪些⽅法？</h3><pre class="line-numbers language-java"><code class="language-java">Object o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
Object o <span class="token operator">=</span> oo<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object o <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="9-7-8、final-finaly-finalize区别？"><a href="#9-7-8、final-finaly-finalize区别？" class="headerlink" title="9.7.8、final/finaly/finalize区别？"></a>9.7.8、final/finaly/finalize区别？</h3><ul>
<li><p>final是定义类、⽅法、字段的修饰符，表示<strong>类不可被继承，⽅法不能被重写，字段值不能被修改</strong></p>
</li>
<li><p>finally是异常处理机制的关键字，表示最后一定会执⾏的操作</p>
</li>
<li><p>finalize是Object的⼀个⽅法，在对象被虚拟机回收时会判断是否执⾏该⽅法，当对象没有覆盖finalize⽅法，或者finalize⽅法已经被虚拟机调⽤过，虚拟机<strong>将这两种情况都视为“没有必要执⾏”</strong></p>
</li>
</ul>
<h3 id="9-7-9、String-StringBuffer-StringBuilder的区别以及实现？"><a href="#9-7-9、String-StringBuffer-StringBuilder的区别以及实现？" class="headerlink" title="9.7.9、String/StringBuffer/StringBuilder的区别以及实现？"></a>9.7.9、String/StringBuffer/StringBuilder的区别以及实现？</h3><p>重排序情况：编译器优化的重排序、指令并行重排序，内存系统重排序。</p>
<p>​    在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</p>
<p>​    1. <em><strong>*如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。*</strong></em></p>
<p>​    2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。<em><strong>*如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。*</strong></em></p>
<p>​    规则八种：程序次序规则（****在一个线程内一段代码的执行结果是有序的****。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！）、锁定规则、volatile变量规则、传递规则、线程启动规则、线程中断规则、线程终结规则、对象终结规则。</p>
<p>ArrayList 和 LinkedList 区别？三种方式访问集合中的元素，ArrayList遍历删除会出的问题？Foreach原理以及Fail-fast机制！</p>
<p>为什么会出现 4.0-3.6=0.40000001 这种现象？</p>
<p>为什么HashMap长度大于8才转换为红黑树，而不是6？</p>
<p>HashMap和TreeMap比较？</p>
<p>任务缓存队列及排队策略，如何自定义拒绝策略？</p>
<p>配置线程池大小，根据CPU密集和IO密集划分</p>
<p>阻塞队列以及生产者消费者的实现</p>
<p>设计模式的单例和工厂是面得最多的</p>
<p>为什么需要破坏双亲委派？自己写个String能加载吗？类初始化时机？</p>
<p>JVM调优</p>
<p>Redis 的缺点？</p>
<p>Redis的并发竞争问题如何解决？</p>
<p>集群是如何判断是否有某个节点挂掉？集群进入fail状态的必要条件？</p>
<p>减库存然后下订单，但是服务器宕机？</p>
<p>负载均衡实现方式，策略？</p>
<p>单拎出来的缓存问题，结合状态码 304 可能问到，相关头字段，<em><strong>*If-Modified-Since 和 Last-Modified，If-None-Match 和 ETag，它们的区别等；*</strong></em></p>
<p>有序性的先行发生原则（happens-before）。</p>
<p>虚引用有哪些应用场景</p>
<p>介绍下JDBC的过程</p>
<p>JDBC的Statement对象有哪几类</p>
<h2 id="9-8、多态的实现原理"><a href="#9-8、多态的实现原理" class="headerlink" title="9.8、多态的实现原理"></a>9.8、多态的实现原理</h2><p>​    多态是指一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>​    Java多态允许父类引用变量指向子类对象，引用变量发出的方法调用到底是哪个对象实现的方法，必须在由程序运行期间才能决定。java中的方法调用有静态绑定和动态绑定之分，静态绑定指的是我们在编译期就已经确定了会执行那个方法的字节码，而动态绑定只有在运行时才能知晓。Java中的静态方法、私有方法以及final修饰的方法的调用，都属于静态绑定，对于重载的实例方法的调用，也是采用静态绑定。方法调用动作会被编译成静态调用指令，该指令对应常量池中方法的符号引用。</p>
<p>​    Java 对于方法调用动态绑定的实现主要依赖于****方法表*<em><strong>，但通过</strong></em>*类引用调用和接口引用调用*<em><strong>的实现则有所不同。总体而言，当某个方法被调用时，JVM 首先要查找相应的</strong></em>*常量池*<em><strong>，得到</strong></em>*方法的符号引用*<em><strong>，并查找调用类的方法表以确定该</strong></em>*方法的直接引用****，最后才真正调用该方法。以下分别对该过程中涉及到的相关部分做详细介绍。</p>
<p>​    动态绑定：JVM有个方法表：记录当前类以及所有父类的可见方法字节码在内存中的直接地址。</p>
<h2 id="9-9、异常体系"><a href="#9-9、异常体系" class="headerlink" title="9.9、异常体系"></a>9.9、异常体系</h2><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210528111300708.png" alt="image-20210528111300708"></p>
<p>​    Java语言设计者将异常划分为两类：<strong>Error和Exception</strong></p>
<ul>
<li><p>Error（错误）：是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时<strong>JVM出现问题</strong>。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）<strong>StackOverflowError，OutOfMemoryError</strong>等。</p>
</li>
<li><p>Exception（异常）：程序本身可以捕获并且可以处理的异常</p>
<ul>
<li>​    运行时异常(<strong>免检异常</strong>)：RuntimeException类极其子类表示JVM在运行期间可能出现的错误。比如空指针异常<strong>NullPointerException</strong>、数组下标越界（<strong>ArrayIndexOutBoundException</strong>）。此类异常属于不可查异常，一般是由<strong>ClassCastException</strong>、<strong>llegalArgumentException</strong>。</li>
<li>​    编译异常(<strong>受检异常</strong>)：Exception中除RuntimeException极其子类之外的异常。如果程序中出现此类异常，比如说<strong>IOException，必须对该异常进行处理，否则编译不通过。</strong>在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。<strong>ClassNotFoundException</strong>，<strong>InterruptedException</strong>、SQLException。</li>
</ul>
</li>
</ul>
<h2 id="9-10、排序：快速，归并，堆排序"><a href="#9-10、排序：快速，归并，堆排序" class="headerlink" title="9.10、排序：快速，归并，堆排序"></a>9.10、排序：快速，归并，堆排序</h2><p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps5.jpg" alt="img"> </p>
<p>  //快速排序,快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。</p>
<p>  // 快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。</p>
<p>  // 先从序列中取出一个数作为基准数；先选择数组的最左边;</p>
<p>  //分区过程：将把这个数大的数全部放到它的右边，小于或者等于它的数全放到它的左边；</p>
<p>  //递归地对左右子序列进行不走2，直到各区间只有一个数</p>
<p>  private  static void quickStart(int[] arr,int left, int right){</p>
<p>​    if(arr == null || left &gt;= right || arr.length &lt; 1)</p>
<p>​    return;</p>
<p>​    int mid = partition(arr,left,right);</p>
<p>​    quickStart(arr,left,mid-1);</p>
<p>​    quickStart(arr,mid+1,right);</p>
<p>  }</p>
<p>  private static int partition(int[] arr, int left, int right){</p>
<p>​    int pivotKey = arr[left];</p>
<p>​    while(left &lt; right) {</p>
<p>​      while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)</p>
<p>​        right –;</p>
<p>​      arr[left] = arr[right]; //把小的移动到左边</p>
<p>​      while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)</p>
<p>​        left ++;</p>
<p>​      arr[right] = arr[left]; //把大的移动到右边</p>
<p>​    }</p>
<p>​    arr[left] = pivotKey; //最后把pivot赋值到中间</p>
<p>​    return left;</p>
<p>  }</p>
<p>  private static void swap1(int[] arr, int left, int rihgt){</p>
<p>​    int temp = arr[left];</p>
<p>​    arr[left] = arr[rihgt];</p>
<p>​    arr[rihgt] = temp;</p>
<p>  }</p>
<p>  //归并排序：</p>
<p>  //二路归并排序，让数组分成2组，然后递归多分几组，知道每组只有一个，然后对每2有序小组进行排序合并。</p>
<p>  //归时，要创建新数组，暂存结果</p>
<p>  public static int[] sortMerge(int[] array,int left,int right){</p>
<p>​    int mid = left + (right-left)/2;</p>
<p>​    if (left &lt; right){</p>
<p>​      sortMerge(array,left,mid);</p>
<p>​      sortMerge(array,mid+1,right);</p>
<p>​      merge(array,left,mid,right);</p>
<p>​    }</p>
<p>​    return array;</p>
<p>  }</p>
<p>  //将有序的left-mid和mid+1 — right这两个有序数组排序;</p>
<p>  public static void merge(int[] array,int left,int mid,int right){</p>
<p>​    //String s = “sdd”;</p>
<p>​    //s.indexOf()</p>
<p>​    int[] temp = new int[right-left+1];</p>
<p>​    int i = left;</p>
<p>​    int j = mid +1;</p>
<p>​    int k = 0;</p>
<p>​      while (i&lt;=mid &amp;&amp; j &lt;= right){</p>
<p>​        if (array[i] &lt; array[j])</p>
<p>​          temp[k++] = array[i++];</p>
<p>​        else</p>
<p>​          temp[k++] = array[j++];</p>
<p>​    }</p>
<p>​    while (i &lt;= mid)</p>
<p>​      temp[k++] = array[i++];</p>
<p>​    while (j&lt;=right)</p>
<p>​      temp[k++] = array[j++];</p>
<p>​    for(int x=0;x&lt;temp.length;x++){</p>
<p>​      array[x+left] = temp[x];</p>
<p>​    }</p>
<p>  }</p>
<h2 id="9-11、序列化和反序列化"><a href="#9-11、序列化和反序列化" class="headerlink" title="9.11、序列化和反序列化"></a>9.11、序列化和反序列化</h2><p>​    java序列化是指把java对象转换为字节序列的过程，而java反序列化是指把字节序列恢复为java对象的过程。</p>
<p>​    序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
<p>​    （利用序列化实现远程通信，可以在网络上传送对象的字节序列。在进程间传递对象，永久性保存对象）</p>
<p>—-JDK类库中序列化的步骤 ：只有实现了Serializable或Externalizable接口的对象才能被序列化，否则抛出异常！</p>
<p>如果类a仅仅实现了Serializable接口，则</p>
<p>ObjectOutputStream采用默认的序列化方式，对a对象的非transient实例变量进行序列化</p>
<p>ObjectInputStream采用默认的反序列化方式，对a对象的非transient实例变量进行反序列化</p>
<p>反序列化失败: 没有添加 serialVersionUID 可能会导致反序列化失败.</p>
<p>继承了一个已经实现序列化接口的父类,并且与父类有重复的属性,在反序列化的时候就会导致重复的属性数据丢失.</p>
<p>–1–创建一个对象输出流，它可以包装一个奇特类型的目标输出流，如文件输出流：</p>
<p>objectOutputStream oos=new objectOutputStream(new FileOutStream(c:\object.out));</p>
<p>–2–通过对象输出流writeObject()方法写对象：</p>
<p>oos.writeObject(new a(“xiaoxiao”,”145263”,”female”));</p>
<p>—-JDK类库中反序列化的步骤</p>
<p>–1–创建一个对象输入流，它可以包装一个其他类型输入流，如文件输入流：</p>
<p>objectInputStream ois=new ObjectInputStream(new FileInputStream(“object.out”));</p>
<p>–2–通过对象输出流的readObject()方法读取对象：</p>
<p>a aa=(a)ois.readObject();</p>
<p>–3–为了正确读数据，完成反序列化，必须保证向对象输出流写对象的顺序与从对象输入流中读对象的顺序一致</p>
<h2 id="9-12、int和Integer有什么区别"><a href="#9-12、int和Integer有什么区别" class="headerlink" title="9.12、int和Integer有什么区别"></a>9.12、int和Integer有什么区别</h2><p>​    为了编程方法， Java有八大基本数据类型。又为了能将这些基本数据类型当做对象处理，又为每个基本数据类型引入了对应的包装类型。JDK1.5之后，引入自动拆箱机制，基本数据类型和包装类可以互换。</p>
<p>​    Integer是int的包装类，必须实例化为才能使用，Integer变量实际是对象的引用，指向对象，默认值为null;</p>
<p>​    int是基本数据类型,不必实例化就能用，它直接存数据值，默认是0.</p>
<p>​    Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true。因为自动拆箱。</p>
<p>​    非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。</p>
<p>​    对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false。</p>
<p>​    <em><strong>*Integer缓存池大小：-128 —-127*</strong></em></p>
<h2 id="9-13、Java语言有哪些特点"><a href="#9-13、Java语言有哪些特点" class="headerlink" title="9.13、Java语言有哪些特点"></a>9.13、Java语言有哪些特点</h2><p>1、简单易学、有丰富的类库</p>
<p>2、面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）</p>
<p>3、与平台无关性（JVM是Java跨平台使用的根本）</p>
<p>4、可靠安全</p>
<p>5、支持多线程</p>
<h2 id="9-14、为什么Java是跨平台的、C语言却不是？"><a href="#9-14、为什么Java是跨平台的、C语言却不是？" class="headerlink" title="9.14、为什么Java是跨平台的、C语言却不是？"></a>9.14、为什么Java是跨平台的、C语言却不是？</h2><p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps6.png" alt="img"> </p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps7.png" alt="img"> </p>
<p>第一，C语言是编译执行的，编译器与平台相关，编译生成的可执行文件与平台相关；</p>
<p>第二，Java是解释执行的，编译为中间码的编译器与平台无关，编译生成的中间码也与平台无关（一次编译，到处运行），中间码再由解释器解释执行，解释器是与平台相关的，也就是不同的平台需要不同的解释器.</p>
<h2 id="9-15、Java和C语言的区别在哪里？"><a href="#9-15、Java和C语言的区别在哪里？" class="headerlink" title="9.15、Java和C语言的区别在哪里？"></a>9.15、Java和C语言的区别在哪里？</h2><p> C是面向过程的，执行效率高;Java是面向对象的语言，执行效率比C语言低。</p>
<p> C语言最关键的是比Java多了指针，这也说明了Java的健壮性，还有Java的多线程机制使程序可以并行运行，Java程序多用于网络。</p>
<p> C的安全性不如Java，C没有Java的垃圾回收机制，申请的空间要手动释放。</p>
<p> Java的通用性好，可以跨平台直接移植，有安装Java虚拟机(JVM)就可以了，但是速度没有c语言快。</p>
<p> C比Java更“底层”，因此可以用C编写例如硬件的驱动，而Java却不行。</p>
<p> 在C语言中，char类型占一个字节，在Java中char类型占2个字节。</p>
<p> Java中可以将类组织起来用Package打包，而C语言没有。Java有public、private、protected权限管理，C没有。</p>
<h2 id="9-16、面向对象和面向过程的区别"><a href="#9-16、面向对象和面向过程的区别" class="headerlink" title="9.16、面向对象和面向过程的区别"></a>9.16、面向对象和面向过程的区别</h2><p><strong>面向过程：</strong>是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p>
<p><strong>面向对象：</strong>是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低</p>
<h2 id="9-17、面向对象有啥好处？"><a href="#9-17、面向对象有啥好处？" class="headerlink" title="9.17、面向对象有啥好处？"></a>9.17、面向对象有啥好处？</h2><p><strong>可维护：</strong>采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的。</p>
<p><strong>可复用：</strong>代码复用，在设计时，可重用现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。</p>
<p><strong>可扩展：</strong>由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展</p>
<p><strong>灵活性好：</strong>数据和方法（方法可以理解为函数）被封装在一起，这样做改动的时候对整个程序的影响不大。</p>
<h2 id="9-18、JDK、JRE、JVM的区别"><a href="#9-18、JDK、JRE、JVM的区别" class="headerlink" title="9.18、JDK、JRE、JVM的区别"></a>9.18、JDK、JRE、JVM的区别</h2><p>JDK是 Java 语言的软件开发工具包(SDK)。在JDK的安装目录下有一个jre目录，jre是java运行时环境，有两个文件夹bin和lib，可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib合起来就称为jre。</p>
<p>利用JDK（调用JAVA API）开发了JAVA程序后，通过JDK中的编译程序（javac.exe）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。</p>
<h3 id="1、JDK：开发，运行-编译"><a href="#1、JDK：开发，运行-编译" class="headerlink" title="*1、JDK：开发，运行+编译*"></a><em><strong>*1、JDK：开发，运行+编译*</strong></em></h3><p>JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。</p>
<p>包含了几个重要的文件夹：</p>
<p>bin:最主要的是编译器(javac.exe)</p>
<p>   include:java和JVM交互用的头文件</p>
<p>   lib：类库</p>
<p>   jre:java运行环境</p>
<h3 id="2、JRE：运行，不能编译"><a href="#2、JRE：运行，不能编译" class="headerlink" title="*2、JRE：运行，不能编译*"></a><em><strong>*2、JRE：运行，不能编译*</strong></em></h3><p>JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器）</p>
<p>光有JVM还不能完成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。（jre里有运行.class的java.exe）</p>
<h3 id="3、JVM：解释字节码为机器指令"><a href="#3、JVM：解释字节码为机器指令" class="headerlink" title="*3、JVM：解释字节码为机器指令*"></a><em><strong>*3、JVM：解释字节码为机器指令*</strong></em></h3><p>Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p>
<h2 id="9-19、面向对象4大特性：抽象、封装、继承、多态"><a href="#9-19、面向对象4大特性：抽象、封装、继承、多态" class="headerlink" title="9.19、面向对象4大特性：抽象、封装、继承、多态"></a>9.19、面向对象4大特性：抽象、封装、继承、多态</h2><h3 id="1-、抽象："><a href="#1-、抽象：" class="headerlink" title="*1*****、抽象：****"></a><em><strong>*1*</strong>***</em>*、抽象：****</h3><p>抽象是将一类对象的共同特征总结出来构造类的过程,包括数据抽象和行为抽象两方面,抽象只关注对象的哪些属性和行为,并不关注这此行为的细节是什么</p>
<h3 id="2、封装："><a href="#2、封装：" class="headerlink" title="*2、封装：*"></a><em><strong>*2、封装：*</strong></em></h3><p>利用抽象数据类型将<strong>数据和基于数据的操作</strong>封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<p>· 减少耦合：可以独立地开发、测试、优化、使用、理解和修改</p>
<p>· 减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</p>
<p>· 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</p>
<p>· 提高软件的可重用性</p>
<p>· 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</p>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<p>public class Person {   private String name;  private int gender;  private int age;   public String getName() {    return name;  }   public String getGender() {    return gender == 0 ? “man” : “woman”;  }   public void work() {    if (18 &lt;= age &amp;&amp; age &lt;= 50) {      System.out.println(name + “ is working very hard!”);    } else {      System.out.println(name + “ can’t work any more!”);    }  }}</p>
<h3 id="3、继承："><a href="#3、继承：" class="headerlink" title="*3、继承：*"></a><em><strong>*3、继承：*</strong></em></h3><p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>3.1 原则：</p>
<p>、子类拥有父类非private的属性和方法。</p>
<p>、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
<p>、子类可以用自己的方式实现父类的方法。</p>
<p>3.2 向上转型：</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p>
<p>Animal animal = new Cat();</p>
<p>3.3继承的缺点：</p>
<p>、父类变，子类就必须变。</p>
<p>、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。</p>
<p>、继承是一种强耦合关系。</p>
<p>那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己<strong>是否需要从子类向父类进行向上转型</strong>。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。</p>
<p>3.4 构造器：</p>
<p>对于构造器而言，它只能够被调用，而不能被继承。父类有默认构造器的话，编译器会默认给子类调用父类的构造器，如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，而且必须是在子类构造器中的第一行代码中，否则编译器会报错：无法找到符合父类形式的构造器。</p>
<p>3.5 protected关键字：</p>
<p>对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。</p>
<h3 id="4、多态："><a href="#4、多态：" class="headerlink" title="*4、多态：*"></a><em><strong>*4、多态：*</strong></em></h3><p>4.1、定义：不同类的对象对同一消息作出不同的响应叫做多态</p>
<p>4.2、多态的分类：</p>
<p>编译时多态，方法的重载；</p>
<p>运行时多态，方法的重写。</p>
<p>4.3、运行时多态存在的三个条件：</p>
<p>有继承关系、子类重写了父类方法、父类引用指向子类对象（向上转型）</p>
<p>4.4、注意：</p>
<p>因为多态存在必须要有“子类重写父类方法”这个条件，那么下面三种类型的方法没办法表现出多态的特性(因为不能被重写)</p>
<p>static方法：static修饰的方法是属于类的，而不属于实例</p>
<p>final方法：因为被final修饰的方法无法被子类重写</p>
<p>private方法：被private修饰的发那个法对子类不可见，</p>
<p>protected方法：被protected修饰的方法可以被子类见到，也可以被重写，但无法被外部所引用，无法引用，就没有多态</p>
<p>4.5、分析多态问题的几条原则</p>
<p>比如有一个父类Father,有一个子类Children</p>
<p>（1）向上转型是自动的。Father f=new Children()是自动的，不需要强转</p>
<p>（2）向下转型要强转。即Children c=new Father()是无法编译通过的，必须要Children c=(Children)new Father(),让父类知道它要转成具体哪个子类</p>
<p>（3）父类引用指向子类对象，子类重写了父类的方法，调用父类的方法，实际调用的是子类重写了父类的该方法。即Father f=new Children()；f.toString()；实际上调用的是Children中的toString()方法</p>
<h2 id="9-20、C-和Java中的多态有什么区别"><a href="#9-20、C-和Java中的多态有什么区别" class="headerlink" title="9.20、C++和Java中的多态有什么区别"></a>9.20、C++和Java中的多态有什么区别</h2><p>1、在构造函数时Java会发生多态，即使子类此时还没有构造完全。而C++则不会发生多态，待父类构造完全，再构造子类。初始化的过程也不相同。java在还未初始化子类的时候，子类的同名函数就已经覆盖了父类的。</p>
<p>2、java中的类对象在构造前（调用构造函数之前）就已经存在了，其函数表和对象类型也已经确定了，没出生就确定。而C++中只有在构造完毕后（所有的构造函数都被成功调用）才存在，其函数表和对象的实际类型才会确定。</p>
<p>3、C++中，如果父类中的函数前边标有virtual，才显现出多态。Java中，不管写不写virtual都是多态的，子类的同名函数会override父类的。</p>
<h2 id="9-21、面向对象设计的类图"><a href="#9-21、面向对象设计的类图" class="headerlink" title="9.21、面向对象设计的类图"></a>9.21、面向对象设计的类图</h2><h3 id="1、泛化关系-Generalization"><a href="#1、泛化关系-Generalization" class="headerlink" title="*1、泛化关系 (Generalization)*"></a><em><strong>*1、泛化关系 (Generalization)*</strong></em></h3><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps8.jpg" alt="img"> </p>
<h3 id="2、实现关系-Realization"><a href="#2、实现关系-Realization" class="headerlink" title="*2、实现关系 (Realization)*"></a><em><strong>*2、实现关系 (Realization)*</strong></em></h3><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps9.jpg" alt="img"> </p>
<h3 id="3、聚合关系-Aggregation"><a href="#3、聚合关系-Aggregation" class="headerlink" title="*3、聚合关系 (Aggregation)*"></a><em><strong>*3、聚合关系 (Aggregation)*</strong></em></h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps10.jpg" alt="img"> </p>
<h3 id="4、组合关系-Composition"><a href="#4、组合关系-Composition" class="headerlink" title="*4、组合关系 (Composition)*"></a><em><strong>*4、组合关系 (Composition)*</strong></em></h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps11.jpg" alt="img"> </p>
<h3 id="5、关联关系-Association"><a href="#5、关联关系-Association" class="headerlink" title="*5、关联关系 (Association)*"></a><em><strong>*5、关联关系 (Association)*</strong></em></h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps12.jpg" alt="img"> </p>
<h3 id="6、依赖关系-Dependency"><a href="#6、依赖关系-Dependency" class="headerlink" title="*6、依赖关系 (Dependency)*"></a><em><strong>*6、依赖关系 (Dependency)*</strong></em></h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<p>A 类是 B 类方法的局部变量；</p>
<p>A 类是 B 类方法的参数；</p>
<p>A 类向 B 类发送消息，从而影响 B 类发生变化。</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps13.jpg" alt="img"> </p>
<h2 id="9-22、面向对象的设计原则"><a href="#9-22、面向对象的设计原则" class="headerlink" title="9.22、面向对象的设计原则"></a>9.22、面向对象的设计原则</h2><p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps14.jpg" alt="img"> </p>
<h3 id="1-单一责任原则"><a href="#1-单一责任原则" class="headerlink" title="*1. 单一责任原则*"></a><em><strong>*1. 单一责任原则*</strong></em></h3><p>修改一个类的原因应该只有一个。</p>
<p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p>
<h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="*2. 开放封闭原则*"></a><em><strong>*2. 开放封闭原则*</strong></em></h3><p>类应该对扩展开放，对修改关闭。</p>
<p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p>
<p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<h3 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="*3. 里氏替换原则*"></a><em><strong>*3. 里氏替换原则*</strong></em></h3><p>子类对象必须能够替换掉所有父类对象。</p>
<p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p>
<p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<h3 id="4-接口分离原则"><a href="#4-接口分离原则" class="headerlink" title="*4. 接口分离原则*"></a><em><strong>*4. 接口分离原则*</strong></em></h3><p>不应该强迫客户依赖于它们不用的方法。</p>
<p>因此使用多个专门的接口比使用单一的总接口要好。</p>
<h3 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="*5. 依赖倒置原则*"></a><em><strong>*5. 依赖倒置原则*</strong></em></h3><p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p>
<p>依赖于抽象意味着：</p>
<p>· 任何变量都不应该持有一个指向具体类的指针或者引用；</p>
<p>· 任何类都不应该从具体类派生；</p>
<p>· 任何方法都不应该覆写它的任何基类中的已经实现的方法。</p>
<h3 id="6、其它常见原则"><a href="#6、其它常见原则" class="headerlink" title="*6、其它常见原则*"></a><em><strong>*6、其它常见原则*</strong></em></h3><p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps15.jpg" alt="img"> </p>
<h2 id="9-23、基本数据类型"><a href="#9-23、基本数据类型" class="headerlink" title="9.23、基本数据类型"></a>9.23、基本数据类型</h2><p>32位系统：char是1字节，short是2字节，int、float、long 占4字节，double占8字节</p>
<p>64位：char是1字节，short是2字节，int、float占4字节，double、long占8字节</p>
<h2 id="9-24、final，finally，finalize关键字"><a href="#9-24、final，finally，finalize关键字" class="headerlink" title="9.24、final，finally，finalize关键字"></a>9.24、final，finally，finalize关键字</h2><p><strong>F****inal：</strong></p>
<p>1、final用于修饰类、成员变量和成员方法。</p>
<p>2、final修饰的类，不能被继承（String、StringBuilder、StringBuffer、Math，不可变类），其中所有的方法都不能被重写(这里需要注意的是<strong>不能被重写</strong>，但是<strong>可以被重载</strong>，这里很多人会弄混)，所以不能同时用abstract和final修饰类（abstract修饰的类是抽象类，抽象类是用于被子类继承的，和final起相反的作用）；</p>
<p>3、final修饰的方法不能被重写，但是子类可以用父类中final修饰的方法；</p>
<p>4、final修饰的成员变量是不可变的，如果成员变量是基本数据类型，初始化之后成员变量的值不能被改变，如果成员变量是引用类型，那么它只能指向初始化时指向的那个对象，不能再指向别的对象，但是对象当中的内容是允许改变的。</p>
<p>5、final关键字的好处：</p>
<p>final方法比非final快一些</p>
<p>final关键字提高了性能。JVM和Java应用都会缓存final变量。</p>
<p>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</p>
<p>使用final关键字，JVM会对方法、变量及类进行优化。</p>
<p><strong>Finally:</strong></p>
<p>通常和try catch搭配使用，保证不管有没有发生异常，资源都能够被释放（释放连接、关闭IO流）。当try中有return时执行顺序：return语句并不是函数的最终出口，如果有finally语句，这在return之后还会执行finally（return的值会暂存在栈里面，等待finally执行后再返回）</p>
<p><strong>Finalize：</strong></p>
<p>Finalize是object类中的一个方法，子类可以重写finalize()方法实现对资源的回收。垃圾回收只负责回收内存，并不负责资源的回收，资源回收要由程序员完成，Java虚拟机在垃圾回收之前会先调用垃圾对象的finalize方法用于使对象释放资源（如关闭连接、关闭文件），之后才进行垃圾回收，这个方法一般不会显示的调用，在垃圾回收时垃圾回收器会主动调用。</p>
<h2 id="9-25、System-out-print-中的三个参数分别是什么类型"><a href="#9-25、System-out-print-中的三个参数分别是什么类型" class="headerlink" title="9.25、System.out.print()中的三个参数分别是什么类型"></a>9.25、System.out.print()中的三个参数分别是什么类型</h2><h3 id="1、源码探究："><a href="#1、源码探究：" class="headerlink" title="*1、源码探究：*"></a><em><strong>*1、源码探究：*</strong></em></h3><p>System：是Java.lang包中的一个类，自动导入，不用import；</p>
<p>out：是System的一个成员变量，用static修饰的，可用System类名直接调用</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps16.jpg" alt="img"> </p>
<p>out的类型是引用数据类型中的PrintStream，所以out可以使用PrintStream中的println( )方法；</p>
<p>println()：并不是System类中的一个方法，而是PrintStream中的一个成员方法。</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps17.jpg" alt="img"> <img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps18.jpg" alt="img"> <img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps19.jpg" alt="img"></p>
<p>总结就是：System类中静态的、且为PrintStream类型的字段out去调用了PrintStream类中的print( )和println( )两个方法也就有了System.out.println( )形式的输出语句。</p>
<h3 id="2、为什么不直接使用PrintStream，而要用System-out呢"><a href="#2、为什么不直接使用PrintStream，而要用System-out呢" class="headerlink" title="*2、为什么不直接使用PrintStream，而要用System.out呢*"></a><em><strong>*2、为什么不直接使用PrintStream，而要用System.out呢*</strong></em></h3><p>PrintStream类并没有无参构造，而其有参构造函数不是要流，就是要File文件，想要直接通过new一个PrintStream类的方式来创建实例，将变得非常麻烦。因此，通过System.out获取一个PrintStream实例的方式才会成为实际使用的。</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps20.jpg" alt="img"> </p>
<h3 id="3、为什么println-和print-这两个方法什么数据类型都可以输出"><a href="#3、为什么println-和print-这两个方法什么数据类型都可以输出" class="headerlink" title="*3、为什么println( )和print( )这两个方法什么数据类型都可以输出*"></a><em><strong>*3、为什么println( )和print( )这两个方法什么数据类型都可以输出*</strong></em></h3><p>因为在PrintStream类中重载了 Println( )方法，包含了相关的数据类型。</p>
<h3 id="4、-System-out-println-的意思"><a href="#4、-System-out-println-的意思" class="headerlink" title="*4、*****System.out::println*****的意思*"></a><em><strong>*4、*</strong>***</em>*System.out::println****<em><strong>*的意思*</strong></em></h3><p>函数式编程：可以使用“函数式接口 变量名 = 类实例::方法名” 的方式对该方法进行引用，System.out::println其实是Consumer<T>接口的一个实现方式</p>
<p>eg1：</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps21.jpg" alt="img"> </p>
<p>eg2：</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps22.jpg" alt="img"><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps23.jpg" alt="img">  <img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps24.jpg" alt="img"></p>
<p>重点：</p>
<p> System.out是一个PrintStream实例的引用；System.out::println 是对一个实例方法的引用。该引用同时指定了对实例（System.out）的引用以及对方法（PrintStream::println）的引用</p>
<p> System.out::println不是 System.out.println 的等价物；前者是一个方法引用表达式，而后者不能单独作为一个表达式，而必须在后面跟上由圆括号包围的参数列表来构成方法调用表达式。</p>
<p> System.out::println 可以看作 lambda表达式 e -&gt; System.out.println(e) 的缩写形式。</p>
<h2 id="9-26、泛型"><a href="#9-26、泛型" class="headerlink" title="9.26、泛型"></a>9.26、泛型</h2><h3 id="1、定义：“泛型”意味着编写的代码可以被不同类型的对象所重用。"><a href="#1、定义：“泛型”意味着编写的代码可以被不同类型的对象所重用。" class="headerlink" title="*1、定义：“泛型”意味着编写的代码可以被不同类型的对象所重用。*"></a><em><strong>*1、定义：“泛型”意味着编写的代码可以被不同类型的对象所重用。*</strong></em></h3><p>泛型，即“参数化类型”。顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<h3 id="2、作用域"><a href="#2、作用域" class="headerlink" title="*2、作用域*"></a><em><strong>*2、作用域*</strong></em></h3><p>泛型只在编译阶段有效，泛型信息不会进入到运行时阶段。</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps25.jpg" alt="img"> </p>
<p>在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。</p>
<p>对此总结成一句话：<strong>泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h3 id="3、泛型的使用"><a href="#3、泛型的使用" class="headerlink" title="*3、泛型的使用*"></a><em><strong>*3、泛型的使用*</strong></em></h3><p><strong>3**</strong>.1**<strong>泛型类</strong></p>
<p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic<T>{   //key这个成员变量的类型为T,T的类型由外部指定    private T key;  public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定    this.key = key;  }  public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定    return key;  }}</p>
<p><strong>3.2泛型接口</strong></p>
<p>泛型接口常被用在各种类的生产器中</p>
<p>//定义一个泛型接口public interface Generator<T> {  public T next();}</p>
<p><strong>3.3泛型方法</strong></p>
<p>泛型方法，是在调用方法的时候指明泛型的具体类型 。</p>
<p>/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： *   1）public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法。 *   2）只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 *   3）<T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 *   4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public <T> T genericMethod(Class<T> tClass)throws InstantiationException , IllegalAccessException{    T instance = tClass.newInstance();    return instance;}</p>
<h3 id="4、泛型的好处"><a href="#4、泛型的好处" class="headerlink" title="*4、泛型的好处*"></a><em><strong>*4、泛型的好处*</strong></em></h3><p> 泛化代码，代码可以更多的重复利用。不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据；</p>
<p> 消除强制类型转换。只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 </p>
<p> 类型安全，提供编译期间的类型检测。</p>
<p> 性能较高，用GJ(泛型JAVA)编写的代码可以为java编译器和虚拟机带来更多的类型信息，这些信息对java程序做进一步优化提供条件。</p>
<h3 id="5-、Java的泛型是如何工作的"><a href="#5-、Java的泛型是如何工作的" class="headerlink" title="*5*****、Java的泛型是如何工作的 ?****"></a><em><strong>*5*</strong>***</em>*、Java的泛型是如何工作的 ?****</h3><p>泛型是通过<strong>类型擦除</strong>来实现的，编译器在编译时擦除了所有类型相关的信息，在运行时不存在任何类型相关的信息。例如 List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型</p>
<h3 id="6-、什么是类型擦除"><a href="#6-、什么是类型擦除" class="headerlink" title="*6*****、什么是类型擦除 ?****"></a><em><strong>*6*</strong>***</em>*、什么是类型擦除 ?****</h3><p>所有类型参数都用他们的限定类型替换：</p>
<p>比如T-&gt;Object ? extends BaseClass-&gt;BaseClass</p>
<h3 id="7-、Java中List和原始类型List之间的区别"><a href="#7-、Java中List和原始类型List之间的区别" class="headerlink" title="*7*****、Java中List和原始类型List之间的区别?****"></a><em><strong>*7*</strong>***</em>*、Java中List<Object>和原始类型List之间的区别?****</h3><p>在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。</p>
<p>它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List<String>传递给接受 List<Object>的方法，因为会产生编译错误。</p>
<h3 id="8、你可以把List传递给一个接受List参数的方法吗？"><a href="#8、你可以把List传递给一个接受List参数的方法吗？" class="headerlink" title="*8、你可以把List传递给一个接受List参数的方法吗？*"></a><em><strong>*8、你可以把List<String>传递给一个接受List<Object>参数的方法吗？*</strong></em></h3><p>不可以，会导致编译错误，因为List<Object>可以存储任何类型的对象包括String, Integer等等，而List<String>却只能用来存储String s</p>
<h3 id="9-、Java中List-lt-gt-和List之间的区别是什么"><a href="#9-、Java中List-lt-gt-和List之间的区别是什么" class="headerlink" title="*9*****、Java中List&lt;?&gt;和List之间的区别是什么?****"></a><em><strong>*9*</strong>***</em>*、Java中List&lt;?&gt;和List<Object>之间的区别是什么?****</h3><p>List<?> 是一个未知类型的List，而List<Object> 其实是任意类型的List。你可以把List<String>, List<Integer>赋值给List<?>，却不能把List<String>赋值给 List<Object>。</p>
<h3 id="10、泛型类型变量不能是基本数据类型"><a href="#10、泛型类型变量不能是基本数据类型" class="headerlink" title="*10、泛型类型变量不能是基本数据类型*"></a><em><strong>*10、泛型类型变量不能是基本数据类型*</strong></em></h3><p>没有ArrayList<double>，只有ArrayList<Double>。因为当类型擦除后，ArrayList的原始类中的类型变量（T）替换为Object，但Object类型不能存储double值。</p>
<h3 id="11、-什么是泛型中的限定通配符和非限定通配符"><a href="#11、-什么是泛型中的限定通配符和非限定通配符" class="headerlink" title="*11、*****什么是泛型中的限定通配符和非限定通配符 ?****"></a><em><strong>*11、*</strong>***</em>*什么是泛型中的限定通配符和非限定通配符 ?****</h3><p><strong>限定通配符</strong>对类型进行了限制。有两种限定通配符：</p>
<p>一种是&lt;? extends T&gt;它通过确保类型必须是T的子类来设定类型的上界，</p>
<p>另一种是&lt;? super T&gt;它通过确保类型必须是T的父类来设定类型的下界。</p>
<p>泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面**<?>表示了非限定通配符**，因为<?>可以用任意类型来替代。</p>
<h3 id="12-、List-lt-extends-T-gt-和List-lt-super-T-gt-之间有什么区别"><a href="#12-、List-lt-extends-T-gt-和List-lt-super-T-gt-之间有什么区别" class="headerlink" title="*12*****、List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?****"></a><em><strong>*12*</strong>***</em>*、List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?****</h3><p>这两个List的声明都是<strong>限定通配符</strong>的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<Integer>或List<Float>。</p>
<h3 id="1-3-、Array中可以用泛型吗"><a href="#1-3-、Array中可以用泛型吗" class="headerlink" title="*1*****3*****、Array中可以用泛型吗?*"></a><em><strong>*1*</strong>***</em>*3****<em><strong>*、Array中可以用泛型吗?*</strong></em></h3><p>Array事实上<strong>并不支持</strong>泛型，这也是为什么在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。</p>
<h2 id="9-27、反射相关问题"><a href="#9-27、反射相关问题" class="headerlink" title="9.27、反射相关问题"></a>9.27、反射相关问题</h2><h3 id="1、获取Class对象的方式（3种）"><a href="#1、获取Class对象的方式（3种）" class="headerlink" title="*1、获取Class对象的方式（3种）*"></a><em><strong>*1、获取Class对象的方式（3种）*</strong></em></h3><p>方式一: 通过Object类中的getClass()方法</p>
<p>Person p = new Person();Class c = p.getClass();</p>
<p>方式二: 通过 类名.class获取到字节码文件对象（任意数据类型都具备一个class静态属性,看上去要比第一种方式简单）。</p>
<p>Class c2 = Person.class;</p>
<p>方式三: 通过Class类中的方法（将类名作为字符串传递给Class类中的静态方法forName即可）。</p>
<p>Class c3 = Class.forName(“Person”);</p>
<p><strong>注意：第三种和前两种的区别</strong></p>
<p>前两种你必须明确Person类型，后面是指定这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串，按照配置文件加载就可以了。</p>
<h3 id="2-、获取全部构造器方法、公有构造器方法，私有构造器方法，暴力私有、公有私有成员变量"><a href="#2-、获取全部构造器方法、公有构造器方法，私有构造器方法，暴力私有、公有私有成员变量" class="headerlink" title="*2*****、获取全部构造器方法、公有构造器方法，私有构造器方法，暴力私有、公有私有成员变量****"></a><em><strong>*2*</strong>***</em>*、获取全部构造器方法、公有构造器方法，私有构造器方法，暴力私有、公有私有成员变量****</h3><p><strong>公有的带参/不带参</strong></p>
<p>//1,获取到Class对象        Class c = Class.forName(“cn.itcast_01_Reflect.Person”);//包名.类名        //2,获取指定的构造方法        //public Person()        //Constructor con = c.getConstructor(null);//空参的构造方法        //public Person(String name, int age, String address)        Constructor con = c.getConstructor(String.class, int.class, String.class);        //3,通过构造方法类中Constructor的方法，创建对象        //Object obj = con.newInstance(null);        Object obj = con.newInstance(“小明”, 22, “哈尔滨”);        //显示        System.out.println(obj);</p>
<p><strong>私有的</strong></p>
<p>//1,获取到Class对象        Class c = Class.forName(“cn.itcast_01_Reflect.Person”);//包名.类名        //2,获取指定的构造方法        //private Person(String name, int age)        Constructor con = c.getDeclaredConstructor(String.class, int.class);        //3,暴力反射         con.setAccessible(true);//取消 Java 语言访问检查        //4,通过构造方法类中的功能，创建对象        Object obj = con.newInstance(“小明”, 23);        System.out.println(obj);</p>
<p><strong>成员变量</strong></p>
<p>//1,获取Class对象        Class c = Class.forName(“cn.itcast_01_Reflect.Person”);        //2，获取构造方法        //public Person(String name)         Constructor con = c.getConstructor(String.class);        //3，通过构造方法，创建对象        Object obj = con.newInstance(“小明”);        //4，获取指定的成员变量        //public String name;        Field nameField = c.getField(“name”);        //public int age;        Field ageField = c.getField(“age”);        //private String address;        Field addressField = c.getDeclaredField(“address”);        addressField.setAccessible(true); //取消 Java 语言访问检查        //5，赋值        ageField.set(obj, 23);        addressField.set(obj, “凯利广场”);        /,6，取值        System.out.println(“name = “+ nameField.get(obj));        System.out.println(“age = “+ ageField.get(obj));        System.out.println(“address = “+ addressField.get(obj));</p>
<h3 id="3-、一个私有的属性，没有set方法，如何改值-反射获取私有变量并赋值"><a href="#3-、一个私有的属性，没有set方法，如何改值-反射获取私有变量并赋值" class="headerlink" title="*3*****、一个私有的属性，没有set方法，如何改值****  *反射获取私有变量并赋值*"></a><em><strong>*3*</strong>***</em>*、一个私有的属性，没有set方法，如何改值****  <em><strong>*反射获取私有变量并赋值*</strong></em></h3><p>通过反射机制修改类中的私有属性的值</p>
<p>public class PrivateTest {  private String name = “hello”;  public String getName() {    return name;  }} public class ReflectionTest {public static void main(String[] args) throws Exception {  Class c = Class.forName(“包名.类名”);  Object obj = c.newInstance(); // 通过类名来获取该类的实例化对象    Field field = c.getDeclaredField(“name”); // 获得指定类的属性    field.setAccessible(true);    // 更改私有属性的值    field.set(obj, “world”);    System.out.println(pt.getName());  }}</p>
<h3 id="4、获取空参成员方法，有参成员方法"><a href="#4、获取空参成员方法，有参成员方法" class="headerlink" title="*4、获取空参成员方法，有参成员方法*"></a><em><strong>*4、获取空参成员方法，有参成员方法*</strong></em></h3><p><strong>公有的</strong></p>
<p>//1， 获取Class对象        Class c = Class.forName(“cn.itcast_01_Reflect.Person”);        //2,获取构造方法        //public Person(String name, int age, String address){        Constructor con = c.getConstructor(String.class, int.class, String.class);        //3，通过构造方法，创建对象        Object obj = con.newInstance(“小明”, 23, “哈尔滨”);        //4，获取指定的方法        //public void method1()  没有返回值没有参数的方法        //Method m1 = c.getMethod(“method1”, null);        //public String method4(String name)        Method m4 = c.getMethod(“method4”, String.class);        //5，执行找到的方法        //m1.invoke(obj, null);        Object result = m4.invoke(obj, “itcast”);        System.out.println(“result = “ + result);</p>
<p><strong>私有的</strong></p>
<p>//1， 获取Class对象        Class c = Class.forName(“cn.itcast_01_Reflect.Person”);        //2,获取构造方法        //public Person(String name, int age, String address){        Constructor con = c.getConstructor(String.class, int.class, String.class);        //3，通过构造方法，创建对象        Object obj = con.newInstance(“小明”, 23, “哈尔滨”);        //4，获取指定的方法        //private void method5(){        Method m5 = c.getDeclaredMethod(“method5”, null);        //5,开启暴力访问        m5.setAccessible(true);        //6，执行找到的方法        m5.invoke(obj, null);</p>
<h3 id="5、如何向ArrayList-里面添加一个Integer类型的量"><a href="#5、如何向ArrayList-里面添加一个Integer类型的量" class="headerlink" title="*5、如何向ArrayList**********里面添加一个Integer类型的量*"></a><em><strong>*5、如何向ArrayList*</strong>***</em>*<String>****<em><strong>*里面添加一个Integer类型的量*</strong></em></h3><p> <strong>泛型擦除（“伪泛型”）：</strong>编译后的class文件没有泛型</p>
<p>不对集合类操作，通过反射获取ArrayList类的class文件对象，调用add方法</p>
<p>public class ReflectionTest {public static void main(String[] args) throws Exception {  ArrayList<String> array = new ArrayList&lt;&gt;();  array.add(“name”);  Class c = array.getClass();  Method method = c.getMethod(“add”, Object.class);  method.invoke(array, 150);  method.invoke(array, 1000);    System.out.println(array);    for (Object obj : array)  // 要用obj类型的来遍历，既有String、Integer      System.out.println(obj);  }}打印结果：[name, 150, 1000]name1501000</p>
<h3 id="6-、JAVA的newInstance-和new的区别-JAVA反射机制，通过类名来获取该类的实例化对象"><a href="#6-、JAVA的newInstance-和new的区别-JAVA反射机制，通过类名来获取该类的实例化对象" class="headerlink" title="*6*****、JAVA的newInstance()和new的区别(JAVA反射机制，通过类名来获取该类的实例化对象)****"></a><em><strong>*6*</strong>***</em>*、JAVA的newInstance()和new的区别(JAVA反射机制，通过类名来获取该类的实例化对象)****</h3><p>Class c = Class.forName(“包名.类名”);Object obj = c.newInstance(); // 通过类名来获取该类的实例化对象</p>
<p>从jvm的角度看，我们使用new的时候，这个要new的类可以没有加载；</p>
<p>但是使用newInstance时候，就必须保证：1、这个类已经加载；2、这个类已经连接了。而完成上面两个步骤的正是class的静态方法forName（）方法，这个静态方法调用了启动类加载器。newInstance实际上是把new这个方式分解为两步。首先调用class的加载方法加载某个类，然后实例化。</p>
<p>newInstance: 弱类型。低效率。只能调用无参构造。</p>
<p>new: 强类型。相对高效。能调用任何public构造。</p>
<p>newInstance()是实现IOC、反射、面对接口编程和依赖倒置等技术方法的必然选择，new只能实现具体类的实例化，不适合于接口编程。</p>
<h2 id="9-28、Object类的方法"><a href="#9-28、Object类的方法" class="headerlink" title="9.28、Object类的方法"></a>9.28、Object类的方法</h2><p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps26.jpg" alt="img"> </p>
<h3 id="1、Object构造方法"><a href="#1、Object构造方法" class="headerlink" title="*1、Object构造方法*"></a><em><strong>*1、Object构造方法*</strong></em></h3><h3 id="2、-clone"><a href="#2、-clone" class="headerlink" title="*2、*****clone*****()*"></a><em><strong>*2、*</strong>***</em>*clone****<em><strong>*()*</strong></em></h3><p>返回的对象为浅拷贝，clone()方法同样是一个被声明为native的方法，因此，我们知道了clone()方法并不是Java的原生方法，具体的实现是有C/C++完成的。clone函数返回的是一个引用，指向的是新的clone出来的对象，此对象与原对象分别占用不同的堆空间。</p>
<p>相关问题：</p>
<p>（1）new 和 clone的区别：</p>
<p>l clone()不会调用构造方法；new会调用构造方法</p>
<p>l clone()更快。clone()能快速创建一个已有对象的副本，即创建对象并且将已有对象中所有属性值克隆；new只能在JVM中申请一个空的内存区域，对象的属性值要通过构造方法赋值</p>
<p>（2）深拷贝和浅拷贝</p>
<p>l 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<p>l 实现对象拷贝的类，必须实现Cloneable接口，并覆写clone()方法。</p>
<p>l 深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝比浅拷贝速度慢且花销较大。</p>
<p>l 若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。</p>
<h3 id="3、-getClass"><a href="#3、-getClass" class="headerlink" title="*3、*****getClass()****"></a><em><strong>*3、*</strong>***</em>*getClass()****</h3><p>getClass()也是一个native方法，返回的是此Object对象的类对象/运行时类对象Class&lt;?&gt;。效果与Object.class相同。</p>
<h3 id="4、-equals"><a href="#4、-equals" class="headerlink" title="*4、*****equals()****"></a><em><strong>*4、*</strong>***</em>*equals()****</h3><p>l ==表示的是变量值相同（对于基本数据类型，地址中存储的是值，引用类型则存储指向实际对象的地址）；比地址</p>
<p>l equals是对象的内容是否相同，重写，则按重写比，否则按object的。比值</p>
<p><strong>l</strong> <em><strong>*重写equals()方法必须重写hasCode()方法*</strong></em></p>
<h3 id="5、hashcode"><a href="#5、hashcode" class="headerlink" title="*5、hashcode*****()****"></a><em><strong>*5、hashcode*</strong>***</em>*()****</h3><p>hashCode()方法返回一个整形数值，表示该对象的哈希码值。</p>
<p>l 如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等；</p>
<p>l 判断现有集合中是否已经存在与此对象相等的对象，如果没有hashCode()方法，需要将Set进行一次遍历，并逐一用equals()方法判断两个对象是否相等，此种算法时间复杂度为o(n)。通过借助于hasCode方法，先计算出即将新加入对象的哈希码，然后根据哈希算法计算出此对象的位置，直接判断此位置上是否已有对象即可。result*31 = (result&lt;&lt;5) - result</p>
<p>l hashCode()相同的两个对象，不一定相等，换言之，不相等的两个对象，hashCode()返回的哈希码可能相同。</p>
<h3 id="6、-toString"><a href="#6、-toString" class="headerlink" title="*6、*****toString()****"></a><em><strong>*6、*</strong>***</em>*toString()****</h3><p>toString()方法返回该对象的字符串表示。</p>
<h3 id="7、wait"><a href="#7、wait" class="headerlink" title="*7、wait()*"></a><em><strong>*7、wait()*</strong></em></h3><p>wait()使当前线程阻塞，前提是 必须先获得锁，配合synchronized 关键字使用。当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。</p>
<h3 id="8-、notify-notifyAll"><a href="#8-、notify-notifyAll" class="headerlink" title="*8*****、notify()**** */* *notifyAll()*"></a><em><strong>*8*</strong>***</em>*、notify()**** <em><strong>*/*</strong></em> <em><strong>*notifyAll()*</strong></em></h3><p>notify()/notifyAll()方法调用后，其所在线程不会立即释放所持有的锁，直到其所在同步代码块中的代码执行完毕，此时释放锁，因此，如果其同步代码块后还有代码，其执行则依赖于JVM的线程调度。</p>
<p>JVM会为一个使用内部锁（synchronized）的对象维护两个集合，Entry Set和Wait Set，也有人翻译为锁池和等待池</p>
<p>l 对于Entry Set：如果线程A已经持有了对象锁，此时如果有其他线程也想获得该对象锁的话，它只能进入Entry Set，并且处于线程的BLOCKED状态。</p>
<p>l 对于Wait Set：如果线程A调用了wait()方法，那么线程A会释放该对象的锁，进入到Wait Set，并且处于线程的WAITING状态。</p>
<p>l 某个线程B想要获得对象锁，一般情况下有两个先决条件</p>
<p>一是对象锁已经被释放了（如曾经持有锁的前任线程A执行完了synchronized代码块或者调用了wait()方法等等）</p>
<p>二是线程B已处于RUNNABLE状态。</p>
<p>l 对于Entry Set中的线程，当对象锁被释放的时候，JVM会唤醒处于Entry Set中的某一个线程，这个线程的状态就从BLOCKED转变为RUNNABLE。</p>
<p>l 对于Wait Set中的线程，当对象的notify()方法被调用时，JVM会唤醒处于Wait Set中的某一个线程，这个线程的状态就从WAITING转变为RUNNABLE；或者当notifyAll()方法被调用时，Wait Set中的全部线程会转变为RUNNABLE状态。所有Wait Set中被唤醒的线程会被转到Entry Set中。</p>
<p>l 然后，每当对象的锁被释放后，那些所有处于RUNNABLE状态的线程会共同去竞争获取对象的锁，最终会有一个线程（具体哪一个取决于JVM实现，队列里的第一个？随机的一个？）真正获取到对象的锁，而其他竞争失败的线程继续在Entry Set中等待下一次机会。</p>
<p>l 尽量使用notifyAll()的原因就是，notify()非常容易导致死锁，但是notifyall唤醒全部也会造成开销。</p>
<h3 id="9、-finalize"><a href="#9、-finalize" class="headerlink" title="*9、*****finalize()****"></a><em><strong>*9、*</strong>***</em>*finalize()****</h3><p>finalize方法主要与Java垃圾回收机制有关。二次标记。</p>
<h2 id="9-29、权限修饰符"><a href="#9-29、权限修饰符" class="headerlink" title="9.29、权限修饰符"></a>9.29、权限修饰符</h2><p>private &lt; default &lt; protected &lt; public</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps27.jpg" alt="img"> </p>
<h2 id="9-30、jdk1-8改进"><a href="#9-30、jdk1-8改进" class="headerlink" title="9.30、jdk1.8改进"></a>9.30、jdk1.8改进</h2><h3 id="1、Lambda表达式"><a href="#1、Lambda表达式" class="headerlink" title="*1、Lambda表达式*"></a><em><strong>*1、Lambda表达式*</strong></em></h3><p>lambda表达式本质上是一段匿名内部类，也可以是一段可以传递的代码</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps28.jpg" alt="img"> </p>
<h3 id="2、函数式接口"><a href="#2、函数式接口" class="headerlink" title="*2、函数式接口*"></a><em><strong>*2、函数式接口*</strong></em></h3><p>函数式接口的提出是为了给Lambda表达式的使用提供更好的支持。</p>
<p>只定义了一个抽象方法的接口（Object类的public方法除外），就是函数式接口，并且还提供了注解：@FunctionalInterface</p>
<p> Consumer <T>：消费型接口，有参无返回值</p>
<p> Supplier<T>：供给型接口，无参有返回值</p>
<p> Function&lt;T，R&gt;：函数式接口，有参有返回值</p>
<p> Predicate<T>：断言型接口，有参有返回值，返回值是boolean类型</p>
<h3 id="3、方法引用"><a href="#3、方法引用" class="headerlink" title="*3、方法引用*"></a><em><strong>*3、方法引用*</strong></em></h3><p>若lambda体中的内容有方法已经实现了，那么可以使用“方法引用”，也可以理解为方法引用是lambda表达式的另外一种表现形式并且其语法比lambda表达式更加简单。</p>
<p>方法引用、构造器引用、数组引用</p>
<h3 id="4、-Stream-API"><a href="#4、-Stream-API" class="headerlink" title="*4、*****Stream API****"></a><em><strong>*4、*</strong>***</em>*Stream API****</h3><p>Stream操作的三个步骤：</p>
<p>创建stream </p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps29.jpg" alt="img"> </p>
<p>中间操作（过滤、map）</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps30.jpg" alt="img"> </p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps31.jpg" alt="img"> </p>
<p>终止操作</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps32.jpg" alt="img"> </p>
<h3 id="5、接口中可以定义默认实现方法和静态方法"><a href="#5、接口中可以定义默认实现方法和静态方法" class="headerlink" title="*5、接口中可以定义默认实现方法和静态方法*"></a><em><strong>*5、接口中可以定义默认实现方法和静态方法*</strong></em></h3><p>在接口中可以使用default和static关键字来修饰接口中定义的普通方法</p>
<p><img src="C:\Users\admin\AppData\Local\Temp\ksohtml6648\wps33.jpg" alt="img"> </p>
<p>当一个类继承父类又实现接口时，若后两者方法名相同，则优先继承父类中的同名方法，即“类优先”，如果实现两个同名方法的接口，则要求实现类必须手动声明默认实现哪个接口中的方法。</p>
<h3 id="6、新的日期API"><a href="#6、新的日期API" class="headerlink" title="*6、新的日期API*"></a><em><strong>*6、新的日期API*</strong></em></h3><p>LocalDate | LocalTime | LocalDateTime</p>
<p>新的日期API都是不可变的，更使用于多线程的使用环境中</p>
<h3 id="7、hashmap和concurrenthashmap结构"><a href="#7、hashmap和concurrenthashmap结构" class="headerlink" title="*7、hashmap和concurrenthashmap结构*"></a><em><strong>*7、hashmap和concurrenthashmap结构*</strong></em></h3><h1 id="10、RabbitMQ"><a href="#10、RabbitMQ" class="headerlink" title="10、RabbitMQ"></a>10、RabbitMQ</h1><h2 id="10-1、如何保证消息的可靠性传输（如何处理消息丢失的问题）？"><a href="#10-1、如何保证消息的可靠性传输（如何处理消息丢失的问题）？" class="headerlink" title="10.1、如何保证消息的可靠性传输（如何处理消息丢失的问题）？"></a>10.1、如何保证消息的可靠性传输（如何处理消息丢失的问题）？</h2><p>1）生产者弄丢了数据：可以开启confirm模式，每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。<em><strong>*confirm机制是异步的。*</strong></em></p>
<p><em><strong>*2）*<em><strong>rabbitmq弄丢了数据，</strong></em>*开启rabbitmq的持久化*<em><strong>，就是消息写入之后会</strong></em>*持久化到磁盘*<em><strong>。</strong></em>*创建queue的时候将其设置为持久化的，发送消息的时候将*</strong></em></p>
<p>****消息的deliveryMode设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘上去。*<em><strong>而且持久化</strong></em>*可以跟生产者那边的confirm机制配合起来****，只有消息被持久化到磁盘之后，才会通知生产者ack了。</p>
<p>3****）消费端弄丢了数据：手动调用rabbitmq提供的ack机制。每次你自己代码里确保处理完的时候，再程序里ack一把。****这样的话，如果你还没处理完，不就没有ack？那rabbitmq就认为你还没处理完，这个时候rabbitmq会把这个消费分配给别的consumer去处理。</p>
<h2 id="10-2、保证消息是有顺序的"><a href="#10-2、保证消息是有顺序的" class="headerlink" title="10.2、保证消息是有顺序的"></a>10.2、保证消息是有顺序的</h2><p><em><strong>*拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理。*</strong></em></p>
<h2 id="10-3、消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？"><a href="#10-3、消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？" class="headerlink" title="10.3、消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？"></a>10.3、消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？</h2><p>​    <em><strong>*可能你的消费端出了问题，不消费了。*</strong></em></p>
<p>​    <em><strong>*先修复consumer的问题，确保其恢复消费速度，临时紧急扩容，将queue资源和consumer资源扩大，增加消费能力，等快速消费完积压数据之后，得恢复原先部署架构。*</strong></em></p>
<p>​    <em><strong>*rabbitmq，rabbitmq是可以设置过期时间的，就是TTL，大量积压在mq里，而是大量的数据会直接搞丢。批量重导，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入mq里面去，把白天丢的数据给他补回来。*</strong></em></p>
<h2 id="10-4、如何保证消息不被重复消费"><a href="#10-4、如何保证消息不被重复消费" class="headerlink" title="10.4、如何保证消息不被重复消费"></a>10.4、如何保证消息不被重复消费</h2><p>​    <em><strong>*保证消息队列消费的幂等性就不怕，重复消费无所谓。主要是结合业务来谈：如写数据库，先根据主键查一下，如果这数据都有了，你就别插入了，update一下好吧。如果是写redis，那没问题了，反正每次都是set，天然幂等性。如果是下订单，让生产者发送每条数据的时候，里面加一个全局唯一的id，根据ID查询是否消费过了，如果已经处理，就忽视。*</strong></em></p>
<h2 id="10-5、RabbitMQ高可用性"><a href="#10-5、RabbitMQ高可用性" class="headerlink" title="10.5、RabbitMQ高可用性"></a>10.5、RabbitMQ高可用性</h2><p><em><strong>*rabbitmq有三种模式：单机模式，普通集群模式，镜像集群模式。单击模式，一个节点。普通集群，*<em><strong>多台机器上启动多个rabbitmq实例，每个机器启动一个。但是你创建的queue，只会放在一个rabbtimq实例上，但是每个实例都同步queue的元数据。实际上如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。没做到所谓的分布式。</strong></em>*镜像集群模式: 你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了。*</strong></em></p>
<h1 id="11、项目相关"><a href="#11、项目相关" class="headerlink" title="11、项目相关"></a>11、项目相关</h1><p>秒杀项目的面试问题：</p>
<p>秒杀项目介绍：</p>
<p>​    <em><strong>*1：这个项目主要是针对处理高并发问题。主要考虑的问题有以下几个方面：*</strong></em></p>
<p><em><strong>*一、正确性。核心问题就是防止超卖，和重复下单。*</strong></em></p>
<p><em><strong>*二、*</strong>***</em>*高并发。主要是采用Redis进行缓存常用查询、消息队列异步下单、页面资源静态化等方面减去数据库压力。****</p>
<p><em><strong>*三、安全性。主要有动态地址生成和接口放刷，双重MD5加密密码。*</strong></em></p>
<p><em><strong>*四、高可用性。一方面使用Redis集群的主从复制和主从切换保证redis的高可用性，另一方面，为防止redsi服务器宕*</strong></em>    <em><strong>*机，使用限流来防止mysql承受过多的请求。*</strong></em></p>
<h2 id="11-1、如何防止超卖"><a href="#11-1、如何防止超卖" class="headerlink" title="11.1、如何防止超卖"></a>11.1、如何防止超卖</h2><p>​    1、利用数据库自带排他锁，当减库存的时候，进位where判断，只有库存余量大于0的时候才进行进库存; update goods set num = num - 1 WHERE id = 1001 and num &gt; 0; 2、也可以可用乐观锁CAS版本号机制。select version from goods WHERE id= 1001；update goods set num = num - 1, version = version + 1 WHERE id= 1001 AND num &gt; 0 AND version = @version(上面查到的version);</p>
<h2 id="11-2、服务器抗压思路"><a href="#11-2、服务器抗压思路" class="headerlink" title="11.2、服务器抗压思路"></a>11.2、服务器抗压思路</h2><p>​    一、使用消息队列、异步生成订单；</p>
<p>​    二、redis库存量预缓存。只将少量的请求流入到服务器。如果全部卖完，拦截请求。</p>
<p>​    三、生成订单前，进行一系列的检验：是否还有库存，是否重复下单，这些数据都可以缓存。</p>
<h2 id="11-3、前端设计"><a href="#11-3、前端设计" class="headerlink" title="11.3、前端设计"></a>11.3、前端设计</h2><p>​    ****静态资源缓存：****将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过CDN缓存静态资源，来抗峰值。在url后面加上？即可。</p>
<p>​    ****禁止重复提交****：前端:用户提交之后按钮置灰，禁止重复提交；后端：在进入页面时，服务器生成token并存到缓存或者session中，form表单使用隐藏域来存储这个token，提交之后带有token.后端收到这个token,看是否与服务器生成的token一致，如果不一致就是重复提交。如果一致，处理完之后清除token.</p>
<p>服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。</p>
<p>首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。</p>
<p>​    <em><strong>*用户限流：某一时间段内只允许用户提交少数次请求，IP限流(Nginx设置IP地址限流)。*</strong></em></p>
<p>​    </p>
<p><em><strong>*中间代理层：*</strong></em></p>
<p>​    <em><strong>*利用负载均衡（例如反响代理Nginx等）使用多个服务器并发处理请求，减小服务器压力。*</strong></em>    </p>
<p>​    <em><strong>*(正向代理代理客户端VPN，反向代理代理服务器。NGINX)*</strong></em> </p>
<p>​    横向增加服务器数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。普通轮询算法、比例加权轮询、ip路由负载、基于服务器响应时间负载分配、根据域名负载。</p>
<p>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
<p>指定权重：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
<p>IP绑定ip_hash：每个请求按ip的hash结果分配，<em><strong>*这样每个访客固定访问一个后端服务器*<em><strong>，</strong></em>*可以解决session的问题。*</strong></em></p>
<p>url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p>
<p>fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<p><em><strong>*服务层：*</strong></em></p>
<p>​    ****业务分离:****将秒杀业务系统和其他业务分离，单独放在高配服务器上。</p>
<p>​    采****用消息队列缓存请求****：将大流量请求写到消息队列缓存，利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求。</p>
<p>​    ****利用缓存应对读请求****：对于读多写少业务，大部分请求是查询请求，所以可以读写分离，利用缓存分担数据库压力。</p>
<p><em><strong>*数据库层：*</strong></em></p>
<p>​    上游就需要把请求拦截掉，数据库层只承担“能力范围内”的访问请求。所以，上面通过在服务层引入队列和缓存，让最底层的数据库高枕无忧。可以对数据库进行优化，减少数据库压力。</p>
<p>​    如果redis挂掉的话，如果提高数据库的并发能力：</p>
<p>​    ****业务拆分****：将不同功能的模块拆分，使用不同的数据库。</p>
<p>​    MySQL****主从复制，读写分离****：</p>
<p>​    <em><strong>*分表分库：*</strong></em></p>
<p>****其他策略：为请求分配成功状态或者分配秒杀资格，将没有资格的请求全部过滤，****只有有资格的才能参与秒杀。说到底的秒杀这个高并发，并不是真正的处理高并发请求，而是如何应对高并发。将大量请求拦截然后放小量请求到数据库执行抢单是完全可以的，不用担心请求丢失的问题。</p>
<h2 id="11-4、怎么保证redis缓存和数据库的一致性"><a href="#11-4、怎么保证redis缓存和数据库的一致性" class="headerlink" title="11.4、怎么保证redis缓存和数据库的一致性"></a>11.4、怎么保证redis缓存和数据库的一致性</h2><p>​    <em><strong>*延时双删；*</strong></em></p>
<p>​    存在不一致问题的，基本都是库存量。秒杀系统的设计，最重要的是不能超卖，这个问题我们已经谈过，用mysql排他锁或者乐观CAS版本号机制可以防止。而即使redis库存量比实际mysql库存量大，依然不会超卖。而redis库存量比mysql库存量小，可能发生没少卖的情况。少卖，问题不大。如果不能少卖，可以将redis预库存调大，他主要起到拦截请求降流的作用，一致不一致问题不大。</p>
<h2 id="11-5、安全性问题"><a href="#11-5、安全性问题" class="headerlink" title="11.5、安全性问题"></a>11.5、安全性问题</h2><p>​    <em><strong>*1、动态地址生成*</strong></em>    </p>
<p>​    <em><strong>*2、接口防刷*</strong></em></p>
<h2 id="11-6、消息队列"><a href="#11-6、消息队列" class="headerlink" title="11.6、消息队列"></a>11.6、消息队列</h2><p>​    ****防止重复消费****：重复消费在消息队列所存在的问题中，从来都不是一个严重的问题。如果是消息是读，那多消费一次没啥影响。如果是写，例如我们这个订单生成，消费之前，查询一下是否之前已经存在用户ID商品ID构成的订单，我们可以将生成的订单存入缓存，所以查询一次也不费劲。</p>
<p>​    ****消息的消费结果如何返回给消息发送方****：客户端轮询订单生成结果。</p>
<p>​    ****消息丢失：****秒杀系统中，本来就是万中选一的，丢失无所谓。如果是重要的信息，我们可以从三个角度来避免。如果是发送者丢失，开启confirm机制，如果队列丢失，开始queue持久化和消息持久化。如果是消费者丢失，关闭自动ACK,当我们消费完之后，调用API给queue发送确认信息。</p>
<h2 id="11-7、秒杀流程、画架构图"><a href="#11-7、秒杀流程、画架构图" class="headerlink" title="11.7、秒杀流程、画架构图"></a>11.7、秒杀流程、画架构图</h2><p>​    1、登录进入商品列表页面，静态资源缓存</p>
<p>​    2、点击进入商品详情页面，静态资源缓存，ajax获取验证码(服务器生成三个数的预算，并将结果缓存到redis);</p>
<p>​    3、点击秒杀, 将验证码结果和商品ID传给后端，如果结果正确。动态生成随机串UUID,结合用户ID和商品ID存入redis，并将path传给前端。前端获取path后，再根据path地址调用秒杀服务；</p>
<p>​    4、服务端获取请求的path参数，去查缓存是否在；</p>
<p>​    5、如果存在，预减redis库存，如果还有库存，看是否已经生成订单，没有的话就将请求入消息队列。</p>
<p>​    6、从消息队列中取消息：获取商品Id和用户ID,判断库存，重复下单；然后下单。</p>
<p>​    7、下单：减库存，生成订单； </p>
<p>​    8、前端轮询订单生成结果。50ms继续轮询或者秒杀是否成功和失败;</p>
<h2 id="11-8、优化策略"><a href="#11-8、优化策略" class="headerlink" title="11.8、优化策略"></a>11.8、优化策略</h2><p>​    多服务器负载均衡</p>
<h2 id="11-9、其他"><a href="#11-9、其他" class="headerlink" title="11.9、其他"></a>11.9、其他</h2><p><em><strong>*Jmeter进行压力测试。*</strong></em></p>
<p><em><strong>*分布式seesion:*</strong></em></p>
<p>用户登录之后,随机生成UUID，作为token以Cookie的方式返回给浏览器。同时将token作为redis key的后缀，用户对象作为value存入redis中。下次浏览器再发送HTTP请求的时候，带有这个Cookie。服务器获取http中的cookie并解析，得到token，然后再redis中查询，如果命中，则返回对象。</p>
<p><em><strong>*MD5双重加密*</strong></em>: 用户填写的表单，在发送给服务器之前，先进行一次MD5加密。然后以Post的形式发送给服务器。服务器获取这个用户ID和密码之后，随机生成Sault，并进行MD5加密。将加密之后的存入数据库，随机salut也存入数据库。</p>
<p><em><strong>*如何解决卖超问题：*</strong></em></p>
<p>//当库存大于0的时候才成功下订单，数据库本身会有锁，那么就不会在数据库中同时多个线程更新一条记录，使用数据库特性来保证超卖的问题；</p>
<p>数据库加唯一索引防止用户重复购买；</p>
<p>redis预减库存减少数据库访问　内存标记减少redis访问　请求先入队列缓冲，异步下单，增强用户体验；</p>
<p>页面级缓存thymeleafViewResolver，手动渲染  使用模板引擎；将渲染的html页面直接存到redis缓存中。</p>
<p>对象缓存Reids</p>
<p>​    redis永久缓存对象减少压力</p>
<p>​    redis预减库存减少数据库访</p>
<p>​    内存标记方法减少redis访问</p>
<p>订单处理队列rabbitmq</p>
<p> 请求先入队缓冲，异步下单，增强用户体验</p>
<p> 请求出队，生成订单，减少库存</p>
<p> 客户端定时轮询检查是否秒杀成功</p>
<p><em><strong>*下订单的过程:*</strong></em></p>
<p>1、将商品库存数量缓存到数据库，</p>
<p>2、获取缓存中的商品库存量</p>
<p>3，判断减去1之后的库存量</p>
<p>4、判断这个秒杀订单形成没有</p>
<p>5、正常请求，入队，发送一个秒杀message到队列里面去，入队之后客户端应该进行轮询。</p>
<p>消息队列：利用Mqsender将用户ID和商品ID的对象作为Json字符串发送给queue,然后消息队列发给指定的接受者。</p>
<p>获取对象ID和商品ID,    判断库存是否不足，判断是否已经下单成功。如果没有，    //原子操作：1.库存减1，(只有减库存成功，说明还有剩余的，才能下单)2.下订单(生成普通订单，生成秒杀订单，将秒杀订单缓存)，3.写入秒杀订单(如果没有生成，秒杀失败，说明卖完了，将外卖的状态写入缓存。)—&gt;是一个事务。</p>
<p>商品的库存量写入缓存，预减库存，查找是否还有足够的量，判断是否重复秒杀，然后订单请求入队；</p>
<p>然后请求出队，获取商品ID和用户ID，判断库存是否不足，是否已经重复下单，如果没有，真正的减库存，然后下单同时将订单写入缓存。如果没有成功，将卖完的状态写入缓存。客户端轮询是否完成下单。            </p>
<p>setTimeout(function() {getMiaoshaResult(goodsId);}, 50);//50ms之后继续轮询</p>
<p>总之，生产者将消息按照转换模式，以交换机的模式选择，将消息发送给指定类型的queue，消费者从监听的queue获取消息;</p>
<p>比如有10件商品要秒杀，可以放到缓存中，读写时不要加锁。 当并发量大的时候，可能有25个人秒杀成功，这样后面的就可以直接抛秒杀结束的静态页面。进去的25个人中有15个人是不可能获得商品的。所以可以根据进入的先后顺序只能前10个人购买成功。后面15个人就抛商品已秒杀完。</p>
<p>假设我们的秒杀场景</p>
<p>比如某商品10件物品待秒. 假设有100台web服务器(假设web服务器是Nginx + Tomcat),n台app服务器,n个数据库</p>
<p>第一步 如果Java层做过滤, 可以在每台web服务器的业务处理模块里做个计数器AtomicInteger(10)=待秒商品总数,decreaseAndGet()&gt;＝0的继续做后续处理, &lt;0的直接返回秒杀结束页面，这样经过第一步的处理只剩下100台*10个=1000个请求。</p>
<p>第二步, memcached 里以商品id作为key的value放个10, 每个web服务器在接到每个请求的同时, 向memcached服务器发起请求, 利用memcached的decr(key,1)操作返回值&gt;=0的继续处理, 其余的返回秒杀失败页面，这样经过第二步的处理只剩下100台中最快速到达的10个请求。</p>
<p>第三步, 向App服务器发起下单操作事务。</p>
<p>第四步, App服务器向商品所在的数据库请求减库存操作(操作数据库时可以 “update table set count=count-1 where id=商品id and count&gt;0;” update 成功记录数为1, 再向订单数据库添加订单记录, 都成功后提交整个事务, 否则的话提示秒杀失败，用户进入支付流程。</p>
<p>看看淘宝的秒杀</p>
<p>一、前端</p>
<p><em><strong>*面对高并发的抢购活动，前端常用的三板斧是【扩容】【静态化】【限流】*</strong></em></p>
<p>扩容：加机器，这是最简单的方法，通过增加前端池的整体承载量来抗峰值。</p>
<p>****静态化：将活动页面上的所有可以静态的元素全部静态化，****并尽量减少动态元素。通过CDN来抗峰值。</p>
<p>****限流：一般都会采用IP级别的限流，即针对某一个IP，限制单位时间内发起请求数量。****或者活动入口的时候增加游戏或者问题环节进行消峰操作。</p>
<p>有损服务：最后一招，在接近前端池承载能力的水位上限的时候，<em><strong>*随机拒绝部分请求来保护活动整体的可用性。*</strong></em></p>
<p>二、那么后端的数据库在高并发和超卖下会遇到什么问题呢</p>
<p>首先MySQL自身对于高并发的处理性能就会出现问题，一般来说，MySQL的处理性能会随着并发thread上升而上升，但是到了一定的并发度之后会出现明显的拐点，之后一路下降，最终甚至会比单thread的性能还要差。</p>
<p>其次，超卖的根结在于减库存操作是一个事务操作，需要先select，然后insert，最后update -1。最后这个-1操作是不能出现负数的，但是当多用户在有库存的情况下并发操作，出现负数这是无法避免的。</p>
<p>最后，当减库存和高并发碰到一起的时候，由于操作的库存数目在同一行，就会出现争抢InnoDB行锁的问题，导致出现互相等待甚至死锁，从而大大降低MySQL的处理性能，最终导致前端页面出现超时异常。</p>
<p>针对上述问题，如何解决呢？ 淘宝的高大上解决方案：</p>
<p>I：关闭死锁检测，提高并发处理性能。</p>
<p>II：修改源代码，将排队提到进入引擎层前，降低引擎层面的并发度。</p>
<p>III：组提交，降低server和引擎的交互次数，降低IO消耗。</p>
<p>解决方案1：<em><strong>*将存库从MySQL前移到Redis中，所有的写操作放到内存中，由于Redis中不存在锁故不会出现互相等待，并且由于Redis的写性能和读性能都远高于MySQL，这就解决了高并发下的性能问题。然后通过队列等异步手段，将变化的数据异步写入到DB中。*</strong></em></p>
<p>优点：解决性能问题</p>
<p>缺点：没有解决超卖问题，同时由于异步写入DB，存在某一时刻DB和Redis中数据不一致的风险。</p>
<p>解决方案2：<em><strong>*引入队列，然后将所有写DB操作在单队列中排队，完全串行处理。当达到库存阀值的时候就不在消费队列，并关闭购买功能。这就解决了超卖问题。*</strong></em></p>
<p>优点：解决超卖问题，略微提升性能。</p>
<p>缺点：性能受限于队列处理机处理性能和DB的写入性能中最短的那个，<em><strong>*另外多商品同时抢购的时候需要准备多条队列。*</strong></em></p>
<p>解决方案3：将写操作前移到MC中，同时利用MC的轻量级的锁机制CAS来实现减库存操作。</p>
<p>优点：读写在内存中，操作性能快，引入轻量级锁之后可以保证同一时刻只有一个写入成功，解决减库存问题。</p>
<p>缺点：没有实测，基于CAS的特性不知道高并发下是否会出现大量更新失败？不过加锁之后肯定对并发性能会有影响。</p>
<p>解决方案4：将提交操作变成两段式，先申请后确认。然后利用Redis的原子自增操作，同时利用Redis的事务特性来发号，保证拿到小于等于库存阀值的号的人都可以成功提交订单。然后数据异步更新到DB中。</p>
<p>优点：解决超卖问题，库存读写都在内存中，故同时解决性能问题。</p>
<p>缺点：由于异步写入DB，可能存在数据不一致。另可能存在少买，也就是如果拿到号的人不真正下订单，可能库存减为0，但是订单数并没有达到库存阀值。</p>
<p>总结</p>
<p>Java用到的线程调度算法：</p>
<p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<p><em><strong>*默认升序，数据库排序；ASC*</strong></em> </p>
<p><em><strong>*无法使用比较运算符来测试 NULL 值，比如 =, &lt;, 或者 &lt;&gt;。*</strong></em></p>
<p><em><strong>*我们必须使用 IS NULL 和 IS NOT NULL 操作符。*</strong></em></p>
<p>CREATE TABLE Person </p>
<p>(</p>
<p>LastName varchar(30),</p>
<p>FirstName varchar,</p>
<p>Address varchar,</p>
<p>Age int(3)</p>
<p>)</p>
<h1 id="12、Nginx"><a href="#12、Nginx" class="headerlink" title="12、Nginx"></a>12、Nginx</h1><p>​    Nginx是一款****轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器****。 ****Nginx 主要提供反向代理、负载均衡、动静分离(静态资源服务)等服务****。下面我简单地介绍一下这些名词。</p>
<p>​    正向代理：某些情况下，****代理我们用户去访问服务器*<em><strong>，</strong></em>*需要用户手动的设置代理服务器的ip和端口号。****正向代理比较常见的一个例子就是 VPN了。</p>
<p>​    反向代理：<em><strong>*是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接受请求，然后将请求转发给内*</strong></em></p>
<p>****部网络的服务器，****并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。</p>
<h2 id="12-1、负载均衡"><a href="#12-1、负载均衡" class="headerlink" title="12.1、负载均衡"></a>12.1、负载均衡</h2><p>​    在高并发情况下需要使用，其原理就是将并发请求分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集</p>
<p>群)共同完成工作任务，从而提高了数据的吞吐量。Nginx支持的****weight轮询（默认）、ip_hash、fair、url_hash这四种负载均衡调度算法****，感兴趣的可以自行查阅。负载均衡相比于反向代理更侧重的时将请求分担到多台服务器上去，所以谈论负载均衡只有在提供某服务的服务器大于两台时才有意义。</p>
<h2 id="12-2、动静分离"><a href="#12-2、动静分离" class="headerlink" title="12.2、动静分离"></a>12.2、动静分离</h2><p>​    动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以</p>
<p>后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p>
<p>22.设计秒杀方案（从高并发、快速响应、高可用三方面回答，高并发（增加网络带宽、DNS域名解析分发多台服务器、使用前置代理服务器ngnix、CDN内容分发、数据库查询优化（读写分离、分库分表）），快速响应（缓存服务器（memcached、redis）、能使用静态页面就用静态页面，减少容器解析、把常访问的图片等内容缓存）、高可用（热备，如数据库服务器的热备、集群监控（如使用zabbix，重点关注IO、内存、带宽和机器load）））</p>
<p>服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。</p>
<p>首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。</p>
<h2 id="12-3、缓存、降级和限流"><a href="#12-3、缓存、降级和限流" class="headerlink" title="12.3、缓存、降级和限流"></a>12.3、缓存、降级和限流</h2><p><em><strong>*在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流：*</strong></em></p>
<p>​    <em><strong>*缓存：缓存的目的是提升系统访问速度和增大系统处理容量*</strong></em></p>
<p>​    <em><strong>*降级：*</strong>***</em>*降级是当服务出现问题或者影响到核心流程时，需要暂时屏蔽掉****<em><strong>*，待高峰或者问题解决后再打开*</strong></em></p>
<p>​    <em><strong>*限流：限流的目的是通过对并发访问/请求进行限速，或者*</strong>***</em>*对一个时间窗口内的请求进行限速来保护系统*<strong><strong><strong>*，一旦达到限制速率则可以*</strong></strong></strong>*拒绝服务、排队或等待、降级等处理****<em><strong>*。*</strong></em></p>
<p>​    计数器法：设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter。缺点：统计的精度太低，无法处理临界问题。如果我在单位时间<em><strong>*1s内的前10ms，已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为“突刺现象”*</strong></em></p>
<p> public boolean grant() {</p>
<p>​    long now = getNowTime();</p>
<p>​    if (now &lt; timeStamp + interval) {</p>
<p>​      // 在时间窗口内</p>
<p>​      reqCount++;</p>
<p>​      // 判断当前时间窗口内是否超过最大请求控制数</p>
<p>​      return reqCount &lt;= limit;</p>
<p>​    } else {</p>
<p>​      timeStamp = now;</p>
<p>​      // 超时后重置</p>
<p>​      reqCount = 1;</p>
<p>​      return true;</p>
<p>​    }</p>
<p>  }</p>
<h2 id="12-4、滑动窗口算法"><a href="#12-4、滑动窗口算法" class="headerlink" title="12.4、滑动窗口算法"></a>12.4、滑动窗口算法</h2><p>将窗口更加细分，每个窗口都有自己的计数器，当总计算达到限定时，限流。这个滑动窗口只是将计算法变得更平滑而已。本质一样。</p>
<p>漏斗法：将容器比作一个漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。</p>
<p>在****令牌桶算法****中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。通过Google开源的guava包，我们可以很轻松的创建一个令牌桶算法的限流器。</p>
<p>Google开源工具包Guava提供了限流工具类<em><strong>*RateLimiter*<em><strong>，该类基于令牌桶算法(Token Bucket)来完成限流，非常易于使用。RateLimiter经常用于限制对一些物理资源或者逻辑资源的访问速率，它支持两种获取permits接口，一</strong></em>*种是如果拿不到立刻返回false（tryAcquire()），一种会阻塞等待一段时间看能不能拿到（tryAcquire(long timeout, TimeUnit unit)）。*</strong></em></p>
<p>缺点：传<em><strong>*统的方式整合RateLimiter 有很大的缺点*<em><strong>：</strong></em>*代码重复量特别大*</strong>***</em>*，而且本身不支持注解方式。****</p>
<h1 id="13、ElasticSearch"><a href="#13、ElasticSearch" class="headerlink" title="13、ElasticSearch"></a>13、ElasticSearch</h1><p>Elasticsearch是一个近乎实时的搜索平台。这意味着从索引文档到可以搜索的时间只有轻微的延迟（通常是1秒）.</p>
<p>集群是一个或多个节点(服务器)的集合. 节点是一个单独的服务器，它是集群的一部分，存储数据，并参与集群的索引和搜索功能。</p>
<p>索引是具有某种相似特征的文档的集合。例如，你可以有一个顾客数据索引，产品目录索引和订单数据索引。文档是可以被索引的基本信息单元。文档用JSON表示,有多个field,如年龄，性别，地址。</p>
<p>Elasticsearch提供了将你的索引细分为多个碎片（或者叫分片）的能力。在创建索引时，可以简单地定义所需的分片数量。每个分片本身就是一个功能完全独立的“索引”，可以驻留在集群中的任何节点上。Shards &amp; Replicas.每个分片又有副本。</p>
<p><em><strong>*正向索引是通过key找value，反向索引则是通过value找key。*</strong></em></p>
<p>首先将文本分割成一系列被称为语汇单元(token)的独立原子元素，此过程即为文档分析，然后建立倒排索引，也就是每个term关键词出现在哪些文档之中。ID TERM DOCUMENT List.，Elasticsearch分别为每个field都建立了一个倒排索引。</p>
<p>Elasticsearch为了能快速找到某个term，将所有的term排个序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。又有一个Term Index，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，可以理<em><strong>*解term index是一颗树*<em><strong>：这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。再结合FST(Finite State Transducers)</strong></em>*的压缩技术，可以使term index缓存到内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了磁盘随机读的次数。*</strong></em></p>
<p><em><strong>*用FST压缩term index外，对posting list也有压缩技巧，如*</strong>***</em>*bitmap****<em><strong>*；*</strong></em></p>
<p><em><strong>*联合索引直接利用跳表(Skip list)的数据结构快速做“与”运算，或者利用上面提到的bitset按位“与”。*</strong></em></p>
<p><em><strong>*shard = hash(document_id) % (num_of_primary_shards)*</strong></em></p>
<h1 id="14、系统设计问题"><a href="#14、系统设计问题" class="headerlink" title="14、系统设计问题"></a>14、系统设计问题</h1><p>​    ****1、****让你系统的设计一个高并发的架构，你会从哪几个方面考虑？</p>
<p>​    <em><strong>*2、一个千万级的APP，你要搞定关注和粉丝列表，你用什么来做。要求最后一个关注的在最前面。新增和取关都要比较快的反馈你怎么做？如果一个人关注了之后，服务器宕机了怎么办？*</strong></em></p>
<p>​    ****3、****设计一个榨汁机类，面向对象怎么设计 </p>
<p>​    ****4、****OOD design：计费停车场</p>
<p>​    5、多个服务器间共享session的解决方案</p>
<p>​    问了new一个对象的加载顺序, 答了从父类到子类的加载过程 静态变量和静态块, 哪个先加载, 答了静态变量。</p>
<p>​    假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写</p>
<p>​    你如果写用InnoDB，读用Myisam的话，主从同步怎么做</p>
<p>​    假设如果有同一时间海量数据入库，你怎么做（期间扯到了鹿晗关晓彤，这种微博大 V给他安排上，还提了消息队列做削峰）</p>
<p>​    你对Elasticsearch有什么了解</p>
<p>  有一个巨大的ip白名单池子，判断一个ip是否命中白名单,散列表 hash一下或者字典树.</p>
<p>​    登录怎样校验密码，海量用户同时登录怎么优化</p>
<p>Cookie 和 Session 的区别，怎样存海量 Session</p>
<p>分布式 Session 问题</p>
<p>显示网站的用户在线数的解决思路</p>
<h1 id="15、大数据相关"><a href="#15、大数据相关" class="headerlink" title="15、大数据相关"></a>15、大数据相关</h1><p>1亿 = 10^8; 1KB = 2^10 = 1024 = 10^3; 1MB = 2^20 = 10 ^ 6 ; 1GB = 2^30 = 10^9；</p>
<p>IB = 8 bit;</p>
<p>2^32 = 40亿；</p>
<p><em><strong>*URL黑名单问题：判断值是否已经存在于集合中：*</strong>***</em>*hash(key) % m****  <em><strong>*哈希函数实现MD*</strong>***</em>*5;****</p>
<p><em><strong>*布隆过滤器解决：用长度为M的位数组*</strong>***</em>*b*<strong><strong><strong>*it*</strong></strong></strong>*Ma*<strong><strong><strong>*p*</strong></strong></strong>*;*<strong><strong><strong>*将所有的值经过K个哈希函数计算之后对m取余，得到在数组中的位置。将K个位置取1。对于新到的*</strong></strong></strong>*url,****<em><strong>*也经过K个哈希函数取余计算数组中的值是否为1，如果全为1，可能存在，有一个为0说明一定不存在。*</strong></em></p>
<p><em><strong>*m和k的大小问题以及容错率的计算：*</strong></em></p>
<p>​    <em><strong>*m*</strong></em> <em><strong>*= - n*</strong></em> <em><strong>***</strong></em> <em><strong>*ln*</strong></em> <em><strong>*p / (ln2)^2 ; m*</strong>***</em>*为位数组长度，n为样本数量，p为容错率**** <em><strong>*0.01%;*</strong></em></p>
<p><em><strong>*如：n*</strong></em> <em><strong>*= 100*</strong>***</em>*亿，p**** <em><strong>*= 0.0.1; m*</strong></em> <em><strong>*=*</strong></em> <em><strong>*20*</strong>***</em>*n**** <em><strong>*= 2000*</strong>***</em>*亿bit**** <em><strong>*= 25 GB;  k =ln2 *  m / n = 14;*</strong></em>  <em><strong>*l*</strong>***</em>*n2 = 0.7**** </p>
<p><em><strong>*2*</strong>***</em>*0*<strong><strong><strong>*亿个3*</strong></strong></strong>*2****<em><strong>*位整数中出现次数最多的数：*</strong></em></p>
<p><em><strong>*用哈希表记录每个整数出现的次数&lt;********key,value&gt;,*</strong>***</em>*一个记录是8B****<em><strong>*;*</strong></em></p>
<p><em><strong>*如果有2*</strong>***</em>*0*<strong><strong><strong>*亿个，就是1*</strong></strong></strong>*6*<strong><strong><strong>*GB*</strong></strong></strong>*;****</p>
<p><em><strong>*所以，我们先将2*</strong>***</em>*0*<strong><strong><strong>*亿的大文件，经过哈希函数，分割为1*</strong></strong></strong>*6****<em><strong>*个小文件。相同的数会分配到同一个文件之中。然后在用哈希表记录每个数出现的次数。然后求每个文件出现最多的次数或者每个文件出现最多的K次，top可以用小顶堆实现。*</strong></em></p>
<p>40亿个非负整数没出现的数：</p>
<p>​    40亿个，如果用哈希表记录每个出现的次数，一个8B，16GB，太大。</p>
<p>​    可以使用位数组，40亿长度的位数组，内存占用为500MB。将40亿个数，一个个的bitmap[indxe] = 1;然后将所有为0的index找出，就是没有出现的数。</p>
<p>​    如果说是10内存找出一个不存在的数呢？</p>
<p>​    500MB变成10内存，原本的40亿长度除以64，就是分割成64个长度为2^22的位数组。</p>
<p>int[] count = new int[64];将40亿个数，每个数 / 2^22，看看他落入哪个区间，count[i]++;</p>
<p>计算每个数的count,看看装满没有，2^22次方，谁大。找到之后，再申请8MB的空间；看看落入这个空间的哪个数少了。</p>
<p>找到100亿个URL重复的URL</p>
<p>​    分流：用哈希函数，将100亿的大文件，转化成小文件，如100个，那么每个近似100兆。然后对url进行哈希表统计，是否出现重复，每个记录8B,那么需要800MB。如果依然是变大了，那就再使用哈希函数分流。</p>
<p>TOPK</p>
<p>​    也是先用哈希函数将大文件转变成小文件，然后用哈希表统计每个数出现的次数。然后对每个小文件的哈希表，使用小顶堆计算topk。然后合在一起再计算topK.</p>
<p>40亿非负整数出现两次的数：</p>
<p>​    40亿<em>2长的位数字，1GB的内存。每两位表示这个树出现的情况。[2</em>num][2*num+1]</p>
<p>第一次出现，标记为01，第二次出现标记为10，第三次出现标记为11.求所有两次出现即标记为10的num;</p>
<p>大数据的中位数，桶排序：</p>
<p>​    长度为2MB（2^21）的整型数组占地8M;分割成大约2148个区间。申请一个arr[2148]的数组，遍历这么多数， num /2^21 看落到了哪个区间，然后count[index]++;从左到右开始数数，找到中位数落在的区间位置。然后再次遍历，对这个位置的数进行哈希统计。然后找到中位数。</p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p><em><strong>*看到上述知乎用户iammutex关于如何正确生成短地址URL的探讨，我们知道了，可以通过发号器的方式正确的生成短地址，生成算法设计要点如下：*</strong></em></p>
<p><em><strong>*（1）利用放号器，初始值为0，对于每一个短链接生成请求，都递增放号器的值，再将此值转换为62进制（a-zA-Z0-9），比如第一次请求时放号器的值为0，对应62进制为a，第二次请求时放号器的值为1，对应62进制为b，第10001次请求时放号器的值为10000，对应62进制为sBc。*</strong></em></p>
<p><em><strong>*（2）将短链接服务器域名与放号器的62进制值进行字符串连接，即为短链接的URL，比如：t.cn/sBc。*</strong></em></p>
<p><em><strong>*（3）重定向过程：生成短链接之后，需要存储短链接到长链接的映射关系，即sBc -&gt; URL，浏览器访问短链接服务器时，根据URL Path取到原始的链接，然后进行302重定向。映射关系可使用K-V存储，比如Redis或Memcache。*</strong></em></p>
<p><em><strong>*七、生成短地址之后如何跳转哪？*</strong></em></p>
<p><em><strong>*对于该部分的讨论，我们可以认为他是整个交互的流程，具体的流程细节如下：*</strong></em></p>
<p><em><strong>*（1）用户访问短链接：<a target="_blank" rel="noopener" href="http://t.cn/RuPKzRW%EF%BC%9B/">http://t.cn/RuPKzRW；\</a>*</strong></em></p>
<p><em><strong>*（2）短链接服务器t.cn收到请求，根据URL路径RuPKzRW获取到原始的长链接（KV缓存数据库中去查找）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xlgen157387/article/details/79863301%EF%BC%9B/">https://blog.csdn.net/xlgen157387/article/details/79863301；\</a>*</strong></em></p>
<p><em><strong>*（3）服务器返回302状态码，将响应头中的Location设置为：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xlgen157387/article/details/79863301%EF%BC%9B/">https://blog.csdn.net/xlgen157387/article/details/79863301；\</a>*</strong></em></p>
<p><em><strong>*（4）浏览器重新向<a target="_blank" rel="noopener" href="https://blog.csdn.net/xlgen157387/article/details/79863301%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%9B/">https://blog.csdn.net/xlgen157387/article/details/79863301发送请求；\</a>*</strong></em></p>
<p><em><strong>*（5）返回响应；*</strong></em></p>
<p><em><strong>*八、短地址发号器优化方案*</strong></em></p>
<p><em><strong>*1、算法优化*</strong></em></p>
<p><em><strong>*采用以上算法，如果不加判断，那么即使对于同一个原始URL，每次生成的短链接也是不同的，这样就会浪费存储空间（因为需要存储多个短链接到同一个URL的映射），如果能将相同的URL映射成同一个短链接，这样就可以节省存储空间了。主要的思路有如下两个：*</strong></em></p>
<p><em><strong>*方案1：查表*</strong></em></p>
<p><em><strong>*每次生成短链接时，先在映射表中查找是否已有原始URL的映射关系，如果有，则直接返回结果。很明显，这种方式效率很低。*</strong></em></p>
<p><em><strong>*方案2：使用LRU本地缓存，空间换时间*</strong></em></p>
<p><em><strong>*使用固定大小的LRU缓存，存储最近N次的映射结果，这样，如果某一个链接生成的非常频繁，则可以在LRU缓存中找到结果直接返回，这是存储空间和性能方面的折中。*</strong></em></p>
<p><em><strong>*2、可伸缩和高可用*</strong></em></p>
<p><em><strong>*如果将短链接生成服务单机部署，缺点一是性能不足，不足以承受海量的并发访问，二是成为系统单点，如果这台机器宕机则整套服务不可 用，为了解决这个问题，可以将系统集群化，进行“分片”。*</strong></em></p>
<p><em><strong>*在以上描述的系统架构中，如果发号器用Redis实现，则Redis是系统的瓶颈与单点，因此，利用数据库分片的设计思想，可部署多个发号器实例，每个实例负责特定号段的发号，比如部署10台Redis，每台分别负责号段尾号为0-9的发号，注意此时发号器的步长则应该设置为10（实例个数）。*</strong></em></p>
<p><em><strong>*另外，也可将长链接与短链接映射关系的存储进行分片，由于没有一个中心化的存储位置，因此需要开发额外的服务，用于查找短链接对应的原始链接的存储节点，这样才能去正确的节点上找到映射关系。*</strong></em></p>
<p><em><strong>*分布式全局唯一ID:雪花算法得出的ID,有序*<em><strong>，唯一，快速。</strong></em>*64位：最高位预留+*</strong>***</em>*毫秒级时间41位+机器ID 10位+毫秒内序列12位；41位时间能用69年。机器ID支持2^10=1024台机器分布。****</p>
<p>与之相对的数据库自增ID:缺陷：****高并发下插入数据需要事务机制，对数据库压力大。大表不能做水平分表****，否则增删容易出错。</p>
<p>UUID：<em><strong>*无序，太长、没法排序、使数据库性能降低s；*</strong></em></p>
<p>有一个无序整型数组，如何求出该数组排序后的任意两个相邻元素的最大差值？（桶排序，尽量分散，桶的数量为 （最大 - 最小）/ 元素个数）</p>
<p>.讲一下IOC和AOP。</p>
<p>Nginx</p>
<p>AVA异常，分类，具体都有哪些？</p>
<p>线程与进程的区别？为什么要有线程？</p>
<p>GMS 与 G1 的区别、应用场景</p>
<p>反射机制（原理、使用场景、Spring 注入）</p>
<p>消息队列，消费者运行速度不一，如何控制数据的同步（保证插入先于删除）</p>
<p>Tomcat的双亲模型，破坏双亲的的三种出现过的，OSGI的破坏双亲的模型</p>
<p>手写线程池需要哪些参数</p>
<p>核心 10 队列 1000 最大 100 的情况线程池怎么处理</p>
<p>JDK 8 与先前版本的区别</p>
<p>讲迭代的区别顺势还讲了快速失败和安全失败</p>
<p>线程间的通信方式（操作系统层面，信号量等等）</p>
<p>List有哪些，怎样做到线程安全：</p>
<p>ThreadLocal：</p>
<p>ThreadLocal 是安全的吗？讲讲原理分析与使用场景、内存泄漏、弱引用</p>
<p>Java怎么做到跨平台的</p>
<p>java怎么把.class文件进行反编译的</p>
<p>安装Java都需要安装哪些东西</p>
<p>Java虚拟机是如何找到类方法中的Main函数的</p>
<p>\1. hashmap 和hash table 和concurrent hashmap<br>\2. jmm模型<br>自己聊 volatile synclock reentreenlock aqs组件 cas automic原子类</p>
<p><em><strong>*线程池7大参数*</strong></em>  我给了个场景说明了参数的作用</p>
<p><em><strong>*corePoolSize：核心池的大小：*</strong></em></p>
<p>****maximumPoolSize：线程池最大线程数****，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</p>
<p><em><strong>*keepAliveTime：空闲的线程保留的时间。*</strong></em></p>
<p><em><strong>*TimeUnit：空闲线程的保留时间单位。*</strong></em></p>
<p><em><strong>*BlockingQueue<Runnable>：阻塞队列*</strong></em></p>
<p><em><strong>*ThreadFactory：线程工厂，用来创建线程*</strong></em></p>
<p><em><strong>*RejectedExecutionHandler：队列已满，而且任务量大于最大线程的异常处理策略*</strong></em></p>
<p>redis数据类型 zset怎么用</p>
<p><em><strong>*nginx集群怎么做 负载均衡算法有哪些，单点故障怎么办*</strong></em></p>
<p>****普通轮询算法、比例加权轮询、ip路由****负载、基于服务器响应时间负载分配、根据域名负载。</p>
<p>Nginx+keepalived双机实现nginx反向代理服务的高可用,一台nginx挂掉之后不影响应用也不影响内网访问外网。</p>
<p><em><strong>*用Keepalived搭建双Nginx server集群 防止单点故障*</strong></em></p>
<p>项目的 QPS 是多少：</p>
<p>讲讲 HashSet：</p>
<p>Spring AOP 有切点，切面，还有哪些</p>
<p>图的最短路径算法：</p>
<p>****深度或广度优先搜索算法****，</p>
<p>****费罗伊德算法****，最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转…….允许经过1~n号所有顶点进行中转，</p>
<p>****迪杰斯特拉算法****，</p>
<p>Bellman-Ford 算法。</p>
<p><em><strong>*MySQL的MVCC：*</strong></em></p>
<p>Integer缓冲机制：</p>
<p>mybatis怎么防止sql注入</p>
<p><em><strong>*spring解决循环依赖*</strong></em></p>
<p><em><strong>*（1）构造器的循环依赖 构造器的循环依赖问题无法解决，只能抛出异常。*</strong></em></p>
<p>****（2）setter注入构成的循环依赖，****spring设计的机制主要就是解决这种循环依赖</p>
<p> <em><strong>*3、prototype作用域bean的循环依赖。无法解决*</strong></em></p>
<p>步骤一：b****eanA进行初始化，并且将自己进行初始化的状态记录下来，并提前向外暴露一个单例工程方法，****从而使其他bean能引用到该bean（可能读完这一句，您仍然心存疑惑，没关系，继续往下读）</p>
<p>步骤二：beanA中有beanB的依赖，<em><strong>*于是开始初始化beanB。*</strong></em></p>
<p>步骤三：初始化beanB的过程中又发现beanB依赖了beanA,于是又进行beanA的初始化，这时发<em><strong>*现beanA已经在进行初始化了，程序发现了存在的循环依赖，然后通过步骤一中暴露的单例工程方法拿到beanA的引用*<em><strong>（注意，此时的beanA只是完成了构造函数的注入但为完成其他步骤），从而beanB拿到beanA的引用，完成注入，完成了初始化，如此beanB的引用也就可以被beanA拿到，</strong></em>*从而beanA也就完成了初始化。*</strong></em></p>
<p>spring进行bean的加载的时候，首先进行bean的初始化（调用构造函数），然后进行属性填充。在这两步中间，spring对bean进行了一次状态的记录</p>
<p><em><strong>*不要使用基于构造函数的依赖注入，可以通过以下方式解决：*</strong></em></p>
<p>​    <em><strong>*1.在字段上使用@Autowired注解，让Spring决定在合适的时机注入*</strong></em></p>
<p>​    <em><strong>*2.用基于setter方法的依赖注入。*</strong></em></p>
<p><em><strong>*聚簇索引和非聚簇索引*</strong></em></p>
<p><em><strong>*对于聚簇索引存储来说，行数据和主键B+树存储在一起，辅助键B+树只存储辅助键和主键，主键和非主键B+树几乎是两种类型的树。对于非聚簇索引存储来说，主键B+树在叶子节点存储指向真正数据行的指针，而非主键。*</strong></em></p>
<p>1 spring aop</p>
<p><em><strong>*3. spring mvc 流程*</strong></em></p>
<p>4.mybatis分页</p>
<p>​    <em><strong>*sql分页 limit + offset 分页：*</strong></em></p>
<p>​    <em><strong>*pagehelper分页插件：拦截器分页。*</strong></em></p>
<p>\6. mysql支持大小写查询</p>
<p>​    <em><strong>*MySQL查询是不区分大小写的*<em><strong>！这可真的是惊呆我了，虽然知道一般情况下，关键字是不区分大小写的，但是没想到连</strong></em>*要查询的参数都是不区分大小写的：*</strong></em></p>
<p>​    <em><strong>*Mysql默认的字符检索策略：utf8_general_ci，表示不区分大小写；utf8_general_cs表示区分大小写，utf8_bin表示二进制比较，同样也区分大小写*</strong></em></p>
<p><em><strong>*7. innodb和 myisam的区别*</strong></em></p>
<p><em><strong>*8 solr或者es介绍一下（倒排索引；有哪些索引结构）*</strong></em></p>
<p>****项目中用到的算法****（排序  查找）， 设计模式</p>
<p>http常见请求头</p>
<p>mybatis传list时xml文件里怎么写，用哪个标签</p>
<p><em><strong>*线程池参数，什么情况下会达到最大线程数量*</strong></em></p>
<p>cookie包括哪两种</p>
<p><em><strong>*SpringMVC 工作原理、内部流程*</strong></em></p>
<p>MyBatis （缓存机制，一级、二级原理和作用，映射是怎么实现的，XML 怎么对应到 Mapper 代理模式）</p>
<p>****防止sql注入****：MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。</p>
<p>mybatis的查询缓存分为一级缓存和二级缓存，一级缓存是SqlSession级别的缓存，二级缓存时mapper级别的缓存，二级缓存是多个SqlSession共享的;</p>
<p>当在同一个SqlSession中执行两次相同的sql语句时，第一次执行完毕会将数据库中查询的数据写到缓存（内存）中，第二次查询时会从缓存中获取数据，不再去底层进行数据库查询，从而提高了查询效率。如果SqlSession执行了DML操作（insert、update、delete），并执行commit（）操作，mybatis则会清空SqlSession中的一级缓存,避免脏读现象。</p>
<p>Mybatis 的二级缓存是 Mapper 级别的缓存，默认不开启，需手工配置。其存储作用域为 Mapper，也就是同一个 namespace 的 mappe.xml; 当一个sqlseesion执行了一次select后，在关闭此session的时候，会将查询结果缓存到二级缓存。当另一个sqlsession执行select时，首先会在他自己的一级缓存中找，如果没找到，就回去二级缓存中找，找到了就返回，就不用再去数据库了。</p>
<p>MySQL 怎么分页：</p>
<p><em><strong>*用limit + offset: SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15*</strong></em></p>
<h1 id="16、Linux相关"><a href="#16、Linux相关" class="headerlink" title="16、Linux相关"></a>16、Linux相关</h1><p><em><strong>*查看进程PID*</strong></em>  </p>
<p><em><strong>*根据名称匹配*</strong>***</em>*：Ps -****<em><strong>*ef | grep xxxx*</strong></em></p>
<p><em><strong>*根据端口号 ：*</strong></em> <em><strong>*lsof -i:5000*</strong></em></p>
<p><em><strong>*关闭xxx的进程 ： kill -9 xxxx;*</strong></em> <em><strong>*9：SIGKILL，强制中断一个进程的进行;*</strong></em></p>
<p><em><strong>*top*</strong></em> <em><strong>*命令是Linux下常用的性能分析工具，*</strong>***</em>*能够实时显示系统中各个进程的资源占用状况****<em><strong>*，类似于Windows的任务管理器;*</strong></em></p>
<p><em><strong>*chmod命令,*</strong></em> <em><strong>*chown,chgrp*</strong></em></p>
<p><em><strong>*cat　用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示.more,less，按页查看，前翻后翻。*</strong></em></p>
<p><em><strong>*tail:*</strong></em> <em><strong>*从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容.*</strong></em></p>
<p><em><strong>*diff 命令用于比较两个文件或目录的不同*</strong></em></p>
<p><em><strong>*scp 命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令;*</strong></em></p>
<p><em><strong>*ssh远程登录；*</strong></em></p>
<p><em><strong>*ping;*</strong></em> <em><strong>*ifconfig*</strong></em></p>
<p><em><strong>*grep命令:该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来*</strong></em></p>
<p><em><strong>*grep -n ‘要查找的字符串’  被查的文件file:返回行数；*</strong></em></p>
<p><em><strong>*cp复制，rm删除，mv移动，tar解压缩，mkdir，rmdir,*</strong></em></p>
<h1 id="17、正则表达式"><a href="#17、正则表达式" class="headerlink" title="17、正则表达式"></a>17、正则表达式</h1><p>****^****匹配输入字符串开始的位置，$匹配输入字符串结尾的地方。</p>
<p>*，匹配前面字符0次或者多次。+，一次或多次匹配。？，零次或一次匹配。</p>
<p>{n},匹配前面n次，{n,}至少匹配n次。{n,m}至少匹配n次，至多匹配m次。</p>
<p>？：如果跟在其他通配符后面，表示非贪心搜索。其他的默认贪心匹配。O+?,表示只匹配一次o.而默认o+匹配所有o;</p>
<p>.，匹配任意字符。 X | Y，表示或，x或者y. [xyz]:字符集中的任意一个。[^xyz],反向字符集，匹配不包含字符的一个。</p>
<p>[a-z],匹配指定范围的任意字符。[^a-z]匹配非范围内的字符。 \d，数字字符匹配，[0-9]; \D,非数字字符匹配[^0-9];</p>
<p>\s,匹配任何空白字符。\S，匹配非空白字符。\w字母数字下划线，\W，非字符数字下划线。</p>
<p>常用正则表示式：</p>
<p>任意个数字：^[0-9]<em>$;  n位数字：^\d{n}$; 中文：[\u4e00-\u9fa5]；非零开头的最多带两位小数的数字：^([1-9][0-9]</em>)+(.[0-9]{1,2})?$；带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$；由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 。<em><strong>*Email地址：*</strong>***</em>*^\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*$****</p>
<p>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$</p>
<p>强密码(必须包含****大小写字母和数字的组合***<em>，不能使用特殊字符，长度在8-10之间)：^(?=.<em>\d)(?=.</em>[a-z])(?=.</em>[A-Z]).{8,10}$</p>
<p>IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用)</p>
<p>IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))</p>
<h1 id="18、设计模式"><a href="#18、设计模式" class="headerlink" title="18、设计模式"></a>18、设计模式</h1><p><em><strong>*创建型模式、结构型模式和行为型模式 3 种。*</strong></em></p>
<p>****创建型模式：用于描述“怎样创建对象”*<em><strong>，它的主要特点是“</strong></em>*将对象的创建与使用分离”*<em><strong>。GoF 中提供了</strong></em>*单例、原型、工厂方法、抽象工厂、建造者****等 5 种创建型模式。</p>
<p>****结构型模式*<em><strong>：用于描述如何将</strong></em>*类或对象按某种布局组成更大的结构*<em><strong>，GoF 中提供了</strong></em>*代理、适配器、桥接、装饰****、外观、享元、组合等 7 种结构型模式。</p>
<p>****行为型模式*<em><strong>：用于描述类或</strong></em>*对象之间怎样相互协作共同完成单个对象都无法单独完成的任务*<em><strong>，以及怎样分配职责。GoF 中提供了模板方法、</strong></em>*策略*<em><strong>、命令、</strong></em>*职责链*<em><strong>、状态、</strong></em>*观察者*<em><strong>、中介者、</strong></em>*迭代器、****访问者、备忘录、解释器等 11 种行为型模式。</p>
<p>****单例（Singleton）模式：某个类只能生成一个实例****，该类提供了一个全局访问点供外部获取该实例，</p>
<p>****工厂方法（Factory Method）模式*<em><strong>：</strong></em>*定义一个用于创建产品的接口****，由子类决定生产什么产品。</p>
<p>****抽象工厂（AbstractFactory）模式*<em><strong>：提供一个创建</strong></em>*产品族的接口*<em><strong>，其</strong></em>*每个子类可以生产一系列相关的产品****。</p>
<p><em><strong>*代理（Proxy）模式*<em><strong>：为某对象提供一种代理以控制对该对象的访问。即</strong></em>*客户端通过代理间接地访问该对象，从而限制、*</strong>***</em>*增强或修改该对象的一些特性。****</p>
<p><em><strong>*适配器（Adapter）模式*<em><strong>：将一个类的接口转换成客户希望的另外一个接口，使得原本由于</strong></em>*接口不兼容而不能一起工作的那些类能一起工作。*</strong></em></p>
<p>****装饰（Decorator）模式：动态的给对象增加一些职责，****即增加其额外的功能。</p>
<p>****策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，****且算法的改变不会影响使用算法的客户。</p>
<p>****职责链（Chain of Responsibility）模式*<em><strong>：</strong></em>*把请求从链中的一个对象传到下一个对象，直到请求被响应为止****。通过这种方式去除对象之间的耦合。</p>
<p><em><strong>*观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。*</strong></em></p>
<p><em><strong>*迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。*</strong></em></p>
<p><em><strong>*UML图： 三格，上面类名，中间属性变量 -+#~表可见范围。下面是方法。接口有个O,没有正方形圈住。*</strong></em></p>
<p><em><strong>*依赖关系：——*</strong>***</em>*à**** <em><strong>*A中引用了B的对象。关联关系 ——&gt;如老师教学生这类关系*</strong></em></p>
<p><em><strong>*聚合关系：——白菱形。整体和部分关系，has-a;只不过部分可脱离整体存在，菱形的那边是整体。如汽车和轮子。*</strong></em></p>
<p><em><strong>*组合关系：——实体黑菱形。整体和部分的关系，部分不可脱离整体。黑菱形是整体。如头和嘴。*</strong></em></p>
<p><em><strong>*继承关系：——白三角，继承关系，老师继承人。*</strong></em></p>
<p><em><strong>*实现关系：——白三角：类实现了接口。*</strong></em></p>
<p><em><strong>*单例模式：*</strong>***</em>*生成单例的四种方式：懒汉模式，饿汉模式，多线程双重检验模式，静态内部类？****</p>
<p>1、当一个类只要求生成一个对象的是场景。2、当对象需要被共享的场合。3、类对象需要频繁实例化又被频繁销毁。</p>
<p>关键点在于：隐藏构造方法， 开放一个静态方法，返回实例对象。有懒汉模式，饿汉模式，和多线程双重检验模式。</p>
<p><em><strong>*工厂模式：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体工厂实现类中。抽象工厂模式是工厂模式方法的升级版本，工厂方法模式只能产生一种产品，而抽象工厂模式可以生产多个等级的产品。*</strong></em></p>
<p><em><strong>*代理模式:在访问对象和目标对象之间创建一个代理对象，代理对象持有对代理对象的引用，访问对象通过代理对象间接访问目标对象。而且代理对象可以扩展目标对象的功能，还一定程度了降级了系统的耦合度。spring*</strong></em> <em><strong>*AOP*</strong>***</em>*是基于代理实现的，当被代理对象实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象， Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理.****</p>
<p>****原型（Prototype）模式的定义如下：****用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。用Clone()方法直接赋值对象。</p>
<p>****工厂模式*<em><strong>：定义一个创建产品对象的</strong></em>*工厂接口*<em><strong>，将产品对象的</strong></em>*实际创建工作推迟到具体子工厂类当中****。可以随时增加新的具体产品类和对应的具体工厂类。</p>
<p><em><strong>*抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。*</strong></em></p>
<p>****代理模式的定义****：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。代理对象可以扩展目标对象的功能；客户端与目标对象分离，在一定程度上降低了系统的耦合度；代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</p>
<p>动态代理：</p>
<p>****适配器模式（Adapter）****包含以下主要角色。</p>
<p>​    ****目标（Target）接口：****当前系统业务所期待的接口，它可以是抽象类或接口。</p>
<p>​    ****适配者（Adaptee）类：****它是被访问和适配的现存组件库中的组件接口。</p>
<p>​    ****适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，****让客户按目标接口的格式访问适配者。</p>
<p>****装饰（Decorator）模式的定义*<em><strong>：指在不改变现有对象结构的情况下，</strong></em>*动态地给该对象增加一些职责****（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰模式主要包含以下角色。</p>
<p>抽象构件（Component）角色：定义一个抽象接口以规范准备<em><strong>*接收附加责任的对象。*</strong></em></p>
<p>具体构件（Concrete   Component）角色：实现抽象构件，<em><strong>*通过装饰角色为其添加一些职责。*</strong></em></p>
<p>抽象装饰（Decorator）角色：****继承抽象构件，并包含具体构件的实例****，可以通过其子类扩展具体构件的功能。</p>
<p>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</p>
<p><em><strong>*模板方法模式：*</strong></em></p>
<p>模板方法（Template Method）模式的定义如下：****定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中****，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<h1 id="19、Spring中用到的设计模式"><a href="#19、Spring中用到的设计模式" class="headerlink" title="19、Spring中用到的设计模式"></a>19、Spring中用到的设计模式</h1><p><em><strong>*工厂设计模式*</strong></em></p>
<p>​    Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。</p>
<p>​    BeanFactory 采用了工厂设计模式，负责读取 bean 配置文档，管理 bean 的加载，实例化，维护 bean 之间的依赖关系，负责 bean 的生命周期。BeanFactroy采用的是****延迟加载形式来注入Bean的*<em><strong>，即只有在使</strong></em>*用到某个Bean*<em><strong>时(调用getBean())，</strong></em>*才对该Bean进行加载实例化****。</p>
<p>​    ApplicationContext 除了提供上述 BeanFactory 所能提供的功能之外，还提供了更完整的框架功能：国际化支持、资源访问，比如访问URL和文件、事件机制，同时加载多个配置文件等。ApplicationContext 在解析配置文件时对配置文件中的所有对象都初始化了，getBean() 方法只是获取对象的过程。</p>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="*单例设计模式*"></a><em><strong>*单例设计模式*</strong></em></h2><p>​    Spring 中 bean 的默认作用域就是 singleton(单例)的。单例的好处：对于频繁使用的对象，可以省略创建对象所花费的时间；new 操作的次数减少，这将减轻 GC 压力，缩短 GC 停顿时间。</p>
<p>​    Spring 通 过 ConcurrentHashMap 实现单例注册表的特殊方式实现单例模式。</p>
<p><em><strong>*简单来说使用单例模式可以带来下面几个好处:*</strong></em></p>
<p>​    <em><strong>*对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统*</strong></em></p>
<p><em><strong>*开销；*</strong></em></p>
<p>​    <em><strong>*由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。*</strong></em></p>
<p><em><strong>*class Singleton{*</strong></em></p>
<p>  <em><strong>*private volatile static Singleton instance;*</strong></em></p>
<p>  <em><strong>*private Singleton(){*</strong></em></p>
<p>  <em><strong>*}*</strong></em></p>
<p>  <em><strong>*public static Singleton getInstance(){*</strong></em></p>
<p>​    <em><strong>*if (instance == null){*</strong></em></p>
<p>​      <em><strong>*synchronized (Singleton.class){*</strong></em></p>
<p>​        <em><strong>*if (instance == null)*</strong></em></p>
<p>​          <em><strong>*instance = new Singleton();*</strong></em></p>
<p>​      <em><strong>*}*</strong></em></p>
<p>​    <em><strong>*}*</strong></em></p>
<p>​    <em><strong>*return instance;*</strong></em></p>
<p>  <em><strong>*}*</strong></em></p>
<p><em><strong>*}*</strong></em></p>
<p><em><strong>*//懒汉模式，等你调用的时候才开始创建实例；懒加载启动快，资源占用小，使用时才实例化，无锁。非线程安全*</strong></em></p>
<p><em><strong>*class Singleton1{*</strong></em></p>
<p>  <em><strong>*private static Singleton1 instance;*</strong></em></p>
<p>  <em><strong>*private Singleton1(){*</strong></em></p>
<p>  <em><strong>*}*</strong></em></p>
<p>  <em><strong>*private static Singleton1 getInstacne(){*</strong></em></p>
<p>​    <em><strong>*if (instance == null)*</strong></em></p>
<p>​      <em><strong>*instance = new Singleton1();*</strong></em></p>
<p>​    <em><strong>*return instance;*</strong></em></p>
<p>  <em><strong>*}*</strong></em></p>
<p><em><strong>*}*</strong></em></p>
<p><em><strong>*//饿汉模式：*</strong></em></p>
<p><em><strong>*//优点：饿汉模式天生是线程安全的，使用时没有延迟。*</strong></em></p>
<p><em><strong>*//缺点：启动时即创建实例，启动慢，有可能造成资源浪费。*</strong></em></p>
<p><em><strong>*class Singleton2{*</strong></em></p>
<p>  <em><strong>*private static Singleton2 instance = new Singleton2();*</strong></em></p>
<p>  <em><strong>*private Singleton2(){}*</strong></em></p>
<p>  <em><strong>*public Singleton2 getInstance(){*</strong></em></p>
<p>​    <em><strong>*return instance;*</strong></em></p>
<p>  <em><strong>*}*</strong></em></p>
<p><em><strong>*}*</strong></em></p>
<p><em><strong>*// Effective Java 第一版推荐写法*</strong></em></p>
<p><em><strong>*class Singleton23 {*</strong></em></p>
<p>  <em><strong>*private static class SingletonHolder {*</strong></em></p>
<p>​    <em><strong>*private static final Singleton23 INSTANCE = new Singleton23();*</strong></em></p>
<p>  <em><strong>*}*</strong></em></p>
<p>  <em><strong>*private Singleton23 (){}*</strong></em></p>
<p>  <em><strong>*public static final Singleton23 getInstance() {*</strong></em></p>
<p>​    <em><strong>*return SingletonHolder.INSTANCE;*</strong></em></p>
<p>  <em><strong>*}*</strong></em></p>
<p><em><strong>*}*</strong></em></p>
<h2 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="*代理设计模式*"></a><em><strong>*代理设计模式*</strong></em></h2><p>​    ****AOP*<em><strong>能够将那些与业务无关，</strong></em>*却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来*<em><strong>，便于</strong></em>*减少系统的重复代码*<em><strong>，</strong></em>*降低模块间的耦合度*<em><strong>，并</strong></em>*有利于未来的可拓展性和可维护性****。</p>
<p>​    <em><strong>*Spring AOP 就是基于动态代理的,*</strong></em> 如果要代理的对象，实现了某个接口，那么Spring AOP会使用****JDK Proxy****，去创建代理对象，而对于没有实现接口的对象， Spring AOP会使用 <em><strong>*Cglib*</strong></em> 生成一个被代理对象的子类来作为代理.</p>
<p>​    使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<p>​    <em><strong>*Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。*</strong></em> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作. Spring AOP 已经集成了 AspectJ , 如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="*模板方法*"></a><em><strong>*模板方法*</strong></em></h2><p>​    <em><strong>*模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。*</strong></em></p>
<p>​    Spring 中 jdbcTemplate、hibernateTemplate <em><strong>*等以 Template 结尾的对数据库操作的类，*<em><strong>它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是</strong></em>*使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。*</strong></em></p>
<h2 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="*观察者模式：*"></a><em><strong>*观察者模式：*</strong></em></h2><p>​    观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>
<p><em><strong>*Spring 事件驱动模型中的三种角色：事件角色、事件监听者角色、事件发布角色、*</strong></em></p>
<p>****事件角色：****ApplicationEvent (org.springframework.context包下)充当事件的角色,这是一个抽象类。</p>
<p>****事件监听者角色：****ApplicationListener 充当了事件监听者角色，它是一个接口，里面只定义了一个 onApplicationEvent（ApplicationEvent E）方法来处理ApplicationEvent。</p>
<p><em><strong>*ApplicationEventPublisher 充当了事件的发布者，它也是一个接口。publishEvent(ApplicationEvent event)*</strong></em></p>
<p>流程：</p>
<p>定义一个事件: 实现一个继承自 ApplicationEv ent，并且写相应的构造函数；</p>
<p>定义一个事件监听者：实现 ApplicationListener 接口，重写 onApplicationEvent() 方法；</p>
<p>使用事件发布者发布消息: 可以通过 ApplicationEventPublisher 的 publishEvent() 方法发布消息</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="*适配器模式:*"></a><em><strong>*适配器模式:*</strong></em></h2><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
<p><em><strong>*spring MVC中的适配器模式:*</strong></em> 在Spring MVC中，DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。</p>
<p>Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是AdvisorAdapter。通知有很多类型：前置通知、后置通知、环绕通知、返回通知、异常通知。每种通知都有相对应的拦截器。Spring预定义的通知要通过对应的适配器，适配成 MethodInterceptor接口(方法拦截器)类型的对象（如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice）。</p>
<h2 id="装饰者模式："><a href="#装饰者模式：" class="headerlink" title="*装饰者模式：*"></a><em><strong>*装饰者模式：*</strong></em></h2><p>​    装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 InputStream家族，InputStream 类下有 FileInputStream (读取文件)、BufferedInputStream (增加缓存,使读取文件速度大大提升)等子类都在不修改InputStream 代码的情况下扩展了它的功能。Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。</p>
<p><em><strong>*集合重复问题:*</strong></em></p>
<p>​    <em><strong>*位图法：集合的最大元素max,创建max+1的数组，如果遇到元素5，设nums[6] = 1,下次还这样时，如果nums[i]=1,表示已经存在。还可以排序。*</strong></em></p>
<p>​    <em><strong>*布隆过滤器：检测一个元素是否属于一个集合。当他不属于这个集合时，那一定数不属于的。如果判断属于，那不一定。实现原理:位数组和Hash结合。M位的位数组，初始化为0.定义k个不同的hash函数，每个函数都将集合中的元素映射到位数组的一位。向集合中插入元素时，k个哈希得到k位。将这些位设为1.*</strong></em></p>
<p>​    <em><strong>*新的被检测元素时，看这k位是否全为1.有一个为0，说明不在集合中。*</strong></em></p>
<p>​    </p>
<h1 id="20、TOPK问题"><a href="#20、TOPK问题" class="headerlink" title="20、TOPK问题"></a>20、TOPK问题</h1><p>​    <em><strong>*最小堆，建立一个最小堆。一个个遍历。中序遍历最终的最小堆；mlogm建堆m大小。 时间复杂度nmlogm*</strong></em></p>
<p>​    <em><strong>*分治：将大文件分成小文件，每个小文件用快排算出topk, 然后合并一块求topk.*</strong></em></p>
<p><em><strong>*频率TOPK, 将数据集按照hash的方法分解成多个小数据集，然后用trie或者hash统计每个小数据集的频率，然后用小顶堆算出每个数据集中出现频率最高的K个，然后算出所有的topK.*</strong></em></p>
<p><em><strong>*去重：*</strong></em></p>
<p>​    <em><strong>*位图法： 9位数的话，99999999+1大小的位数组。*</strong></em></p>
<p><em><strong>*排序问题：*</strong></em></p>
<p>​    <em><strong>*数据库排序法：文本文件导入数据库，数据库索引排序。*</strong></em></p>
<p>​    <em><strong>*分治法：分治排序，然后集合。*</strong></em></p>
<p>​    <em><strong>*位图法：形成max+1的位数组，填入，然后从大到小开始排*</strong></em></p>
<h1 id="21、SpringBoot框架相关问题总结"><a href="#21、SpringBoot框架相关问题总结" class="headerlink" title="21、SpringBoot框架相关问题总结"></a>21、SpringBoot框架相关问题总结</h1><p>​    Spring Boot是Spring开源组织下的子项目，<em><strong>*是Spring组件一站式解决方法。主要是简化spring的使用难度，简化了配置复杂度，使开发者快速上手。优点有：独立运行，简化配置，自动配置，上手容易。*</strong></em></p>
<p>Spring Boot 的核心配置文件有哪几个？它们的区别是什么？</p>
<p>​    <em><strong>*application*</strong></em> 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。</p>
<p>​    .properties 和 .yml</p>
<h2 id="Spring-Boot-的核心注解是哪个："><a href="#Spring-Boot-的核心注解是哪个：" class="headerlink" title="Spring Boot 的核心注解是哪个："></a>Spring Boot 的核心注解是哪个：</h2><p><em><strong>*@*</strong>***</em>*SpringBootApplication****<em><strong>*，他包含了三个注解：*</strong></em></p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p>​    从Spring3.0，@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。</p>
<p>​    <em><strong>*@SpringBootConfiguration 也是来源于 @Configuration，*</strong>***</em>*二者功能都是将当前类标注为配置类，并将当前类里以 @Bean 注解标记的方法的实例注入到srping容器中，实例名即为方法名。****</p>
<p>@ComponentScan：Spring组件扫描。</p>
<p>​    <em><strong>*用于将一些标注了特定注解的bean定义*</strong>***</em>*批量采集注册到Spring的IoC容器之中，这****<em><strong>*些特定的注解大致包括：@Controller@Entity@Component@Service@Repository*</strong></em></p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项。</p>
<p><em><strong>*@EnableAutoConfiguration 注解启用自动配置，*</strong>***</em>*其可以帮助 SpringBoot 应用将所有符合条件的 @Configuration 配置都加载到当前 IoC 容器之中，****</p>
<h2 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="*开启 Spring Boot 特性有哪几种方式？*"></a><em><strong>*开启 Spring Boot 特性有哪几种方式？*</strong></em></h2><p><em><strong>*1）继承spring-boot-starter-parent项目2）导入spring-boot-dependencies项目依赖*</strong></em></p>
<p><em><strong>*SpringBoot内置Tomcat/Jetty容器，可以独立运行。*</strong></em></p>
<h2 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="*运行 Spring Boot 有哪几种方式？*"></a><em><strong>*运行 Spring Boot 有哪几种方式？*</strong></em></h2><p><em><strong>*1）打包用命令或者放到容器中运行*</strong></em></p>
<p><em><strong>*3）直接执行 main 方法运行*</strong></em></p>
<p>2）用 Maven/ Gradle 插件运行</p>
<h2 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h2><p>​    <em><strong>*扫描所有具有META-INF/spring.factories的jar包。spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件。*</strong></em></p>
<p>​    <em><strong>*这个spring.factories文件也是一组一组的key=value的形式，其中一个key是EnableAutoConfiguration类的全类名，而它的value是一个xxxxAutoConfiguration的类名的列表，这些类名以逗号分隔。*</strong></em></p>
<p>​    <em><strong>*这个@EnableAutoConfiguration注解通过@SpringBootApplication被间接的标记在了Spring Boot的启动类上。在SpringApplication.run(…)的内部就会执行selectImports()方法，找到所有JavaConfig自动配置类的全限定名对应的class，然后将所有自动配置类加载到Spring容器中。*</strong></em></p>
<p>​    <em><strong>*Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。*</strong></em></p>
<h2 id="Starters"><a href="#Starters" class="headerlink" title="*Starters*"></a><em><strong>*Starters*</strong></em></h2><p>​    Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring及其他技术，而不需要到处找示例代码和依赖包。Starters包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。</p>
<p>​    </p>
<h2 id="Spring-Boot读取配置的几种方式"><a href="#Spring-Boot读取配置的几种方式" class="headerlink" title="*Spring Boot读取配置的几种方式:*"></a><em><strong>*Spring Boot读取配置的几种方式:*</strong></em></h2><p>​    <em><strong>*@*</strong>***</em>*Value****注解读取方式: @Value(“${info.address}”)</p>
<p>​    <em><strong>*@*</strong>***</em>*ConfigurationProperties****注解读取方式: @ConfigurationProperties(prefix = “info”)</p>
<p>​        </p>
<p>​    <em><strong>*读取指定文件资源目录下建立config/db-config.properties:*</strong></em></p>
<p>@PropertySource+@ConfigurationProperties注解读取方式]</p>
<p>@PropertySource+@Value注解读取方式</p>
<p>Spring Boot支持Java Util Logging,Log4j2,Lockback作为日志框架，如果你使用starters启动器，S****pring Boot将使用Logback作为默认日志框架****。无论使用哪种日志框架，Spring <em><strong>*Boot都支持配置将日志输出到控制台或者文件中。*</strong></em></p>
<p>spring-boot-starter启动器包含spring-boot-starter-logging<em><strong>*启动器并集成了slf4j日志抽象及Logback日志框架。*</strong></em></p>
<h2 id="SpringBoot热部署："><a href="#SpringBoot热部署：" class="headerlink" title="*SpringBoot热部署：*"></a><em><strong>*SpringBoot热部署：*</strong></em></h2><p>Spring Boot提供了一个名为spring-boot-devtools的模块来使应用支持热部署，提高开发者的开发效率，无需手动重启Spring Boot应用。</p>
<p>添加依赖模块devtools,在配置文件中自定义。</p>
<p>\1. # 热部署开关，false即不启用热部署</p>
<p>\2. spring.devtools.restart.enabled: true</p>
<p>\3. </p>
<p>\4. # 指定热部署的目录</p>
<p>\5. #spring.devtools.restart.additional-paths: src/main/java</p>
<p>\6. </p>
<p>\7. # 指定目录不更新</p>
<p>\8. spring.devtools.restart.exclude: test/**</p>
<p><em><strong>*pring Boot 可以兼容老 Spring 项目吗，如何做？*</strong></em></p>
<p><em><strong>*可以兼容，使用 @ImportResource 注解导入老 Spring 项目配置文件*</strong></em></p>
<h1 id="22、Mybatis"><a href="#22、Mybatis" class="headerlink" title="22、Mybatis"></a>22、Mybatis</h1><p>​    Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，****开发时只需要关注SQL语句本身*<em><strong>，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。MyBatis 可以使用 XML 或注解来</strong></em>*配置和映射原生信息，将 POJO映射成数据库中的记录****。</p>
<p>​    通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并****通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句*<em><strong>，最后</strong></em>*由mybatis框架执行sql并将结果映射为java对象并返回****。（从执行sql到返回result的过程）。</p>
<p>Mybaits的优点：基于SQL语句编程，相当灵活；与JDBC相比，减少了50%以上的代码量。与Spring很好的集成。</p>
<h2 id="MyBatis框架的缺点："><a href="#MyBatis框架的缺点：" class="headerlink" title="*MyBatis框架的缺点：*"></a><em><strong>*MyBatis框架的缺点：*</strong></em></h2><p>****SQL语句的编写工作量较大*<em><strong>；SQL语句</strong></em>*依赖于数据库****，导致数据库移植性差，不能随意更换数据库。</p>
<p>MyBatis与Hibernate有哪些不同？半ORM框架，MyBatis需要程序员自己编写Sql语句。编写原生态sql，可以严格控制sql执行性能，灵活度高。Hibernate****对象/关系映射能力强*<em><strong>，</strong></em>*数据库无关性好*<em><strong>，对于关系模型要求高的软件，如果用hibernate开发可以</strong></em>*节省很多代码****，提高效率。</p>
<h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="*#{}和${}的区别是什么？*"></a><em><strong>*#{}和${}的区别是什么？*</strong></em></h2><p>****#{}是预编译处理，${}是字符串替换****。Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；使用#{}可以有效的防止SQL注入，提高系统安全性。$方式一般用于传入数据库对象，例如传入表名.</p>
<p>当实体类中的属性名和表中的字段名不一样 ，怎么办 </p>
<p>​    1、sql语句中定义字段名的别名2、通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。</p>
<p>模糊查询：</p>
<p>​     string wildcardname = “%smi%”;</p>
<p>  list<name> names = mapper.selectlike(wildcardname);</p>
  <select id=”selectlike”>


<p>   select * from foo where bar like #{value}</p>
  </select>

<p>2、可能引起sql注入。</p>
<select id=”selectlike”>


<p>​     select * from foo where bar like “%”#{value}”%”</p>
</select>

<p>MyBatis插入数据返回插入对象的主键属性设置：</p>
<p>useGeneratedKeys=”true” keyProperty=”userId”</p>
<p><em><strong>*Dao接口即Mapper接口。接口的全限名，就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MapperStatement对象。*</strong></em></p>
<p><em><strong>*Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。*</strong></em></p>
<p>****Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页****，而非物理分页。</p>
<p><em><strong>*分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。*</strong></em></p>
<p>​    </p>
<p>使用sql的别名，或者ResultMap,逐一定义数据库列名和对象属性之间的映射关系。有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<p>动态sql：执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。：trim | where | set | foreach | if | choose | when | otherwise | bind。</p>
<p>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</p>
<p>答：<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</p>
<p> 不同的Xml映射文件，如果<em><strong>*配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；*</strong></em></p>
<p>原因****就是namespace+id是作为Map&lt;String, MapperStatement&gt;的key使用的****，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>
<p>MyBatis实现一对多有几种方式,怎么操作的？</p>
<p>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。</p>
<p>接口绑定，****就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,****这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p>
<p>接口绑定有两种实现方式,****一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；*<em><strong>另外一种就是</strong></em>*通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。****当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。</p>
<h2 id="ResultMap和ResultType："><a href="#ResultMap和ResultType：" class="headerlink" title="*ResultMap和ResultType：*"></a><em><strong>*ResultMap和ResultType：*</strong></em></h2><p>两者都是表示查询结果集与java对象之间的一种关系，处理查询结果集，映射到java对象。 </p>
<p><em><strong>*resultMap：表示将查询结果集中的列一一映射到bean对象的各个属性。*</strong></em></p>
<p>****ResultType:表示的是bean中的对象类****，此时可以省略掉resultMap标签的映射，但是必须保证查询结果集中的属性 和 bean对象类中的属性是一一对应的，此时大小写不敏感，但是有限制。</p>
<p>parameterType直接将查询结果列值类型自动对应到java对象属性类型上，不再配置映射关系一一对应。</p>
<h1 id="23、Spring-MVC"><a href="#23、Spring-MVC" class="headerlink" title="23、Spring MVC"></a>23、Spring MVC</h1><h2 id="1、组件"><a href="#1、组件" class="headerlink" title="*1、组件*"></a><em><strong>*1、组件*</strong></em></h2><p>（1）****前端控制器 DispatcherServlet****（不需要程序员开发）</p>
<p>作用：****接收请求、响应结果，相当于转发器****，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p>
<p>（2）****处理器映射器HandlerMapping****（不需要程序员开发）</p>
<p>作用：<em><strong>*根据请求的URL来查找Handler*</strong></em></p>
<p>（3）处****理器适配器HandlerAdapte****r</p>
<p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p>
<p>（4）****处理器Handler****（需要程序员开发）</p>
<p>（5）****视图解析器 ViewResolver****（不需要程序员开发）</p>
<p>作用：进行视图的解析，****根据视图逻辑名解析成真正的视图（****view）</p>
<p>（6）视图View（需要程序员开发jsp）</p>
<p>****View是一个接口， 它的实现类支持不同的视图类型（jsp****，freemarker，pdf等等）</p>
<h2 id="2-、-SpringMVC常用的注解有哪些？"><a href="#2-、-SpringMVC常用的注解有哪些？" class="headerlink" title="*2*****、*****SpringMVC常用的注解有哪些？*"></a><em><strong>*2*</strong>***</em>*、****<em><strong>*SpringMVC常用的注解有哪些？*</strong></em></h2><p>​    @RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。</p>
<p>​    @RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p>
<p>​    @ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<p>控制器注解：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller。方法无法返回到JSP页面，视图解析器不起作用。</p>
<h2 id="3、如果在拦截请求中，我想拦截get方式提交的方法-怎么配置？"><a href="#3、如果在拦截请求中，我想拦截get方式提交的方法-怎么配置？" class="headerlink" title="*3、如果在拦截请求中，我想拦截get方式提交的方法,怎么配置？*"></a><em><strong>*3、如果在拦截请求中，我想拦截get方式提交的方法,怎么配置？*</strong></em></h2><p>答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。</p>
<h2 id="4、怎样在方法里面得到Request-或者Session？"><a href="#4、怎样在方法里面得到Request-或者Session？" class="headerlink" title="*4、怎样在方法里面得到Request,或者Session？*"></a><em><strong>*4、怎样在方法里面得到Request,或者Session？*</strong></em></h2><p>答：直接在方法的形参中声明request,SpringMvc就自动把request对象传入。</p>
<h2 id="5、如果想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#5、如果想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="*5、如果想在拦截的方法里面得到从前台传入的参数,怎么得到？*"></a><em><strong>*5、如果想在拦截的方法里面得到从前台传入的参数,怎么得到？*</strong></em></h2><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p>
<h2 id="6、如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#6、如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="*6、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？*"></a><em><strong>*6、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？*</strong></em></h2><p>答：直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。</p>
<h2 id="7、SpringMvc中函数的返回值是什么？"><a href="#7、SpringMvc中函数的返回值是什么？" class="headerlink" title="*7、SpringMvc中函数的返回值是什么？*"></a><em><strong>*7、SpringMvc中函数的返回值是什么？*</strong></em></h2><p>答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p>
<h2 id="8、SpringMvc用什么对象从后台向前台传递数据的？"><a href="#8、SpringMvc用什么对象从后台向前台传递数据的？" class="headerlink" title="*8、SpringMvc用什么对象从后台向前台传递数据的？*"></a><em><strong>*8、SpringMvc用什么对象从后台向前台传递数据的？*</strong></em></h2><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p>
<h2 id="9、怎么样把ModelMap里面的数据放入Session里面？"><a href="#9、怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="*9、怎么样把ModelMap里面的数据放入Session里面？*"></a><em><strong>*9、怎么样把ModelMap里面的数据放入Session里面？*</strong></em></h2><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p>
<h2 id="注解原理："><a href="#注解原理：" class="headerlink" title="*注解原理：*"></a><em><strong>*注解原理：*</strong></em></h2><p>​    ****注解本质是一个继承了Annotation的特殊接口，****其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h1 id="24、Spring"><a href="#24、Spring" class="headerlink" title="24、Spring"></a>24、Spring</h1><h2 id="Spring的AOP理解："><a href="#Spring的AOP理解：" class="headerlink" title="*Spring的AOP理解：*"></a><em><strong>*Spring的AOP理解：*</strong></em></h2><p>OOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</p>
<p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p>
<p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p>
<p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p>
<p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p>
<p>​    ①JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</p>
<p>​    ②如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
<p>（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<p><em><strong>*InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。*</strong></em></p>
<h2 id="Spring的IoC"><a href="#Spring的IoC" class="headerlink" title="*Spring的IoC*"></a><em><strong>*Spring的IoC*</strong></em></h2><p>（1）IOC就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</p>
<p>（2）最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p>
<p>（3）Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。</p>
<p>（1）BeanFactory：****是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。****ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>
<p><em><strong>*①*</strong>***</em>*继承MessageSource，因此支持国际化****。</p>
<p>②****统一的资源文件访问方式****。</p>
<p><em><strong>*③*</strong>***</em>*提供在监听器中注册bean的事件。****</p>
<p><em><strong>*④*</strong>***</em>*同时加载多个配置文件。****</p>
<p>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
<p>（2）<em><strong>*①*</strong>***</em>*BeanFactroy采用的是延迟加载形式来注入Bean的****，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。而ApplicationContext是启动时创建所有的bean;</p>
<p>6、请解释Spring Bean的生命周期？</p>
<p> 首先说一下Servlet的生命周期：实例化，初始init，接收请求service，销毁destroy；</p>
<h2 id="Spring上下文中的Bean生命周期也类似，如下："><a href="#Spring上下文中的Bean生命周期也类似，如下：" class="headerlink" title="*Spring上下文中的Bean生命周期也类似，如下：*"></a><em><strong>*Spring上下文中的Bean生命周期也类似，如下：*</strong></em></h2><p><em><strong>*（1）实例化Bean：*</strong></em></p>
<p>对于BeanFactory容器，<em><strong>*当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。*<em><strong>对于ApplicationContext容器，当容器启动结束后，</strong></em>*通过获取BeanDefinition对象中的信息，实例化所有的bean。*</strong></em></p>
<p>（2）<em><strong>*设置对象属性（依赖注入）：*</strong></em></p>
<p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口<em><strong>*完成依赖注入。*</strong></em></p>
<p>（3）处理Aware接口：</p>
<p>接着，S<em><strong>*pring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：*</strong></em></p>
<p>①如果这个Bean已经实现了****BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法****，此处传递的就是Spring配置文件中Bean的id值；</p>
<p>②如果这个Bean已经实现了****BeanFactoryAware接口，会调用它实现的setBeanFactory()方法****，传递的是Spring工厂自身。</p>
<p>③如果这个Bean已经实现了****ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法****，传入Spring上下文；</p>
<p>（4）BeanPostProcessor：</p>
<p>如果想对Bean进行一些<em><strong>*自定义的处理，那么可以让Bean实现了BeanPostProcessor接口*<em><strong>，那将会调用</strong></em>*postProcessBeforeInitialization(Object obj, String s)方法。*</strong></em></p>
<p>（5）InitializingBean 与 init-method：</p>
<p>如果Bean在Spring配置文件中配置了 <em><strong>*init-method 属性，则会自动调用其配置的初始化方法。*</strong></em></p>
<p>（6）如果这个Bean实现了<em><strong>*BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；*<em><strong>由于这个方法是在Bean初始化结束时调用的，</strong></em>*所以可以被应用于内存或缓存技术；*</strong></em></p>
<p>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p>
<p><em><strong>*（7）DisposableBean：*</strong></em></p>
<p>当Bean不再需要时，会经过清理阶段，<em><strong>*如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；*</strong></em></p>
<p>（8）destroy-method：</p>
<p>最后，如果这个Bean的Spring配置中配置了<em><strong>*destroy-method属性，会自动调用其配置的销毁方法*</strong></em></p>
<h2 id="Spring的自动装配："><a href="#Spring的自动装配：" class="headerlink" title="*Spring的自动装配：*"></a><em><strong>*Spring的自动装配：*</strong></em></h2><p>（1）no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p>
<p>（2****）byName：通过bean的名称进行自动装配****，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。 </p>
<p>（3<em><strong>*）byType：通过参数的数据类型进行自动装配。*</strong></em></p>
<p>（4）constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p>
<p>（5）autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p>
<p>@Autowired和@Resource之间的区别</p>
<p>(1) @Autowired****默认是按照类型装配注入的*<em><strong>，</strong></em>*默认情况下它要求依赖对象必须存在****（可以设置它required属性为false）。</p>
<p>(2) @Resource<em><strong>*默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。*</strong></em></p>
<h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="*Spring事务*"></a><em><strong>*Spring事务*</strong></em></h2><p><em><strong>*本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。*</strong></em></p>
<h2 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="*AOP通知类型*"></a><em><strong>*AOP通知类型*</strong></em></h2><p><em><strong>*前置通知，后置通知，返回后通知，抛出异常通知，环绕通知。*</strong></em></p>
<h1 id="25、常用数据结构"><a href="#25、常用数据结构" class="headerlink" title="25、常用数据结构"></a>25、常用数据结构</h1><h2 id="25-1、字典树"><a href="#25-1、字典树" class="headerlink" title="25.1、字典树"></a>25.1、字典树</h2><p>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</p>
<p>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
<p>每个节点的所有子节点包含的字符都不相同。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《Java面经》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/05/28/java-mian-jing/" property="cc:attributionName"
               rel="cc:attributionURL">
                JavaGuy
            </a> 采用
            <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: 'GgssQFlBBeYrJoL1y5s8jXeR-gzGzoHsz',
        appKey: 'kXYkbr7xencqP3PxqQNKykdt',
        notify: 'true' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/06/02/20210603/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/26.jpg" class="responsive-img" alt="20210603">
                        
                        <span class="card-title">20210603</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1、MySQL5.7 .19代价模型1.1、代价模型MySQL5.7代价分为IO，CPU，远程操作和内存代价，目前内存代价没有考虑。代价分为server层和engine层。server层主要是cpu的代价，而engine层主要是io的代价。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-06-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Lab/" class="post-category" target="_blank">
                                    Lab
                                </a>
                            
                            <a href="/categories/Lab/%E5%91%A8%E4%BC%9A%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/" class="post-category" target="_blank">
                                    周会总结报告
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BB%A3%E4%BB%B7%E4%BC%B0%E7%AE%97/" target="_blank">
                        <span class="chip bg-color">代价估算</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/05/27/20210527/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="20210527">
                        
                        <span class="card-title">20210527</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1、MySQL查询优化进一步学习1.1、子查询优化MySQL支持的子查询优化策略如下：

使用MySQL trace工具，跟踪优化器对SQL的整个优化执行过程。
首先建三张表，并添加索引
DROP TABLE IF EXISTS `t1`;
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-05-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Lab/" class="post-category" target="_blank">
                                    Lab
                                </a>
                            
                            <a href="/categories/Lab/%E5%91%A8%E4%BC%9A%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/" class="post-category" target="_blank">
                                    周会总结报告
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" target="_blank">
                        <span class="chip bg-color">子查询优化</span>
                    </a>
                    
                    <a href="/tags/%E6%9D%A1%E4%BB%B6%E5%8C%96%E7%AE%80/" target="_blank">
                        <span class="chip bg-color">条件化简</span>
                    </a>
                    
                    <a href="/tags/%E6%B6%88%E9%99%A4%E5%A4%96%E8%BF%9E%E6%8E%A5/" target="_blank">
                        <span class="chip bg-color">消除外连接</span>
                    </a>
                    
                    <a href="/tags/%E8%AF%AD%E4%B9%89%E4%BC%98%E5%8C%96/" target="_blank">
                        <span class="chip bg-color">语义优化</span>
                    </a>
                    
                    <a href="/tags/%E9%9D%9ESPJ%E4%BC%98%E5%8C%96/" target="_blank">
                        <span class="chip bg-color">非SPJ优化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: JavaGuy的博客<br />'
            + '作者: JavaGuy<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

<!-- <script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'artDetail',
        blogId: '20962-1585405055583-879',
        name: '算法码上来',
        qrcode: 'https://godweiyang.com/medias/gzh.jpg',
        keyword: 'VIP',
    });
</script> -->

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4, h5, h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5, h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; ZhangQu. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">285.4k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/zhangqu999" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:zhang1842279380@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=1842279380&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 1000;
        var uvcountOffset = 200;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2021, 03, 18, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    
    <script type="text/javascript" src="/libs/others/snow.js"></script>
    

</body>

</html>