<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="20210520, SpringBoot Java MySQL MA JavaGuy Math 算法">
    <meta name="baidu-site-verification" content="code-r7CYm21B6o" />
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48" />
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7" />
    <meta name="description" content="一、运行张轲学长代码

二、查询优化器系统学习1、数据管理系统的查询优化1.1、数据库调优1.1.1、目标使数据库有更高的吞吐量和更短的响应时间。
1.1.2、常见调优方法
人工调优

基于案例的调优（静态）

自调优

Oracle实现的">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>20210520 | JavaGuy的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?ce84511d3df71640a9378a69f6293044";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="JavaGuy的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JavaGuy的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">JavaGuy的博客</div>
        <div class="logo-desc">
            
            华中科技大学 | 计算机科学与技术 | 分布式云数据库内核
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '91a6f824b85ba9ed6e7cf599364e2f8bc897a465357160c6425c8eacd8883377';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        20210520
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" target="_blank">
                            <span class="chip bg-color">查询优化</span>
                        </a>
                        
                        <a href="/tags/%E4%BB%A3%E4%BB%B7%E4%BC%B0%E7%AE%97/" target="_blank">
                            <span class="chip bg-color">代价估算</span>
                        </a>
                        
                        <a href="/tags/%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/" target="_blank">
                            <span class="chip bg-color">多表连接算法</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/Lab/" class="post-category" target="_blank">
                            Lab
                        </a>
                        
                        <a href="/categories/Lab/%E5%91%A8%E4%BC%9A%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/" class="post-category" target="_blank">
                            周会总结报告
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-05-19
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    JavaGuy
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    23.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    87 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="一、运行张轲学长代码"><a href="#一、运行张轲学长代码" class="headerlink" title="一、运行张轲学长代码"></a>一、运行张轲学长代码</h1><p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210519215255584.png" alt="image-20210519215255584"></p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210519215341562.png" alt="image-20210519215341562"></p>
<h1 id="二、查询优化器系统学习"><a href="#二、查询优化器系统学习" class="headerlink" title="二、查询优化器系统学习"></a>二、查询优化器系统学习</h1><h1 id="1、数据管理系统的查询优化"><a href="#1、数据管理系统的查询优化" class="headerlink" title="1、数据管理系统的查询优化"></a>1、数据管理系统的查询优化</h1><h2 id="1-1、数据库调优"><a href="#1-1、数据库调优" class="headerlink" title="1.1、数据库调优"></a>1.1、数据库调优</h2><h3 id="1-1-1、目标"><a href="#1-1-1、目标" class="headerlink" title="1.1.1、目标"></a>1.1.1、目标</h3><p>使数据库有更高的吞吐量和更短的响应时间。</p>
<h3 id="1-1-2、常见调优方法"><a href="#1-1-2、常见调优方法" class="headerlink" title="1.1.2、常见调优方法"></a>1.1.2、常见调优方法</h3><ul>
<li><p>人工调优</p>
</li>
<li><p>基于案例的调优（静态）</p>
</li>
<li><p>自调优</p>
<ul>
<li><p>Oracle实现的自调优技术</p>
<ul>
<li><p>Redo Logfile Sizeing Advisor：系统自动推荐重做日志的文件大小</p>
</li>
<li><p>Auto checkpoint tuning</p>
</li>
<li><p>Auto shared memory tuning</p>
</li>
<li><p>transaction rollback and recovery monitoring</p>
</li>
<li><p>SQL tuning advisor：给出建立索引的建议，SQL重写的建议</p>
</li>
<li><p>SQL Analyzer：对SQL语句的不同查询执行计划进行性能比较和分析</p>
</li>
<li><p>SQL Access advisor</p>
</li>
<li><p>SQL plan management：使SQL能根据环境的变化选择稳定、高效的查询执行计划</p>
</li>
<li><p>undo advisor：为管理员恰当设置undo_retention提供建议，避免快照过于陈旧</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>应用情况的估算</p>
<ul>
<li>应用的使用方式（以读多写少或读写均衡来区分OLAP和OLTP；应用对数据库的并发情况；并发是否可以池化）</li>
<li>数据量</li>
<li>对数据库的压力和峰值压力</li>
</ul>
</li>
<li><p>系统选型策略</p>
</li>
<li><p>数据模型的设计</p>
<ul>
<li>E-R模型设计</li>
<li>数据逻辑分布策略：减少数据请求中不必要的数据传输，只返回用户需要的数据，如分区，分库分表</li>
<li>数据物理存储策略：目的是减少IO，如使用压缩技术将索引和表数据分开；将日志，索引，数据分布在不同物理存储上。</li>
<li>索引：在查询频繁的对象上建立适当的索引，使其正效应大于负效应（索引维护需要消耗）</li>
<li>SQL设计：依据查询重写规则，编写正确的，高效的SQL，要有意识地保障SQL能用到索引</li>
<li>数据库功能的启用<ul>
<li>查询重用：可缓存查询执行计划，查询结果</li>
<li>数据库参数的设置：如可以设置数据缓冲区</li>
</ul>
</li>
<li>模拟系统预运行：压测</li>
<li>系统监控与分析<ul>
<li>应用系统表现：收集用户意见</li>
<li>OS环境监控：实时监控CPU，内存，IO，并与历史正常情况对比</li>
<li>数据库内部状态监控：如实时监控锁的情况，与历史正常情况对比</li>
<li>日志分析：在数据库的日志和操作系统的日志中找出异常事件，定位问题</li>
<li><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515152036888.png" alt="image-20210515152036888"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-2、查询优化技术"><a href="#1-2、查询优化技术" class="headerlink" title="1.2、查询优化技术"></a>1.2、查询优化技术</h2><p>查询优化技术是SQL层面的优化，属于局部优化，而数据库调优是全局优化。</p>
<h3 id="1-2-1、查询重用"><a href="#1-2-1、查询重用" class="headerlink" title="1.2.1、查询重用"></a>1.2.1、查询重用</h3><p>查询重用指尽可能多地利用先前的执行结果，已达到节约时间和减少资源消耗的目的。</p>
<ul>
<li>查询结果的重用：在缓冲区分配一块缓冲块存放SQL语句和最后的结果集，减少了查询执行全过程的资源的消耗</li>
<li>查询计划的重用：缓存查询语句的执行计划和相应的语法树结构，减少了查询计划生成的时间和资源消耗</li>
</ul>
<p>弊端：结果集很大会占用大量内存；同一条SQL不用用户查询结果可能不同。</p>
<h3 id="1-2-2、查询重写规则"><a href="#1-2-2、查询重写规则" class="headerlink" title="1.2.2、查询重写规则"></a>1.2.2、查询重写规则</h3><p>是查询语句的一种等价转换，即对于任何相关模式的任意状态都会产生相同的结果。其目标有两个：</p>
<ul>
<li>将查询转换为等价的，效率更高的形式，例如将效率低的谓词转为效率高的谓词、消除重复条件</li>
<li>尽量将查询重写为等价、简单且不受表顺序限制的形式，为物理查询优化阶段提供更多的选择，例如视图的重写，子查询的合并转换</li>
</ul>
<p>查询重写的依据是关系代数，关系代数的等价变换规则对查询重写提供了理论上的支持。查询重写之后，查询优化器可能生成多个连接路径，可以从候选者中择优。</p>
<p>对查询优化技术进行分类，有以下4个角度</p>
<ul>
<li>语法级：基于语法进行优化</li>
<li>代数级：运用关系代数进行优化</li>
<li>语义级：根据完整性约束，对查询语句进行语义理解，推知一些可优化的操作</li>
<li>物理级：基于代价估算模型，比较得出各种执行方式中代价最小的</li>
</ul>
<p>查询重写是基于前三个角度进行的优化，属于逻辑优化的范畴；而基于代价估算模型是物理层面的优化，是从连接路径中选择代价最小的路径的过程。</p>
<p>查询重写主要优化思路：</p>
<ul>
<li>将过程性查询转为描述性查询，如视图重写</li>
<li>将复杂查询（如嵌套子查询、外连接，嵌套连接）尽可能转为多表连接查询</li>
<li>将效率低的谓词转为等价的效率高的谓词，如等价谓词重写</li>
<li>利用等式和不等式的性质，简化where，having，on条件</li>
</ul>
<p>重写的核心是“<strong>等价转换</strong>”，只有等价才可以重写。</p>
<h3 id="1-2-3、查询算法优化"><a href="#1-2-3、查询算法优化" class="headerlink" title="1.2.3、查询算法优化"></a>1.2.3、查询算法优化</h3><ul>
<li><p>查询优化：即求解给定查询语句的高效执行计划的过程。</p>
</li>
<li><p>查询计划</p>
<ul>
<li>也称查询树，由一系列操作符按一定的运算关系构成查询的一个执行方案。</li>
<li>从形式上看是一颗二叉树，叶子是每个单表对象，两个叶子的父节点是一个连接操作符（如左外连接）连接后的中间结果（临时表），直到根节点</li>
<li>涉及的主要关系节点有：<ul>
<li>单表节点：考虑单表的数据获取方式，直接通过IO获取数据、通过索引获取数据、通过索引定位数据，再通过IO获取数据</li>
<li>两表节点：考虑两表以何种方式连接、代价有多大、连接路径有哪些<ul>
<li>哈希连接：数据量比较大</li>
<li>嵌套连接：外表数据量小，内表数据量大</li>
<li>归并连接：数据有序</li>
</ul>
</li>
<li>多表中间节点：考虑多表连接顺序如何构成代价最小的执行计划。如果判断连接方式太多，也会导致效率问题。目前很多数据库采用左深连接树，右深连接树，紧密树对多表进行连接，得到多种连接路径。</li>
</ul>
</li>
</ul>
</li>
<li><p>生成最优查询计划的策略通常有两个：</p>
<ul>
<li>基于规则优化：根据经验或一些已被证明有效的方式，定义为“规则”，用这些规则简化查询计划生成过程中符合可被化简的操作，使用启发式规则排除一些明显不好的存取路径。</li>
<li>基于代价优化：根据一个代价评估模型，在生成查询计划的过程中，计算每条存取路径的花费，然后选择代价最小的作为子路径，这样直到所有表连接完成得到一个完整的路径。目前主流数据库都采用了基于代价优化的策略</li>
</ul>
</li>
<li><p>查询优化器的实现，多是两种优化策略组合使用，如MySQL和PostgreSQL</p>
</li>
<li><p>多表连接的优化算法</p>
<ul>
<li>SYSTEM-R算法：近乎穷举的搜索算法</li>
<li>启发式搜索算法：基于启发式规则抛弃不好的存取路径挑选好的</li>
<li>贪心算法：根据某种优化方式，以当前情况为基础做出最优选择，并认为每次搜索的局部存取路径是最优的，然后继续搜索与其他表的连接路径</li>
<li>动态规划</li>
<li>遗传算法：一种启发式算法，模拟自然界生物进化过程，采用人工进化的方式对目标空间进行随机化搜索</li>
</ul>
</li>
<li><p>查询的基本操作有选择，投影和连接。</p>
<ul>
<li>选择和投影的优化规则适用于SPJ（select-project-join）和非SPJ（SPJ + group by）</li>
<li>连接分为两表连接和多表连接，n个表连接方式有n! 种，将导致搜索空间极度膨胀，这是查询优化器实现需要考虑的问题。</li>
</ul>
</li>
</ul>
<h3 id="1-2-4、并行查询优化"><a href="#1-2-4、并行查询优化" class="headerlink" title="1.2.4、并行查询优化"></a>1.2.4、并行查询优化</h3><p>单机数据库中，查询优化算法只需找到查询的一个具有最小执行话费的执行计划；而并行数据库中，查询优化目标是寻找具有最小响应时间的查询执行计划，这需要查询工作分解为一些可以并行运行的子工作。一个查询能否并行执行，取决于以下几个因素：</p>
<ul>
<li>系统中的可用资源，如内存，高速缓存数据量</li>
<li>CPU的数量</li>
<li>运算中的特定代数运算符，如A,B,C,D四个表连接，四个表的单表扫描可以并行执行，A,B连接的同时可以进行C,D的连接。</li>
</ul>
<p>在同一个SQL内，查询并行分为以下两种：</p>
<ul>
<li>查询内并行：将同一操作如单表扫描，两表连接，排序等分解为多个独立的子操作，由不同CPU同时执行。</li>
<li>查询间并行：将一条SQL语句分解成多个子操作，由多个CPU同时执行。</li>
</ul>
<h3 id="1-2-5、分布式查询优化"><a href="#1-2-5、分布式查询优化" class="headerlink" title="1.2.5、分布式查询优化"></a>1.2.5、分布式查询优化</h3><p>在分布式数据库中，<strong>查询优化策略</strong>（主要是<strong>数据传输策略</strong>，如A传到B或B传到A或进行过滤后再进行传输）和<strong>局部处理优化</strong>（传统单节点数据库优化技术）是查询优化的重点。</p>
<p>查询优化策略中，数据的网络通信开销是考虑的主要因素。分布式查询优化以<strong>减少传输的次数和数据量</strong>作为查询优化的目标。因此分布式数据库中的代价估算模型，除了考虑CPU和IO代价之外，还要考虑通信代价，即：</p>
<blockquote>
<p>总代价 = IO代价 + CPU代价 + 通信代价</p>
</blockquote>
<h3 id="1-2-6、其他优化"><a href="#1-2-6、其他优化" class="headerlink" title="1.2.6、其他优化"></a>1.2.6、其他优化</h3><p>数据库的查询性能，还与一些其他因素有关，如数据库集群系统总的SD（share disk）集群和SN（share nothing）集群，不同架构查询优化技术也不同。SD集群用的共享存储方式，在数据读写时可能产生读写冲突，因此单表扫描会收到影响；而SN集群采用的是非共享存储方式，因此在考虑了通信代价后单节点的优化方式依然适用。</p>
<h1 id="2、逻辑查询优化"><a href="#2、逻辑查询优化" class="headerlink" title="2、逻辑查询优化"></a>2、逻辑查询优化</h1><p>查询优化器在逻辑优化阶段主要解决的问题是：如何找出SQL语句的等价变换形式，使SQL执行更高效，可用优化思路有：</p>
<ul>
<li>子句局部优化：如等价谓词重写、where和having条件化简</li>
<li>子句间关联优化：如连接消除、子查询优化、视图重写</li>
<li>局部与整体的优化：如OR重写并集规则需要考虑UNION操作（变换后整体形式）的花费和OR操作（局部表达式）的花费</li>
<li>形式变化优化：如嵌套连接消除</li>
<li>语义优化：根据完整性约束、SQL表达式的含义等信息对语句进行语义优化</li>
<li>其他优化：根据一些规则对非SPJ做的其他优化、根据硬件环境进行的并行查询优化</li>
</ul>
<p>各种逻辑优化技术都基于关系代数和启发式规则</p>
<h2 id="2-1、查询优化技术的理论基础"><a href="#2-1、查询优化技术的理论基础" class="headerlink" title="2.1、查询优化技术的理论基础"></a>2.1、查询优化技术的理论基础</h2><h3 id="2-1-1、关系代数"><a href="#2-1-1、关系代数" class="headerlink" title="2.1.1、关系代数"></a>2.1.1、关系代数</h3><p>关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成。</p>
<ul>
<li><p>关系数据结构：即关系数据库中的二维表结构</p>
</li>
<li><p>关系是一种对象，也成为表</p>
</li>
<li><p>关系的元数据：即表结构</p>
</li>
<li><p>关系的数据，即表的行数据，也称为元组，记录</p>
</li>
<li><p>关系运算：将一定的运算符作用于一定的关系对象上，得到预期的运算结果</p>
<p>关系代数运算符包括以下4类：</p>
<ul>
<li>传统集合运算符：UNION（并），INTERSECTION（交）, DIFFERENCE（差）等</li>
<li>专门的关系运算符：SELECT（选择）, PROJECT（投影）, JOIN（连接）, DIVIDE（除）</li>
<li>辅助运算符：辅助专门的关系运算符进行操作，包括算术运算符和逻辑运算符</li>
<li>关系扩展运算符：SEMIJOIN（半连接）, SEMIDIFFERENCE（半差）, EXTEND（扩展）, COMPOSITION（合计）, TCLOSE（传递闭包）</li>
</ul>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515165808023.png" alt="image-20210515165808023"></p>
</li>
</ul>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515165826899.png" alt="image-20210515165826899"></p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515165846607.png" alt="image-20210515165846607"></p>
<h3 id="2-1-2、关系代数等价变换规则对优化的指导意义"><a href="#2-1-2、关系代数等价变换规则对优化的指导意义" class="headerlink" title="2.1.2、关系代数等价变换规则对优化的指导意义"></a>2.1.2、关系代数等价变换规则对优化的指导意义</h3><p>查询语句可以表示为一颗二叉树（首先是语法分析得到一颗查询树；其次有语义分析等工作；再次是根据关系代数进行了数据库的逻辑查询优化；最后是根据代价估算算法进行物理查询优化。优化的结果被送到执行器执行），其中：</p>
<ul>
<li>叶子是单表</li>
<li>内部节点是运算符（或称算子，操作符），表示左右子树的运算方式</li>
<li>子树是子表达式或SQL片段</li>
<li>根节点是最后运算的操作符</li>
<li>根节点之后是查询优化后的结果</li>
<li>一棵树就是一个查询的路径</li>
<li>多个关系连接，连接顺序不同，可以得出多个类似的二叉树</li>
<li>查询优化就是找出代价最小的二叉树，即最优查询路径。每条路径的生成包括了单表扫描、两表连接、多表连接顺序、多表连接搜索空间等技术</li>
<li>基于代价估算的查询优化就是通过计算和比较，找出代价最少的最优二叉树</li>
</ul>
<h4 id="2-1-2-1、从运算符角度考虑优化"><a href="#2-1-2-1、从运算符角度考虑优化" class="headerlink" title="2.1.2.1、从运算符角度考虑优化"></a>2.1.2.1、从运算符角度考虑优化</h4><p>不同运算符根据其特点，可以对查询语句做不同的优化，减少中间生成物的大小和数量，节约IO，内存，从而提高执行速度。</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515171038653.png" alt="image-20210515171038653"></p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515171126019.png" alt="image-20210515171126019"></p>
<h4 id="2-1-2-2、从运算规则角度考虑优化"><a href="#2-1-2-2、从运算规则角度考虑优化" class="headerlink" title="2.1.2.2、从运算规则角度考虑优化"></a>2.1.2.2、从运算规则角度考虑优化</h4><p>下面的运算规则是查询重写技术作等价转换的基础</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515171907978.png" alt="image-20210515171907978"></p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515172043157.png" alt="image-20210515172043157"></p>
<h2 id="2-2、查询重写规则"><a href="#2-2、查询重写规则" class="headerlink" title="2.2、查询重写规则"></a>2.2、查询重写规则</h2><p>OLTP采用基于选择，投影和连接3种基本操作相结合的查询，称为SPJ查询。数据库在查询优化过程中，会对这3种基本操作进行优化：</p>
<ul>
<li>选择操作：对应限制条件，优化方法是选择操作下推，目的是尽量减少连接操作前的元组数，使得中间临时表尽量少，这样就能减少IO，内存和CPU的消耗</li>
<li>投影操作：对应目的列对象，优化方法是投影操作下推，目的是尽量减少连接操作前的列数，从而减少连接以后的中间临时表元组大小，节约内存（不能减少IO，因为行存储，元组是读取的基本单位）</li>
<li>连接操作：对应连接条件，涉及两个子问题<ul>
<li>多表连接中表的连接顺序决定着效率</li>
<li>多表连接中表的连接顺序由语义决定：查询语句决定了多表连接的语义，如笛卡尔积、内连接、左外连接等</li>
</ul>
</li>
</ul>
<p>针对SQL语句特点，分为以下两类：</p>
<ul>
<li>针对SPJ的查询优化：基于选择，投影，连接三种基本操作相结合的查询</li>
<li>针对非SPJ的查询优化：在SPJ的基础上存在group by操作的查询，较复杂。</li>
</ul>
<p>选择和投影可以基于关系代数规则进行优化；表连接可以基于多表连接相关算法进行优化；其他操作多是基于索引和代价估算进行优化</p>
<h3 id="2-2-1、子查询的优化"><a href="#2-2-1、子查询的优化" class="headerlink" title="2.2.1、子查询的优化"></a>2.2.1、子查询的优化</h3><p>子查询出现位置不同，对优化影响不同</p>
<ul>
<li>目标列位置：只能是标量子查询</li>
<li>from子句位置：只能是非相关子查询，可以上拉子查询到父层，在多表连接时统一考虑连接代价后择优</li>
<li>where子句位置：是条件表达式的一部分，格式除了一般的操作符，也有用谓词指定的一些操作，如IN，BETWEEN, EXISTS等</li>
<li>join/on子句位置：join块类似from子句；on块类似where子句</li>
<li>group by子句位置：子查询写在此处无意义</li>
<li>order by子句位置：没有实用意义</li>
</ul>
<h4 id="2-2-1-1、子查询的分类"><a href="#2-2-1-1、子查询的分类" class="headerlink" title="2.2.1.1、子查询的分类"></a>2.2.1.1、子查询的分类</h4><p>根据子查询中涉及的关系对象与外层关系对象间的关系，子查询分为以下两类：</p>
<ul>
<li><p>相关子查询：子查询的执行依赖于外层父查询的一些属性值（查询优化器对相关子查询的优化有一定意义）</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515180200702.png" alt="image-20210515180200702"></p>
</li>
<li><p>非相关子查询：子查询的执行不依赖外层父查询的任何属性值，子查询完全独立。</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515180342372.png" alt="image-20210515180342372"></p>
</li>
</ul>
<p>从特定谓词看，子查询分为以下三类：</p>
<ul>
<li>[NOT]IN/ALL/ANY/SOME子查询：左边是操作数，右边是子查询，是最常见的子查询类型之一</li>
<li>[NOT]EXISTS子查询：没有左操作数，右边是子查询，也比较常见</li>
<li>其他子查询</li>
</ul>
<p>从语句构成复杂程度看，子查询可以分为以下三类：</p>
<ul>
<li>SPJ子查询</li>
<li>group by子查询：SPJ子查询加上分组，聚合操作</li>
<li>其他子查询：group by子查询加上其他子句如TOP-K、LIMIT/OFFSET、集合、排序等操作</li>
</ul>
<p>从结果集的角度看，子查询分为以下四种：</p>
<ul>
<li>标量子查询：返回结果集类型是一个单一值</li>
<li>列子查询：返回的结果集类型是一条单一元组</li>
<li>行子查询：返回的结果集类型是一个单一列</li>
<li>表子查询：返回的结果集类型是一个表（多行多列）</li>
</ul>
<h4 id="2-2-1-2、子查询的优化思路"><a href="#2-2-1-2、子查询的优化思路" class="headerlink" title="2.2.1.2、子查询的优化思路"></a>2.2.1.2、子查询的优化思路</h4><p>早期，查询优化器对子查询都采用嵌套执行的方式（即对父查询中的每一行，都执行一次子查询，这样效率很低），因此对其进行优化很有必要。将子查询转为连接操作之后，有如下好处：</p>
<ul>
<li>子查询不用执行很多次</li>
<li>优化器可以根据统计信息来选择不同的连接方法和不同的连接顺序</li>
<li>子查询中的连接条件、过滤条件分别变成了父查询的连接条件和过滤条件，优化器可以对这些条件进行下推，以提高执行效率</li>
</ul>
<p><strong>子查询优化</strong>思路如下：</p>
<ul>
<li><p>子查询合并：在语义等价条件下，多个子查询可以合并成一个子查询，这样多次表扫描，多次连接减少为单次表扫描和单次连接</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515195237030.png" alt="image-20210515195237030"></p>
</li>
<li><p>子查询展开：又称子查询反嵌套，子查询上拉。实质是把某些子查询重写为等价的多表连接操作。带来好处是，有关的访问路径、连接方法和连接顺序可能被有效使用，使得查询语句的层次尽可能地减少。常见的IN/ANY/SOME/ALL/EXISTS依据情况转为半连接（SEMI JOIN）</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515195803605.png" alt="image-20210515195803605"></p>
</li>
<li><p>聚集子查询消除：聚合函数上推，将子查询变为一个新的不包含聚合函数的子查询，并与父查询的部分或全表做左外连接。</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515200013724.png" alt="image-20210515200013724"></p>
</li>
<li><p>其他：利用窗口函数消除子查询、子查询推进等技术</p>
</li>
</ul>
<p><strong>子查询展开</strong>是一种最常用的子查询优化技术，有以下两种形式：</p>
<ul>
<li>如果子查询中出现了聚合、group by、distinct子句， 则子查询只能单独求解，不可以上拉到上层</li>
<li>如果子查询只是一个简单的SPJ格式语句，则可以上拉到上层。前提是上拉后的结果不能带来多余元组，需遵循以下规则：<ul>
<li>如果上层查询结果没有重复（select包含主键），则可以展开子查询，并且展开后的查询的select子句前应加上distinct标志</li>
<li>如果上层查询的select语句中有distinct标志，则可以直接子查询展开</li>
<li>如果内层查询结果没有重复元组，则可以展开</li>
</ul>
</li>
</ul>
<p>子查询展开具体步骤：</p>
<ul>
<li>将子查询和上层查询的from子句连接为同一个from子句，并且修改相应的运行参数</li>
<li>将子查询的谓词符号进行相应修改（如IN修改为ANY）</li>
<li>将子查询的where条件作为一个整体与上层查询的where条件进行合并，并用and连接，从而保证新生成的谓词与原谓词的上下文意思相同，成为一个整体</li>
</ul>
<h4 id="2-2-1-3、最常见的子查询类型的优化"><a href="#2-2-1-3、最常见的子查询类型的优化" class="headerlink" title="2.2.1.3、最常见的子查询类型的优化"></a>2.2.1.3、最常见的子查询类型的优化</h4><ul>
<li>IN类型</li>
<li>ALL/ANY/SOME类型</li>
<li>EXISTS类型</li>
</ul>
<h3 id="2-2-2、视图重写"><a href="#2-2-2、视图重写" class="headerlink" title="2.2.2、视图重写"></a>2.2.2、视图重写</h3><h3 id="2-2-3、等价谓词重写"><a href="#2-2-3、等价谓词重写" class="headerlink" title="2.2.3、等价谓词重写"></a>2.2.3、等价谓词重写</h3><p>数据库执行引擎对某些谓词的处理效率要比其他谓词高，基于此，把逻辑表达式重写成等价的且效率更高的形式，能有效提高查询执行效率。这就是等价谓词重写。其规则如下：</p>
<ul>
<li>LIKE规则</li>
<li>BETWEEN-AND规则</li>
<li>IN转换OR规则</li>
<li>IN转换ANY规则</li>
<li>OR转换ANY规则</li>
<li>ALL/ANY转换集函数规则</li>
<li>NOT规则</li>
<li>OR重写并集规则</li>
</ul>
<h3 id="2-2-4、条件化简"><a href="#2-2-4、条件化简" class="headerlink" title="2.2.4、条件化简"></a>2.2.4、条件化简</h3><p>利用等式和不等式的性质，将where，having和on条件进行化简，化简方式通常有如下几个：</p>
<ul>
<li>把having条件并入where条件</li>
<li>去除表达式中冗余的括号</li>
<li>常量传递</li>
<li>消除死码</li>
<li>表达式计算</li>
<li>等式变换</li>
<li>不等式变换</li>
<li>布尔表达式变换</li>
<li>谓词传递闭包</li>
<li>任何一个布尔表达式都能被转为一个合取范式（CNF）</li>
<li>索引的利用</li>
</ul>
<h3 id="2-2-5、外连接消除"><a href="#2-2-5、外连接消除" class="headerlink" title="2.2.5、外连接消除"></a>2.2.5、外连接消除</h3><h4 id="2-2-5-1、外连接消除的意义"><a href="#2-2-5-1、外连接消除的意义" class="headerlink" title="2.2.5.1、外连接消除的意义"></a>2.2.5.1、外连接消除的意义</h4><p>外连接分为左外连接，右外连接和全外连接，连接过程中，外连接的左右子树不能互换，并且外连接与其他连接交换连接顺序时，必须满足严格的条件进行等价变换。查询重写的一项技术就是把外连接转为内连接，转换意义如下：</p>
<ul>
<li><p>查询优化器在处理外连接操作所需时间多于内连接</p>
</li>
<li><p>优化器在选择表连接顺序时，可以有更多更灵活的选择，从而可以选择更好的表连接顺序，加快查询执行的速度</p>
</li>
<li><p>表的一些连接算法(如块嵌套连接和索引循环连接)将规模小的或筛选条件最严格的作为外表，可以减少不必要的IO开销，极大加快算法执行的速度</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515204036869.png" alt="image-20210515204036869"></p>
</li>
</ul>
<p>以下分三种情况讨论表2-8</p>
<ul>
<li>左外连接转为内连接</li>
<li>全外连接转为左外连接</li>
<li>右外连接转为内连接</li>
</ul>
<h4 id="2-2-5-2、外连接消除的条件"><a href="#2-2-5-2、外连接消除的条件" class="headerlink" title="2.2.5.2、外连接消除的条件"></a>2.2.5.2、外连接消除的条件</h4><p>外连接可以转为内连接的条件：where子句中与内表相关的条件满足空值拒绝（reject-NULL条件），一般认为满足以下任意一种情况，就满足空值拒绝：</p>
<ul>
<li>条件可以保证从结果中排除外连接右侧（右表）生成的值为NULL的行，所以能使该查询在语义上等效于内连接</li>
<li>外连接的提供空值的一侧为另一侧的每行只返回一行。如果该条件为真，则不存在提供空值的行，并且外连接等价于内连接</li>
</ul>
<h3 id="2-2-6、嵌套连接消除"><a href="#2-2-6、嵌套连接消除" class="headerlink" title="2.2.6、嵌套连接消除"></a>2.2.6、嵌套连接消除</h3><p>多表连接时有时会存在嵌套的情况，而嵌套连接不能够利用交换表的位置而获得优化。当执行连接操作的次序不是从左到右逐个进行时，就说这样的连接表达式存在嵌套。</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515205708740.png" alt="image-20210515205708740"></p>
<p>先t2和t3连接得到中间结果{t2t3}后再与t1连接，这种方式就是嵌套连接，括号不可以去掉，没有去掉括号的等价形式。</p>
<p>另外，如下格式也是嵌套连接，即使括号去掉不影响语义，这种格式用括号对连接次序做了区分</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210515210149035.png" alt="image-20210515210149035"></p>
<p>综上，我们可以得到下面两条结论：</p>
<ul>
<li>如果连接表达式只包括内连接，括号可以去掉，这意味着表之间的次序可以交换，这是关系代数中连接的交换律的应用</li>
<li>如果连接表达式包括外连接，括号不可以去掉，意味着表之间的次序只能按照原语义进行，至多能执行外连接向内连接转换的优化</li>
</ul>
<h3 id="2-2-7、连接消除"><a href="#2-2-7、连接消除" class="headerlink" title="2.2.7、连接消除"></a>2.2.7、连接消除</h3><p>连接分类</p>
<ul>
<li>根据连接语义方式的不同：内连接、外连接、半连接、反半连接</li>
<li>根据连接对象的不同：自连接和非自连接</li>
<li>根据连接条件的有无：笛卡尔积式的连接和带有限定条件的连接</li>
<li>根据连接条件形式的不同：等值连接和范围连接</li>
</ul>
<p>可能存在一些连接，连接对象可以被去掉，因为这样的连接对象存在只会带来连接计算的消耗，而对连接结果没有影响，如下面的情况一，二，三</p>
<p>情况一：主外键关系的表进行连接，可以消除主键表，这不会影响对外键表的查询</p>
<p>情况二：唯一键作为连接条件，三表内连接可以去掉中间表（中间表的列只作为连接条件）</p>
<p>情况三：其他一些特殊情况，可以去掉连接 操作（可消除的表除了作为连接对象之外，不出现在任何子句中）</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210516092941770.png" alt="image-20210516092941770"></p>
<h3 id="2-2-8、语义优化"><a href="#2-2-8、语义优化" class="headerlink" title="2.2.8、语义优化"></a>2.2.8、语义优化</h3><ul>
<li>语义转换：根据完整性约束等信息对某特定语义进行推理，进而得到一种查询效率不同但结果相同的查询</li>
<li>语义优化：因为语义转换形成的优化称为语义优化</li>
</ul>
<p>语义优化常见方式如下：</p>
<ul>
<li>连接消除：对一些连接操作先不必评估代价，根据已知信息能推知结果或得到一个简化的操作</li>
<li>连接引入：增加连接有助于原关系变小或原关系的选择率降低</li>
<li>谓词引入：根据完整性约束等信息引入新谓词，如引入基于索引的列，可能使查询更快</li>
<li>检测空回答集：查询语句中的谓词与约束相悖，如check约束限定score是60到100，而一个查询条件是score&lt;60，则能立刻推知条件不成立</li>
<li>排序优化：order by操作通常由索引或排序完成；如果能利用索引，则排序操作可以省略</li>
<li>唯一性使用：利用唯一性，索引等特点，检查是否存在不必要的distinct操作，如主键上的distinct可以消除掉</li>
</ul>
<h3 id="2-2-9、针对非SPJ的优化"><a href="#2-2-9、针对非SPJ的优化" class="headerlink" title="2.2.9、针对非SPJ的优化"></a>2.2.9、针对非SPJ的优化</h3><p>目前决策支持系统，数据仓库，OLAP系统的应用日益广泛，SQL语句中的group by、聚合函数、Windows函数（分析函数）等被广泛应用。早期的关系数据库System-R对group by和聚合等操作的处理放在完成所有的连接和选择操作之后进行，执行效率很低。因此，现代的商业和开源数据库，都使用了一些非SPJ的优化技术</p>
<h4 id="2-2-9-1、group-by的优化"><a href="#2-2-9-1、group-by的优化" class="headerlink" title="2.2.9.1、group by的优化"></a>2.2.9.1、group by的优化</h4><p>可考虑<strong>分组转换技术</strong>，即对分组操作、聚合操作与连接操作的位置进行交换，常见方式如下：</p>
<ul>
<li>分组操作下移：下移是指在查询树上让分组操作尽量靠近叶子节点，使得分组操作的节点低于一些选择操作。group by操作可能大幅度减少关系元组的个数，如果能够对某个关系先进行分组操作，再进行表连接，很可能提高连接效率。</li>
<li>分组操作上移：如果连接操作能够过滤掉大部分元组，则先进行连接后进行group by操作，可以提高分组操作的效率。</li>
</ul>
<p>因为group by操作上移或者下移都不能保证重写后的查询效率一定更高，所以，要在查询优化器中采用<strong>基于代价</strong>的方式来估算几种路径的优劣，另外<strong>要尽量应用索引</strong>。</p>
<h4 id="2-2-9-2、order-by的优化"><a href="#2-2-9-2、order-by的优化" class="headerlink" title="2.2.9.2、order by的优化"></a>2.2.9.2、order by的优化</h4><p>可以考虑如下几方面：</p>
<ul>
<li>排序消除</li>
<li>排序下推</li>
</ul>
<h4 id="2-2-9-3、distinct的优化"><a href="#2-2-9-3、distinct的优化" class="headerlink" title="2.2.9.3、distinct的优化"></a>2.2.9.3、distinct的优化</h4><p>可以考虑如下几方面：</p>
<ul>
<li>distinct消除</li>
<li>distinct下推</li>
<li>distinct迁移</li>
</ul>
<h2 id="2-3、启发式规则在逻辑优化阶段的应用"><a href="#2-3、启发式规则在逻辑优化阶段的应用" class="headerlink" title="2.3、启发式规则在逻辑优化阶段的应用"></a>2.3、启发式规则在逻辑优化阶段的应用</h2><p>逻辑优化阶段使用的启发式规则通常包括如下两类：</p>
<ul>
<li>一定能带来优化效果的：<ul>
<li>优先做选择和投影（连接条件在查询树上下推）</li>
<li>嵌套连接的消除</li>
<li>外连接的消除</li>
<li>连接的消除</li>
<li>使用等价谓词重写对条件化简</li>
<li>语义优化</li>
<li>剪掉冗余操作（一些剪枝优化技术）、最小化查询块</li>
</ul>
</li>
<li>变换未必会带来性能的提高，需根据代价选择，包括：<ul>
<li>分组的合并</li>
<li>使用索引优化分组、排序，distinct等操作</li>
<li>对视图的查询变为基于表的查询</li>
<li>连接条件的下推</li>
<li>分组的下推</li>
<li>连接提取公共表达式</li>
<li>谓词的上拉</li>
<li>用连接取代集合操作</li>
<li>用UNIONALL取代OR操作</li>
</ul>
</li>
</ul>
<h1 id="3、物理查询优化"><a href="#3、物理查询优化" class="headerlink" title="3、物理查询优化"></a>3、物理查询优化</h1><p>查询优化器在物理优化阶段，主要解决的问题是：</p>
<ul>
<li>从可选的单表扫描方式中，挑选什么样的单表扫描方式最优？</li>
<li>对于两表连接，如何连接最优？</li>
<li>对于多表连接，哪种连接顺序最优？</li>
<li>对于多表连接，是否需要对每种连接顺序都探索？如果不全部探索，如何找到一种最优组合？</li>
</ul>
<p>在查询优化器实现早期，认为使用逻辑优化技术（即使用关系代数规则和启发式规则对查询进行优化）后，生成的执行计划就是最优的。现在，引入了基于代价的查询优化方式后，对查询计划做了定量的分析，对每一个执行方式进行评估，挑出代价最小的作为最优的计划。目前主流数据库的优化器通常都融合了这两种方式。</p>
<h2 id="3-1、查询代价估算"><a href="#3-1、查询代价估算" class="headerlink" title="3.1、查询代价估算"></a>3.1、查询代价估算</h2><p>查询代价估算的重点是代价估算模型，这是物理查询优化的依据。此外，选择率也很重要，对代价求解起着重要作用</p>
<h3 id="3-1-1、代价模型"><a href="#3-1-1、代价模型" class="headerlink" title="3.1.1、代价模型"></a>3.1.1、代价模型</h3><p>查询代价估算基于CPU代价和IO代价，计算公式如下：</p>
<p>总代价 = IO代价 +  CPU代价</p>
<p>COST = p * a_page_cpu_time + W * T</p>
<p>其中p是计划运行时访问的页面数，a_page_cpu_time是每个页面读取的时间花费，其乘积 = IO代价</p>
<p>T为访问的元组数，W为权重因子，表明IO到CPU的相关性，又称选择率，它等于满足条件“A<op>a”的元组数和R中所有元组N的比值。他们的乘积反映了CPU代价</p>
<h3 id="3-1-2、选择率计算的常用方法"><a href="#3-1-2、选择率计算的常用方法" class="headerlink" title="3.1.2、选择率计算的常用方法"></a>3.1.2、选择率计算的常用方法</h3><p>选择率在代价估算模型中占有重要地位，其精确程度直接影响最优计划的选取。选择率计算常用方法如下：</p>
<ul>
<li>无参数方法：使用ad hoc（点对点）数据结构或直方图维护属性值的分布，直方图最常用</li>
<li>参数法：使用具有一些自由统计参数（参数是预先估计出来的）的数学分布函数逼近真实分布</li>
<li>曲线拟合法：为克服参数法的不灵活性，用一般多项式来标准最小方差来逼近属性值的分布</li>
<li>抽样法：从数据库中抽取部分样本元组，针对这些样本进行查询，然后收集统计数据，只有足够的样本被测试之后，才能达到预期的精度</li>
<li>综合法：将以上几种方法结合起来，如抽样法和直方图法结合</li>
</ul>
<h2 id="3-2、单表扫描算法"><a href="#3-2、单表扫描算法" class="headerlink" title="3.2、单表扫描算法"></a>3.2、单表扫描算法</h2><p>单表扫描需要从表上获取元组，直接关系到物理IO的读取，所以不同的单表扫描方式，有不同的代价</p>
<h3 id="3-2-1、常用的单表扫描算法"><a href="#3-2-1、常用的单表扫描算法" class="headerlink" title="3.2.1、常用的单表扫描算法"></a>3.2.1、常用的单表扫描算法</h3><p>对于单表数据的获取，有如下方式：</p>
<ul>
<li>全表扫描表数据：为获取表的全部元组，读取表对应的全部数据页</li>
<li>局部扫描表数据：为获取表的部分元组，读取指定位置对应的数据页</li>
</ul>
<p>单表扫描和IO操作密切相关，因此很多算法在IO上倾注精力，常见单表扫描算法如下：</p>
<ul>
<li>顺序扫描：从物理存储上按照存储顺序直接读取表数据；当无索引可用，或访问表中大部分数据，或表数据量很小时，效果较好</li>
<li>索引扫描：根据索引键读索引，找出物理元组的位置；根据从索引中找到的位置，从存储中读取数据页；索引扫描可以将元组按排序的顺序返回；若选择率较低，则读数据花费的IO会显著减少</li>
<li>只读索引扫描：根据索引键读索引，索引中的数据能够满足条件判断，不需要读取数据页</li>
<li>行扫描：用于直接定位表中的某一行。通常给元组增加一个特殊的列，可以直接计算元组的物理位置，然后直接读取元组对应的页面。在PostgreSQL中称为Tid扫描，此方式在元组头上增加CTID的列，用该列可以直接计算本条元组的物理存储位置</li>
<li>并行表扫描：对同一个表，并行地、通过顺序的方式获取表数据，结果是得到一个完整的表数据</li>
<li>并行索引扫描：对同一个表，并行地、通过索引的方式获取表数据，将结果合并在一起</li>
<li>组合多个索引扫描：对同一个元组的组合条件（AND或OR谓词组合的多个索引列上的多条件查询）进行多次索引扫描，然后在内存里用一个位图来描述索引扫描结果中符合索引条件的元组位置</li>
</ul>
<h3 id="3-2-2、单表扫描代价计算"><a href="#3-2-2、单表扫描代价计算" class="headerlink" title="3.2.2、单表扫描代价计算"></a>3.2.2、单表扫描代价计算</h3><p>因为单表扫描是将数据从存储系统调入内存，因此其代价要考虑IO花费。顺序扫描，主要是IO花费 + 元组从页面中解析的花费；索引扫描和其他方式的扫描，由于元组不是全部元组，因此要考虑选择率的问题。单表扫描代价估算公式如下：</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210516105429946.png" alt="image-20210516105429946"></p>
<h2 id="3-3、索引"><a href="#3-3、索引" class="headerlink" title="3.3、索引"></a>3.3、索引</h2><p>索引是建立在表上的，本质上是通过索引直接定位表的物理元组，加快数据获取的方式，因此索引优化的手段应该归属到物理查询优化阶段。</p>
<h3 id="3-3-1、如何利用索引"><a href="#3-3-1、如何利用索引" class="headerlink" title="3.3.1、如何利用索引"></a>3.3.1、如何利用索引</h3><p>索引是提高查询优化的有效手段，如果某个列存在索引，并不意味着能够有效使用，通常查询优化器使用索引的原则如下：</p>
<ul>
<li>索引列出现在where，having，on子句中，有利于利用索引过滤元组</li>
<li>索引列是被连接的表（内表）对象的列且存在于连接条件中</li>
<li>还有一些特殊情况，如排序操作、在索引列上求MIN、MAX值</li>
</ul>
<p>对于索引列，索引可用的条件如下：</p>
<ul>
<li>在where，having，join/on条件中出现“key<op>常量”格式的条件子句（索引列不能参与带有变量的表达式的运算）</li>
<li>操作符不能是&lt;&gt;（不等于操作符在任何类型的列上均不能使用索引，可以认为这是一个优化规则，因为这种情况下，顺序扫描效果更好）</li>
<li>索引列的值选择率越低，索引越有效，通常认为选择率小于0.1则索引扫描效果会比较好</li>
</ul>
<h3 id="3-3-2、索引列的位置对使用索引的影响"><a href="#3-3-2、索引列的位置对使用索引的影响" class="headerlink" title="3.3.2、索引列的位置对使用索引的影响"></a>3.3.2、索引列的位置对使用索引的影响</h3><p>在查询语句中，索引列在不同的位置对索引的使用有着不同的影响。</p>
<h4 id="3-3-2-1、对目标列、where等条件子句的影响"><a href="#3-3-2-1、对目标列、where等条件子句的影响" class="headerlink" title="3.3.2.1、对目标列、where等条件子句的影响"></a>3.3.2.1、对目标列、where等条件子句的影响</h4><h4 id="3-3-2-2、对group-by子句的影响"><a href="#3-3-2-2、对group-by子句的影响" class="headerlink" title="3.3.2.2、对group by子句的影响"></a>3.3.2.2、对group by子句的影响</h4><h4 id="3-3-2-3、对having子句的影响"><a href="#3-3-2-3、对having子句的影响" class="headerlink" title="3.3.2.3、对having子句的影响"></a>3.3.2.3、对having子句的影响</h4><h4 id="3-3-2-4、对order-by子句的影响"><a href="#3-3-2-4、对order-by子句的影响" class="headerlink" title="3.3.2.4、对order by子句的影响"></a>3.3.2.4、对order by子句的影响</h4><h4 id="3-3-2-5、对distinct的影响"><a href="#3-3-2-5、对distinct的影响" class="headerlink" title="3.3.2.5、对distinct的影响"></a>3.3.2.5、对distinct的影响</h4><h3 id="3-3-3、联合索引对索引使用的影响"><a href="#3-3-3、联合索引对索引使用的影响" class="headerlink" title="3.3.3、联合索引对索引使用的影响"></a>3.3.3、联合索引对索引使用的影响</h3><h3 id="3-3-4、多个索引对索引使用的影响"><a href="#3-3-4、多个索引对索引使用的影响" class="headerlink" title="3.3.4、多个索引对索引使用的影响"></a>3.3.4、多个索引对索引使用的影响</h3><h2 id="3-4、两表连接算法"><a href="#3-4、两表连接算法" class="headerlink" title="3.4、两表连接算法"></a>3.4、两表连接算法</h2><p>关系代数一项重要的操作是连接运算，多表连接是建立在两表连接基础上的，研究两表连接的方式对连接效率的提高有着直接的影响。</p>
<h3 id="3-4-1、基本的两表连接算法"><a href="#3-4-1、基本的两表连接算法" class="headerlink" title="3.4.1、基本的两表连接算法"></a>3.4.1、基本的两表连接算法</h3><p>主要有嵌套循环连接算法、归并连接算法、hash连接算法。</p>
<h4 id="3-4-1-1、嵌套循环连接算法"><a href="#3-4-1-1、嵌套循环连接算法" class="headerlink" title="3.4.1.1、嵌套循环连接算法"></a>3.4.1.1、嵌套循环连接算法</h4><p>两表做连接，最基本的连接算法就是嵌套循环连接算法，该算法描述如下：</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210516111754226.png" alt="image-20210516111754226"></p>
<p>数据库引擎在实现该算法时，以元组为单位进行连接，而元组是从内存页面获取来的，内存页面是从存储系统通过IO获得的，因此每个IO申请以块为单位尽量读入多个页面，可以改进算法，改进后的称为<strong>基于块的嵌套循环连接算法。</strong></p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210516130351611.png" alt="image-20210516130351611"></p>
<p>无论是嵌套循环连接算法还是基于块的嵌套循环连接算法，本质都是在一个两层循环中各自拿出一个元组，逐一匹配是否满足连接条件。其他一些两表连接算法，多是在此基础上进行的改进，如在考虑了聚集索引和二级索引的情况下，如果内表有索引可用，则可以加快连接的速度。如果外表元组较少，内层的元组驻留内存多一些（如一些查询优化器采用物化技术固化内层的元组），则能有效提高连接的效率。上述两种算法适用于内连接，左外连接，半连接，反半连接等语义的处理。</p>
<h4 id="3-4-1-2、排序归并连接算法"><a href="#3-4-1-2、排序归并连接算法" class="headerlink" title="3.4.1.2、排序归并连接算法"></a>3.4.1.2、排序归并连接算法</h4><p>算法步骤是：为两个表创建可用内存缓冲区数为M的M个子表，将每个子表排好序；然后读入每个子表的第一个块到M个块中，找出其中最小的先进行两个表的元组的匹配，找出次小的匹配……以此类推，完成其他子表的两表连接。</p>
<p>归并连接算法要求内外表都是有序的，所以对于内外标都要排序，如果连接列是索引列，则可以利用索引进行排序。该算法适用于内连接，左外连接，右外连接，全外连接，半连接，反半连接等语义的处理。</p>
<h4 id="3-4-1-3、hash连接算法"><a href="#3-4-1-3、hash连接算法" class="headerlink" title="3.4.1.3、hash连接算法"></a>3.4.1.3、hash连接算法</h4><p>基于hash的两表连接算法常见的有以下三种：</p>
<ul>
<li>用连接列作为hash的关键字，对内表进行hash运算建立哈希表，然后对外表的每个元组的连接用hash函数求值，值映射到内表建立好的哈希表就可以连接了；否则，探索外表下一个元组。这样的哈希连接算法称为<strong>简单hash连接算法（Simple Hash Join，SHJ）</strong>。</li>
<li>如果把内表和外表分为等大小的子表，然后对外表和内表的每个相同下标值的子表进行SHJ算法的操作，可以避免因内存小而反复读入内外表数据的问题，这样的改进算法称为<strong>优美hash连接算法（Grace Hash Join，GHJ）</strong></li>
<li>结合了SHJ和GHJ优点的算法称为<strong>混合hash连接算法（Hybrid Hash Join，HHJ）</strong>。HHJ算法是把第一个子表保存到内存不刷出，如果内存很大，则子表能容纳更大量的数据，效率接近于SHJ</li>
</ul>
<p>Hash类的算法都存在hash冲突，如GHJ算法，当内存小或者数据倾斜（数据不能均匀地分布到Hash桶，Hash处理后集中在少量桶中）时，通过把一个表划分为多个子表的方式，仍然不能消除反复读入内外表数据的问题（称为“分区溢出”）。</p>
<p>Hash连接算法只适用于<strong>数据类型相同的等值连接</strong>。Hash连接要存储Hash元组到Hash桶，要求较大内存。如果表中连接列值重复率很高不能均匀分布，相同值的元组映射到少数几个桶中，Hash连接算法效率就不高。Hash连接要求内表不能太大，通常查询优化器会申请一段内存存放hash表，如果超出且不能继续动态申请，则需要写临时文件，这会导致IO颠簸（如PostgreSQL就存在此类问题）。</p>
<p>Hash连接算法适用于内连接，左外连接，右外连接，全外连接，半连接，反半连接等语义的处理。</p>
<h3 id="3-4-2、进一步认识两表连接算法"><a href="#3-4-2、进一步认识两表连接算法" class="headerlink" title="3.4.2、进一步认识两表连接算法"></a>3.4.2、进一步认识两表连接算法</h3><p>从内存容量角度看，两表连接算法分为一趟算法，两趟算法，甚至多趟算法。这里的趟是指从存储系统获取全部数据的次数。趟数是一种方式，不是算法思想的改进，是代码实现中为减少IO所做的改进工作。</p>
<p>结合连接算法和索引、趟数的关系，两表连接算法对于查询优化器的意义如下表所示：</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210516145539689.png" alt="image-20210516145539689"></p>
<h3 id="3-4-3、连接操作代价计算"><a href="#3-4-3、连接操作代价计算" class="headerlink" title="3.4.3、连接操作代价计算"></a>3.4.3、连接操作代价计算</h3><p>连接操作花费CPU资源，理论上连接操作代价估算原理如下表：</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210516145832475.png" alt="image-20210516145832475"></p>
<p>公式中涉及参数含义如下：</p>
<ul>
<li>a_tuple_cpu_time：获取一个元组消耗的CPU时间</li>
<li>N-outer：扫描获取的外表的元组数</li>
<li>N-inner：扫描获取的内表的元组数，N-inner = N-inner-all * 选择率，其中N-inner-all表示内表所有元组数</li>
<li>C-outer：扫描外表的代价，C-outer = N-outer * a_tuple_cpu_time</li>
<li>C-inner：扫描内表的代价，C-inner = N-inner * a_tuple_cpu_time</li>
<li>C-inner-index：使用索引扫描内表的代价，通常会比C-inner小</li>
<li>C-outersort：外表排序的代价</li>
<li>C-innersort：内表排序的代价</li>
<li>C-createhash：创建hash的代价</li>
</ul>
<h2 id="3-5、多表连接算法"><a href="#3-5、多表连接算法" class="headerlink" title="3.5、多表连接算法"></a>3.5、多表连接算法</h2><p>多表连接算法实现的是在查询路径生成的过程中，根据代价估算，从各种可能的候选路径中找出最优的路径。它需要解决两个问题：</p>
<ul>
<li>多表连接的顺序</li>
<li>多表连接的搜索空间：N个表的连接可能有N！种连接组合，这可能构成一个巨大的搜索空间。如何将搜索空间限制在一个可接受的范围内，并高效生成查询执行计划将成为一个难点</li>
</ul>
<h3 id="3-5-1、多表连接顺序"><a href="#3-5-1、多表连接顺序" class="headerlink" title="3.5.1、多表连接顺序"></a>3.5.1、多表连接顺序</h3><p>多表间的连接顺序表示了查询计划树的基本形态。在1990年，Schneder等人在研究查询树模型时提出了左深树，右深树和紧密树3种形态，如下图</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210516151149070.png" alt="image-20210516151149070"></p>
<p>即使是同一种树的生成方式，也有细节需要考虑。如上图a中{A,B}和{B,A}两种连接方式花费可能不同。比如最终连接结果{A,B,C}则需要验证比较6种连接方式，找出最优的一种作为下次和其他表连接的依据。</p>
<p>人们针对以上树的形成、形成的树花费代价最少的，提出了诸多算法，树的形成过程主要有以下两种策略：</p>
<ul>
<li>自顶向下：从SQL表达式树的树根开始，向下进行，估计每个节点可能的执行方法，计算每种组合的代价，从中挑选最优的</li>
<li>自底向上：从SQL表达式树的树叶开始，向上进行，计算每个子表达式所有实现方法的代价，从中挑选最优的，再和上层进行连接，直至树根</li>
</ul>
<p>多数数据库都采用第二种方式–自底向上，构造查询计划树。</p>
<h3 id="3-5-2、常用的多表连接算法"><a href="#3-5-2、常用的多表连接算法" class="headerlink" title="3.5.2、常用的多表连接算法"></a>3.5.2、常用的多表连接算法</h3><p>多表连接搜索最优查询树，有很多算法，如启发式、分枝界定计划枚举、贪心、动态规划、爬山法、System R优化方法等</p>
<h4 id="3-5-2-1、动态规划"><a href="#3-5-2-1、动态规划" class="headerlink" title="3.5.2.1、动态规划"></a>3.5.2.1、动态规划</h4><p>在数据库领域，动态规划算法主要解决多表连接的问题。它是自底向上进行的，即从叶子开始做第一层，然后开始对每层的关系做两两连接（如果满足内连接进行两两连接，不满足则不可对全部表进行两两连接），构造出上层，逐次递推到树根。以下介绍具体步骤：</p>
<ul>
<li>初始状态：构造第一层关系，即叶子结点，每个叶子对应一个单表，为每一个待连接的关系计算最优路径（单表的最优路径就是单表的最佳访问方式，通过评估不同的单表的数据扫描方式代价，找出代价最小的作为每个单表的局部最优路径）</li>
<li>归纳：当第1层到第n-1层的关系已经生成，那么求解第n层的关系方法为：将第n-1层的关系与第一层中的每个关系连接，生成新的关系（对新关系的大小进行估算），放于第n层，且每一个新关系，均求解最优路径。每层路径的生成都是基于下层生成的最优路径，这满足最优化原理的要求。</li>
</ul>
<p>还有的改进算法，在生成第n层的时候，除了通过第n-1层和第一层连接外，还可以通过第n-2层和第二层连接…</p>
<p>例如对于下面的查询语句</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210516154200387.png" alt="image-20210516154200387"></p>
<p>生成最优查询计划的过程如下表</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210516154251032.png" alt="image-20210516154251032"></p>
<p>PostgreSQL查询优化器求解多表连接时，采用了这种算法。</p>
<h4 id="3-5-2-2、启发式算法"><a href="#3-5-2-2、启发式算法" class="headerlink" title="3.5.2.2、启发式算法"></a>3.5.2.2、启发式算法</h4><p>启发式算法是相对最优化算法提出的，是一个基于直观或者经验构造的算法，不能保证找到最好的查询计划。在数据库的查询优化器中，启发式一直贯穿于整个查询优化阶段，在逻辑查询优化阶段和物理查询优化阶段，都有一些启发式规则可用。PostgreSQL，MySQL，Oracle等数据库在实现查询优化器时，采用了启发式和其他方式相结合的方式。</p>
<p>物理查询优化阶段常用启发式规则如下：</p>
<ul>
<li>关系R在列X上建立索引，且对R的选择操作发生在列X上，则采用索引扫描方式</li>
<li>R连接S，其中一个关系上的连接列存在索引，则采用索引连接且此关系作为内表</li>
<li>R连接S，其中一个关系上的连接列是排序的，则采用排序连接比hash连接好</li>
</ul>
<h4 id="3-5-2-3、贪心算法"><a href="#3-5-2-3、贪心算法" class="headerlink" title="3.5.2.3、贪心算法"></a>3.5.2.3、贪心算法</h4><p>贪心算法最后得到的是局部最优解，不一定全局最优，其实现步骤如下：</p>
<ol>
<li>初始，算法选出的候选对象集合为空</li>
<li>根据选择函数，从剩余候选对象中选出最有可能构成解的对象</li>
<li>如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑</li>
<li>如果集合中加上该对象后可行，就加到集合里</li>
<li>扩充集合，检查该集合是否构成解</li>
<li>如果贪心算法正确工作，那么找到的第一个解通常都是最优的，可以终止算法</li>
<li>继续执行第二步</li>
</ol>
<p>MySQL查询优化器求解多表连接时采用了这种算法</p>
<h4 id="3-5-2-4、System-R算法"><a href="#3-5-2-4、System-R算法" class="headerlink" title="3.5.2.4、System-R算法"></a>3.5.2.4、System-R算法</h4><p>对自底向上的动态规划算法进行了改进，主要思想是把子树的查询计划的最优查询计划和次优查询计划保留，用于上层的查询计划生成，以便使得查询计划总体上最优。</p>
<h4 id="3-5-2-5、遗传算法"><a href="#3-5-2-5、遗传算法" class="headerlink" title="3.5.2.5、遗传算法"></a>3.5.2.5、遗传算法</h4><p>遗传算法（GA）是美国学着Holland与1975年首次提出，是一种启发式算法， 基于自然群体遗传演化机制的高效搜索算法。它抛弃了传统的搜索方式，模拟自然界生物进化过程，采用人工进化的方式对目标空间进行随机化搜索。它将问题域中的可能解看做是群体的一个个体（染色体），并将每一个个体编码成符号串形式，模拟达尔文的遗传选择和自然淘汰的生物进化过程，对群体反复进行基于遗传学的操作（选择，交叉，变异）根据预定的目标适应度函数对每个个体进行评价，依据“适者生存，优胜劣汰”的进化规则，不断得到更优的群体，同时以全局并行搜索方式来搜索优化群体中的最优个体，求得满足要求的最优解。</p>
<p>遗传算法通过作用于“染色体”上的“基因”，寻找好的“染色体”来求解问题（对算法所产生的每个“染色体”进行评价，并基于适应度值来改造“染色体”，使适用性好的“染色体”比适应性差的“染色体”有更多的“繁殖机会”）</p>
<p>下面介绍一些遗传算法的主要概念：</p>
<ul>
<li>群体：表示GA的搜索空间</li>
<li>个体：在多表连接中是每个基本关系或者中间生成的临时关系</li>
<li>染色体：个体的标志，由若干基因组成，是GA操作的基本对象，所以操作个体实则是操作染色体，染色体用字符串表示</li>
<li>基因：多段基因组成染色体，基因变异导致基因不断被优化</li>
<li>适应度：表示个体对环境的适应程度，通常由某一适应函数表示。对应执行策略的执行代价</li>
<li>选择：GA基本操作之一，依据个体的适应度，在群体中按照一定的概率选择可以作为父本的个体，适应度大的被选中的概率高，体现了“适者生存，优胜劣汰”的进化规则</li>
<li>交叉：GA的基本操作之一，即将父本个体按照一定的概率随机地交换基因形成新的个体</li>
<li>变异：GA的基本操作之一，即按一定的概率随机改变某个个体的基因值</li>
</ul>
<p>接下来介绍遗传算法设计的关键问题</p>
<ul>
<li>串的编码方式：本质是编码问题，一般把问题的各种参数用二进制形式进行编码，构成子串；然后把子串拼接构成“染色体”串。串长度及编码形式对算法收敛影响极大</li>
<li>适应度函数的确定：又称对象函数或问题的“环境”，是问题求解品质的测量函数。一般可以把问题的模型函数作为适应度函数，但有时需要另行构造</li>
<li>遗传算法自身参数设定：遗传算法自身参数有3个，即群体大小n，交叉概率Pc和变异概率Pm，具体如下：<ul>
<li>群体大小n太小时难以求出最优解，太大则增长收敛时间，一般n取30~160</li>
<li>交叉概率Pc太小时难以向前搜索，太大则容易破坏高适应值的结构，一般取0.25~0.75</li>
<li>变异概率Pm太小时难以产生新的基因结构，太大使遗传算法成了单纯的随机搜索，一般取0.01~0.2</li>
</ul>
</li>
</ul>
<p>遗传算法的主要步骤如下：</p>
<ol>
<li>随机初始化种群</li>
<li>评估初始的种群，即为种群计算每个个体的适应值且对所有个体排序</li>
<li>如果没有达到预定演化数（可以是一个确定的、与连接的表的个数无关的值，这样保证搜索空间一定不会因连接的表的个数增多导致搜索空间指数级增大），则继续下一步，否则结束算法</li>
<li>选择父体，随机挑选父体dad和母体mum</li>
<li>杂交，父体和母体杂交得到新个体child</li>
<li>变异，在某些个别条件下对新个体变异（不是大概率变异，不是每次都需要变异）</li>
<li>计算新个体的适应值，并把适应值排序插入到种群，种群中排名最后的则被淘汰</li>
<li>继续第三步</li>
</ol>
<h4 id="3-5-2-6、其他算法"><a href="#3-5-2-6、其他算法" class="headerlink" title="3.5.2.6、其他算法"></a>3.5.2.6、其他算法</h4><p>还有一些其他算法，如爬山法、分支界定枚举法、随机算法、模拟退火算法或多种算法相结合，都可以用于查询优化多表连接的生成。</p>
<h3 id="3-5-3、多表连接算法的比较"><a href="#3-5-3、多表连接算法的比较" class="headerlink" title="3.5.3、多表连接算法的比较"></a>3.5.3、多表连接算法的比较</h3><p>多表连接算法比较如下图</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210516165246747.png" alt="image-20210516165246747"></p>
<h1 id="11、MySQL查询优化器概述"><a href="#11、MySQL查询优化器概述" class="headerlink" title="11、MySQL查询优化器概述"></a>11、MySQL查询优化器概述</h1><p>MySQL查询优化器主要功能是完成select语句的执行，此外，还有个重要功能，就是使用关系代数、启发式规则、代价估算模型等技术，提高select执行的效率。</p>
<p>MySQL查询优化器实现了第二章介绍的大多数查询优化技术，这些技术用于对SPJ和非SPJ类型的查询语句进行优化。</p>
<p>本章从整体上介绍MySQL查询优化器，分别对其执行过程、架构、层次、设计思想、主要概念、代码结构宏观探讨MySQL查询优化器的实现。</p>
<h2 id="11-1、MySQL查询执行过程"><a href="#11-1、MySQL查询执行过程" class="headerlink" title="11.1、MySQL查询执行过程"></a>11.1、MySQL查询执行过程</h2><p>MySQL查询执行过程分为4个阶段</p>
<ul>
<li>语法分析阶段：将SQL语句经词法和语法分析后变换为一棵查询树st_select_lex传给优化器，并对SQL表达的语义进行检查</li>
<li>生成逻辑查询执行计划阶段：优化器在查询树中遍历每个关系，确定关系是否是常量表、为每个关系查找可用索引、运用关系代数原理和启发式规则进行逻辑上的查询优化（如消除子查询，消除外连接等）</li>
<li>生成物理查执行计划阶段：优化器对各个连接表进行排序，然后再求解多表连接最优路径，对于每个关系尽量应用索引计算其代价，找出代价最小的路径后保存到JOIN类的best_positions</li>
<li>执行查询执行计划阶段：直接把查询执行计划传到执行器执行</li>
</ul>
<p>四个阶段如下图</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210517152340375.png" alt="image-20210517152340375"></p>
<p>逻辑查询优化阶段：基于关系代数规则和启发式规则，把SQL经过等价的代数转换，变为一种更节省IO的执行序列</p>
<p>物理查询优化阶段：在解决多表连接时有两套算法：一是用户指定表连接次序的算法；二是混杂了贪心和穷举思想的算法</p>
<h2 id="11-2、MySQL查询优化器的架构和设计思想"><a href="#11-2、MySQL查询优化器的架构和设计思想" class="headerlink" title="11.2、MySQL查询优化器的架构和设计思想"></a>11.2、MySQL查询优化器的架构和设计思想</h2><p>查询优化器通过JOIN对象的prepare（MySQL5.7.19及以后版本这个方法被移到SELECT_LEX::prepare了）和optimize方法完成优化工作。</p>
<p>prepare完成的查询优化主要包括：子查询的冗余子句消除、IN类型子查询优化、将ANY/ALL等类型的子查询转换为MIN/MAX等操作，这是对简单子查询进行的优化；</p>
<p>JOIN.optimize函数完成的查询优化主要包括：子查询上拉，把外连接优化为内连接，消除嵌套连接，where子句、join/on子句、having子句条件表达式化简（尤其是对含有常量表达式的化简、等式合并），优化没有group by子句情况下的count(*)、MIN和MAX，裁剪分区partition（如果查询的表是分区表），确定多表的连接路径（单表是多表的特例，统计join的代价，两种多表连接算法选其一搜索最优的join顺序、生成执行计划）、优化等式谓词、优化distinct、创建临时表存储临时结果优化分组排序等操作。在这些过程中，MySQL并没有把优化过程明显分为逻辑查询优化阶段和物理查询优化阶段，而是互为混杂，这是MySQL查询优化器的一大特点。</p>
<h3 id="11-2-1、MySQL查询优化器架构"><a href="#11-2-1、MySQL查询优化器架构" class="headerlink" title="11.2.1、MySQL查询优化器架构"></a>11.2.1、MySQL查询优化器架构</h3><p>其架构和执行过程如下图：</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210517160204396.png"></p>
<p>主要经历4个过程：</p>
<ul>
<li>P1过程：SQL语句输入变为语法查询树</li>
<li>P2过程：查询预处理，主要是子查询优化</li>
<li>P3过程：将语法树变为逻辑关系查询树，进而变成物理查询执行计划，挑出最优计划</li>
<li>P4过程：依据最优查询执行计划得到查询结果</li>
</ul>
<p>主要经历以下4个模块</p>
<ul>
<li>M1模块：语法分析模块，执行P1</li>
<li>M2模块：查询预处理模块，执行P2</li>
<li>M3模块：查询优化模块，执行P3</li>
<li>M4模块：查询执行模块，执行P4</li>
</ul>
<p>实现MySQL查询优化器功能的主要是M3模块，其主要有两个子阶段工作：</p>
<ul>
<li>M3-S1逻辑查询优化阶段：把语法查询树通过关系代数原理，优化为关系代数查询树</li>
<li>M3-S2物理查询优化阶段：把关系代数查询树用于贪心算法，生成最优执行计划</li>
</ul>
<h3 id="11-2-2、MySQL查询优化器的层次"><a href="#11-2-2、MySQL查询优化器的层次" class="headerlink" title="11.2.2、MySQL查询优化器的层次"></a>11.2.2、MySQL查询优化器的层次</h3><p>代码层面看，逻辑结构不是很清晰；但是从技术层面看，还是可以分为逻辑查询优化和物理查询优化两个阶段。</p>
<h3 id="11-2-3、MySQL查询优化器设计思想"><a href="#11-2-3、MySQL查询优化器设计思想" class="headerlink" title="11.2.3、MySQL查询优化器设计思想"></a>11.2.3、MySQL查询优化器设计思想</h3><p>唯快唯实用</p>
<h2 id="11-3、主要概念"><a href="#11-3、主要概念" class="headerlink" title="11.3、主要概念"></a>11.3、主要概念</h2><h3 id="11-3-1、常量表"><a href="#11-3-1、常量表" class="headerlink" title="11.3.1、常量表"></a>11.3.1、常量表</h3><p>MySQL常量表的“常量”不同于编程语言中的常量。在MySQL中，常量表是指读取表上的数据行数是确定的零行或者一行，分为以下两种类型：</p>
<ul>
<li>system表：表中只有一行数据</li>
<li>const表：经where语句中的限制条件（“column=常数”格式的表达式）筛选后只有一行数据；这表明，在column列上存在索引，索引列可能是一个主键列，也可能是唯一键的列。</li>
</ul>
<p>满足这两个条件之一，就是常量表。</p>
<p>常量表的引入，实质上使得查询优化器能够基于规则对多表连接算法进行优化。因为多表连接算法，至少是个多重循环，而常量表的存在，使得循环层数得到消减</p>
<h3 id="11-3-2、表数据的访问方式"><a href="#11-3-2、表数据的访问方式" class="headerlink" title="11.3.2、表数据的访问方式"></a>11.3.2、表数据的访问方式</h3><p>单表又称简单表，是一个用户定义的逻辑概念上的table（create table定义）。MySQL对表的扫描分为两种类型：一是基于索引，而是直接在表上做数据的顺序扫描，这和其他数据库读取数据的方式没有本质区别。</p>
<p>MySQL基于索引的扫描又区分为多种情况，进而细化出各种扫描方式（JT_EQ_REF、JT_REF、JT_REF_OR_NULL等），根据这种细化的扫描方式又详细区分了不同的扫描花费估算公式（参看best_access_path函数），这使得估算更为精准，有助于更好地得到查询执行计划。</p>
<p>此外，MySQL提出一些其他的扫描方式（基于常量表），如JT_SYSTEM、JT_CONST等，这使得读取更为快捷，有助于得到更好的查询计划。对于JT_SYSTEM、JT_CONST的查找，优化器会通过join_read_system，join_read_const函数快速读取表中的值。</p>
<p>MySQL对表数据扫描方式的细化，区分了常量表和其他非常量表，使得在查询执行计划生成阶段就可以提前释放加在常量表上的锁（JOIN::optimize方法中对mysql_unlock_some_tables函数的调用）从而提高了并发度。</p>
<p>MySQL提供的各种数据访问方式如下表：</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210517164135780.png" alt="image-20210517164135780"></p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210517164206107.png" alt="image-20210517164206107"></p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210517164311450.png" alt="image-20210517164311450"></p>
<p>在MySQL代码中，提出两种单表扫描方式，分别是：index scan和table scan。</p>
<p>除了JT_ALL为表扫描外，其余多数属于索引扫描，只是根据索引的定义情况，区分了多种类型而已。</p>
<p>在opt_range.h文件中，定义了接口类QUICK_SELECT_I，其主要是利用索引实现快速查询定义的一个公共接口，处理一些特殊情况的查询（如类QUICK_GROUP_MIN_MAX_SELECT是为了在分组操作中求最值），其子类如下表所示：</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210517165107122.png" alt="image-20210517165107122"></p>
<h2 id="11-4、代码层次结构"><a href="#11-4、代码层次结构" class="headerlink" title="11.4、代码层次结构"></a>11.4、代码层次结构</h2><p>MySQL查询优化器的入口函数是SELECT_LEX::prepare函数（？）</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210517165454907.png" alt="image-20210517165454907"></p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210517165550608.png" alt="image-20210517165550608"></p>
<h1 id="12、MySQL查询优化器相关数据结构"><a href="#12、MySQL查询优化器相关数据结构" class="headerlink" title="12、MySQL查询优化器相关数据结构"></a>12、MySQL查询优化器相关数据结构</h1><p>本章介绍MySQL查询优化器模块的主要数据结构、数据结构之间的关联关系以及数据结构在查询优化器执行流程中的主要作用</p>
<h2 id="12-1、主要的类和数据结构"><a href="#12-1、主要的类和数据结构" class="headerlink" title="12.1、主要的类和数据结构"></a>12.1、主要的类和数据结构</h2><p>主要包括四个方面：</p>
<ul>
<li>查询树</li>
<li>基本对象</li>
<li>连接相关的对象与执行计划</li>
<li>代价估算类</li>
</ul>
<h3 id="12-1-1、查询树"><a href="#12-1-1、查询树" class="headerlink" title="12.1.1、查询树"></a>12.1.1、查询树</h3><p>语法分析器的结果是查询树，使用sql_lex.h下的st_select_lex类表示</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">    <span class="token comment" spellcheck="true">//where子句</span>
  Item <span class="token operator">*</span>m_where_cond<span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//having子句</span>
  Item <span class="token operator">*</span>m_having_cond<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//from子句中的表对象</span>
  SQL_I_List<span class="token operator">&lt;</span>TABLE_LIST<span class="token operator">></span>  table_list<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//group by子句</span>
  SQL_I_List<span class="token operator">&lt;</span>ORDER<span class="token operator">></span>       group_list<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//连接树</span>
  JOIN <span class="token operator">*</span>join<span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//顶层连接链表</span>
  List<span class="token operator">&lt;</span>TABLE_LIST<span class="token operator">></span> top_join_list<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//当前被分析的连接链表</span>
  List<span class="token operator">&lt;</span>TABLE_LIST<span class="token operator">></span> <span class="token operator">*</span>join_list<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//半连接嵌套链表</span>
  List<span class="token operator">&lt;</span>TABLE_LIST<span class="token operator">></span> sj_nests<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//基本表，即从SQL查询语句中分解出的基表</span>
  TABLE_LIST <span class="token operator">*</span>leaf_tables<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//基本表的数量</span>
  uint leaf_table_count<span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">//order by子句</span>
  SQL_I_List<span class="token operator">&lt;</span>ORDER<span class="token operator">></span> order_list<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//limit子句</span>
  Item <span class="token operator">*</span>select_limit<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/// LIMIT ... OFFSET clause, NULL if no offset is given</span>
  Item <span class="token operator">*</span>offset_limit<span class="token punctuation">;</span>


 <span class="token comment" spellcheck="true">//查询树的一些基本方法</span>
  TABLE_LIST<span class="token operator">*</span> <span class="token function">add_table_to_list</span><span class="token punctuation">(</span>THD <span class="token operator">*</span>thd<span class="token punctuation">,</span> Table_ident <span class="token operator">*</span>table<span class="token punctuation">,</span>
                LEX_STRING <span class="token operator">*</span>alias<span class="token punctuation">,</span>
                ulong table_options<span class="token punctuation">,</span>
                thr_lock_type flags<span class="token operator">=</span> TL_UNLOCK<span class="token punctuation">,</span>
                                enum_mdl_type mdl_type<span class="token operator">=</span> MDL_SHARED_READ<span class="token punctuation">,</span>
                List<span class="token operator">&lt;</span>Index_hint<span class="token operator">></span> <span class="token operator">*</span>hints<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
                                List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token operator">*</span>partition_names<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
                                LEX_STRING <span class="token operator">*</span>option<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  TABLE_LIST <span class="token operator">*</span><span class="token function">nest_last_join</span><span class="token punctuation">(</span>THD <span class="token operator">*</span>thd<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">add_joined_table</span><span class="token punctuation">(</span>TABLE_LIST <span class="token operator">*</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>
  TABLE_LIST <span class="token operator">*</span><span class="token function">convert_right_join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="12-1-2、基本对象"><a href="#12-1-2、基本对象" class="headerlink" title="12.1.2、基本对象"></a>12.1.2、基本对象</h3><p>MySQL和查询优化相关的基本对象主要有：关系（table.h里的TABLE_LIST），索引（sql_class.h里的Key），连接表（sql_select.h里的JOIN_TAB）</p>
<h4 id="12-1-2-1、关系"><a href="#12-1-2-1、关系" class="headerlink" title="12.1.2.1、关系"></a>12.1.2.1、关系</h4><p>MySQL在TABLE_LIST存放了查询优化阶段用到的信息以及其他阶段用到的信息，是一个逻辑上的表结构。在存储层，由TABLE结构体(table.h里)表示表对象</p>
<p>结构体TABLE_LIST定义如下：</p>
<pre class="line-numbers language-CPP"><code class="language-CPP">struct TABLE_LIST {
      //表所属数据库，表名，别名
  const char *db, *table_name, *alias;
    //模式名
  char *schema_table_name;
      //与连接相关的一些信息
  Item        *m_join_cond;
  Item          *m_sj_cond;   
        //半连接的表对象
  table_map     sj_inner_tables;
      //查询树
  st_select_lex    *select_lex;
    
    //视图相关信息
  List<TABLE_LIST> *view_tables;
  /* most upper view this table belongs to */
  TABLE_LIST    *belong_to_view;
  /*
    The view directly referencing this table
    (non-zero only for merged underlying tables of a view).
  */
  TABLE_LIST    *referencing_view;
    
    //安全权限相关的信息
  Security_context *security_ctx;
  /*
    This view security context (non-zero only for views with
    SQL SECURITY DEFINER)
  */
  Security_context *view_sctx;
    GRANT_INFO    grant;
    
    //管理相关的一些信息
  //表对象上的锁信息
  thr_lock_type lock_type;
      //是否被缓存
  bool        cacheable_table;    /* stop PS caching */
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="12-1-2-2、索引"><a href="#12-1-2-2、索引" class="headerlink" title="12.1.2.2、索引"></a>12.1.2.2、索引</h4><p>MySQL通过Key类定义索引的类型和索引的关键信息，其中KEY_CREATE_INFO包括了索引列、索引算法等，如下图</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210517175055037.png" alt="image-20210517175055037"></p>
<p>首先在sql.lex.h里定义了6种索引类型</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> keytype <span class="token punctuation">{</span>
  KEYTYPE_PRIMARY<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//主键索引</span>
  KEYTYPE_UNIQUE<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//唯一索引</span>
  KEYTYPE_MULTIPLE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//多重索引</span>
  KEYTYPE_FULLTEXT<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//全文索引</span>
  KEYTYPE_SPATIAL<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//空间索引</span>
  KEYTYPE_FOREIGN <span class="token comment" spellcheck="true">//外键索引</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在sql_class.h里定义了索引类Key：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Key</span> <span class="token operator">:</span><span class="token keyword">public</span> Sql_alloc <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//索引类型</span>
  keytype type<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//索引元信息，如索引算法、名称、注释等</span>
  KEY_CREATE_INFO key_create_info<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//索引列信息，如列的名称，长度等</span>
  List<span class="token operator">&lt;</span>Key_part_spec<span class="token operator">></span> columns<span class="token punctuation">;</span>
  LEX_STRING name<span class="token punctuation">;</span>
  <span class="token keyword">bool</span> generated<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>索引元信息中的<code>enum ha_key_alg algorithm</code>支持的索引算法如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">enum</span> ha_key_alg <span class="token punctuation">{</span>
  HA_KEY_ALG_UNDEF<span class="token operator">=</span>    <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/* Not specified (old file) */</span>
  HA_KEY_ALG_BTREE<span class="token operator">=</span>    <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/* B-tree算法，默认使用       */</span>
  HA_KEY_ALG_RTREE<span class="token operator">=</span>    <span class="token number">2</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/* R-tree算法，用于空间搜索 */</span>
  HA_KEY_ALG_HASH<span class="token operator">=</span>    <span class="token number">3</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/* HASH算法，用于堆表搜索 */</span>
  HA_KEY_ALG_FULLTEXT<span class="token operator">=</span>    <span class="token number">4</span>        <span class="token comment" spellcheck="true">/* 全文索引，用于MyISAM存储引擎的表 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="12-1-2-3、连接表"><a href="#12-1-2-3、连接表" class="headerlink" title="12.1.2.3、连接表"></a>12.1.2.3、连接表</h4><p>连接表是介于关系（TABLE_LIST类）与连接类（JOIN类）之间的一个过渡对象，存放了关系的一些相关信息，也存放了连接操作需要的一些信息，因此称为连接表。其定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">JOIN_TAB</span> <span class="token operator">:</span> <span class="token keyword">public</span> Sql_alloc<span class="token punctuation">,</span> <span class="token keyword">public</span> QEP_shared_owner <span class="token punctuation">{</span>
  TABLE_LIST    <span class="token operator">*</span>table_ref<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/**&lt; points to table reference               */</span>
<span class="token comment" spellcheck="true">//第一个可用的索引</span>
  Key_use       <span class="token operator">*</span>m_keyuse<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//join/on条件表达式中的等式</span>
  COND_EQUAL    <span class="token operator">*</span>cond_equal<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//被扫描的记录行数（不是返回结果的行数）</span>
  ha_rows       found_records<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用JT_ALL，JT_RANGE，JT_INDEX_MERGE访问表的花费</span>
  ha_rows       read_time<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//连接时依赖的表</span>
  table_map     dependent<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//快速查找的类型</span>
  <span class="token keyword">enum</span> quick_type use_quick<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//两表连接时使用的缓存算法等</span>
  uint          m_use_join_cache<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//半连接相关的一些变量</span>
  TABLE_LIST    <span class="token operator">*</span>emb_sj_nest<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/// @returns semijoin strategy for this table.</span>
  uint <span class="token function">get_sj_strategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="12-1-3、连接对象与执行计划"><a href="#12-1-3、连接对象与执行计划" class="headerlink" title="12.1.3、连接对象与执行计划"></a>12.1.3、连接对象与执行计划</h3><p>MySQL查询优化相关的连接对象主要有连接类（JOIN）、约束条件（Item）和位置（POSITION）等</p>
<h4 id="12-1-3-1、连接类（JOIN）"><a href="#12-1-3-1、连接类（JOIN）" class="headerlink" title="12.1.3.1、连接类（JOIN）"></a>12.1.3.1、连接类（JOIN）</h4><p>sql_optimizer.h里的JOIN类是连接操作对应的查询语句的连接关系内容，是优化和执行的基本单位，也是优化结果（查询执行计划）的存储对象，其定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">JOIN</span> <span class="token operator">:</span><span class="token keyword">public</span> Sql_alloc <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">//语法分析之后得到的查询树</span>
  SELECT_LEX <span class="token operator">*</span><span class="token keyword">const</span> select_lex<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//进行集合操作的查询语句</span>
  SELECT_LEX_UNIT <span class="token operator">*</span><span class="token keyword">const</span> unit<span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">//存放连接中所有的连接关系对象，存放顺序参见get_best_combination函数</span>
  JOIN_TAB <span class="token operator">*</span>join_tab<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//查询执行计划表</span>
  QEP_TAB <span class="token operator">*</span>qep_tab<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//保存当前最优查询计划</span>
  JOIN_TAB <span class="token operator">*</span><span class="token operator">*</span>best_ref<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//位图，标识表在连接中的位置</span>
  JOIN_TAB <span class="token operator">*</span><span class="token operator">*</span>map2table<span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">//查询块中出现的基表数量</span>
  uint     tables<span class="token punctuation">;</span> 
     <span class="token comment" spellcheck="true">//查询块中出现的主要的表的个数（包括物化的临时表等）</span>
  uint     primary_tables<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//常量表的个数</span>
  uint     const_tables<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//临时表的个数</span>
  uint     tmp_tables<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">/**
     构成当前连接的最优表的连接次序（用数组线性存放各个表对象，用来表示这些表按数组指定次序连接得到当前连接）
  */</span>
  POSITION <span class="token operator">*</span>best_positions<span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">//当前路径，在求解最优路径（best_positions）的过程中，表示某一刻的一个路径</span>
  POSITION <span class="token operator">*</span>positions<span class="token punctuation">;</span>  
    <span class="token comment" spellcheck="true">//最优查询路径对应的最小花费</span>
  <span class="token keyword">double</span>   best_read<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//最优查询路径估计会返回的行数</span>
  ha_rows  best_rowcount<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//锁信息</span>
  MYSQL_LOCK <span class="token operator">*</span>lock<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//索引</span>
  Key_use_array keyuse_array<span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">//查询语句中的所有表达式</span>
  List<span class="token operator">&lt;</span>Item<span class="token operator">></span> <span class="token operator">&amp;</span>all_fields<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//order by和group by子句</span>
  ORDER_with_src order<span class="token punctuation">,</span> group_list<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//where子句</span>
  Item       <span class="token operator">*</span>where_cond<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//having子句</span>
  Item       <span class="token operator">*</span>having_cond<span class="token punctuation">;</span>
  Item       <span class="token operator">*</span>having_for_explain<span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">//条件子句</span>
  COND_EQUAL <span class="token operator">*</span>cond_equal<span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">//半连接相关</span>
  List<span class="token operator">&lt;</span>TABLE<span class="token operator">></span> sj_tmp_tables<span class="token punctuation">;</span>
  List<span class="token operator">&lt;</span>Semijoin_mat_exec<span class="token operator">></span> sjm_exec_list<span class="token punctuation">;</span>
    
     
  <span class="token comment" spellcheck="true">//查询优化器的几个主要方法</span>
  <span class="token comment" spellcheck="true">//正式优化阶段，使用逻辑，物理优化方法，进行查询的各种操作代价估算</span>
  <span class="token keyword">int</span> <span class="token function">optimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//重置该连接对象状态</span>
  <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//得到执行计划，按查询执行计划查询</span>
  <span class="token keyword">void</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//prepare连接结果</span>
  <span class="token keyword">bool</span> <span class="token function">prepare_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="12-1-3-2、约束条件"><a href="#12-1-3-2、约束条件" class="headerlink" title="12.1.3.2、约束条件"></a>12.1.3.2、约束条件</h4><p>约束条件是指where或join/on或having子句中的谓词表达式，其分为两种：一种是限制条件，用来过滤单表的元组；另一种是连接条件，满足连接条件的元组才会连接，连接条件表达式一般包括两个或两个以上关系的变量。</p>
<p>MySQL用Item类表示约束条件表达式，这是一个父类，由一系列子类继承该父类，Item_equal类与Item类之间关系如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">Item_equal
    Item_bool_func
        Item_int_func
            Item_func
                Item_result_field
                    Item
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>约束条件类Item的定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token operator">:</span> <span class="token keyword">public</span> Parse_tree_node <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//Item是一个多用途对象，可以存放连接类中的where，having条件等</span>
  <span class="token keyword">enum</span> Type <span class="token punctuation">{</span>INVALID_ITEM<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
             FIELD_ITEM<span class="token punctuation">,</span> FUNC_ITEM<span class="token punctuation">,</span> SUM_FUNC_ITEM<span class="token punctuation">,</span> STRING_ITEM<span class="token punctuation">,</span>
         INT_ITEM<span class="token punctuation">,</span> REAL_ITEM<span class="token punctuation">,</span> NULL_ITEM<span class="token punctuation">,</span> VARBIN_ITEM<span class="token punctuation">,</span>
         COPY_STR_ITEM<span class="token punctuation">,</span> FIELD_AVG_ITEM<span class="token punctuation">,</span> DEFAULT_VALUE_ITEM<span class="token punctuation">,</span>
         PROC_ITEM<span class="token punctuation">,</span>COND_ITEM<span class="token punctuation">,</span> REF_ITEM<span class="token punctuation">,</span> FIELD_STD_ITEM<span class="token punctuation">,</span>
         FIELD_VARIANCE_ITEM<span class="token punctuation">,</span> INSERT_VALUE_ITEM<span class="token punctuation">,</span>
             SUBSELECT_ITEM<span class="token punctuation">,</span> ROW_ITEM<span class="token punctuation">,</span> CACHE_ITEM<span class="token punctuation">,</span> TYPE_HOLDER<span class="token punctuation">,</span>
             PARAM_ITEM<span class="token punctuation">,</span> TRIGGER_FIELD_ITEM<span class="token punctuation">,</span> DECIMAL_ITEM<span class="token punctuation">,</span>
             XPATH_NODESET<span class="token punctuation">,</span> XPATH_NODESET_CMP<span class="token punctuation">,</span>
             VIEW_FIXER_ITEM<span class="token punctuation">}</span><span class="token punctuation">;</span>
    
  <span class="token comment" spellcheck="true">/*
  将一个Item类转化为一个Filed类返回,例如：
    Item_int ->Field_longlong
    Item_real->Field_double
    Item_string->Field_string
  */</span>
      Field <span class="token operator">*</span><span class="token function">tmp_table_field_from_field_type</span><span class="token punctuation">(</span>TABLE <span class="token operator">*</span>table<span class="token punctuation">,</span> <span class="token keyword">bool</span> fixed_length<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Item语法树</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210517205411374.png" alt="image-20210517205411374"></p>
<p>等值条件类COND_EQUAL：</p>
<pre class="line-numbers language-CPP"><code class="language-CPP">class COND_EQUAL: public Sql_alloc
{
public:
    //本层以及本层以下的成员个数（条件有嵌套）
  uint max_members;       
 //上层的所有等值判断的约束条件
  COND_EQUAL *upper_levels;      
//当前等式表达式
  List<Item_equal> current_level;
  COND_EQUAL()
  { 
    upper_levels= 0;
  }
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>表示等式的类Item_equal，格式如field1=field2、field=const</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Item_equal</span><span class="token operator">:</span> <span class="token keyword">public</span> Item_bool_func <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//表达式的因子，如field1=field2中的field1和field2</span>
  List<span class="token operator">&lt;</span>Item_field<span class="token operator">></span> fields<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//常量因子</span>
  Item <span class="token operator">*</span>const_item<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="12-1-3-3、位置"><a href="#12-1-3-3、位置" class="headerlink" title="12.1.3.3、位置"></a>12.1.3.3、位置</h4><p>在连接顺序中，位置是指被连接的表的位置。这个位置上存储了被访问的表、被使用的访问方法、半连接策略的选择、半连接优化状态等。MySQL多表连接算法支持的是从左到右的类似左深树的连接方式，但左深树是一个树形结构，而MySQL的多表连接算法连接表的过程是一个平面结构，先对表进行排序，然后从左到右地连接排好序的表，然后确定当前连接方式的花费。</p>
<p>位置st_position结构体的定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> st_position <span class="token operator">:</span> <span class="token keyword">public</span> Sql_alloc <span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">//rows_fetched = selectivity(access_condition) * cardinality(table)</span>
  <span class="token keyword">double</span> rows_fetched<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//访问表的花费</span>
  <span class="token keyword">double</span> read_cost<span class="token punctuation">;</span> 
  <span class="token comment" spellcheck="true">//访问的连接对象</span>
  JOIN_TAB <span class="token operator">*</span>table<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">/**
  索引信息
    NULL  -  'index' or 'range' or 'index_merge' or 'ALL' access is used.
    Other - [eq_]ref[_or_null] access is used. Pointer to {t.keypart1 = expr}
  */</span>
  Key_use <span class="token operator">*</span>key<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//半连接优化策略</span>
  uint sj_strategy<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//首次匹配策略</span>
  <span class="token comment" spellcheck="true">/*
    Index of the first inner table that we intend to handle with this
    strategy
  */</span>
  uint first_firstmatch_table<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/*
    Tables that were not in the join prefix when we've started considering 
    FirstMatch strategy.
  */</span>
  table_map first_firstmatch_rtbl<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/* 
    Tables that need to be in the prefix before we can calculate the cost
    of using FirstMatch strategy.
   */</span>
  table_map firstmatch_need_tables<span class="token punctuation">;</span>
    
     <span class="token comment" spellcheck="true">//重复淘汰策略</span>
     <span class="token comment" spellcheck="true">/* The first table that the strategy will need to handle */</span>
  uint  first_dupsweedout_table<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/*
    Tables that we will need to have in the prefix to do the weedout step
    (all inner and all outer that the involved semi-joins are correlated with)
  */</span>
  table_map dupsweedout_tables<span class="token punctuation">;</span>
    
    <span class="token comment" spellcheck="true">//半连接物化扫描策略</span>
      <span class="token comment" spellcheck="true">/* The last inner table (valid once we're after it) */</span>
  uint      sjm_scan_last_inner<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/*
    Tables that we need to have in the prefix to calculate the correct cost.
    Basically, we need all inner tables and outer tables mentioned in the
    semi-join's ON expression so we can correctly account for fanout.
  */</span>
  table_map sjm_scan_need_tables<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="12-1-4、代价估算类"><a href="#12-1-4、代价估算类" class="headerlink" title="12.1.4、代价估算类"></a>12.1.4、代价估算类</h3><p>主要包括四个层面：</p>
<ul>
<li>IO花费</li>
<li>CPU花费</li>
<li>远程操作花费</li>
<li>内存操作花费</li>
</ul>
<p>代价估算类Cost_estimate定义如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Cost_estimate</span> <span class="token punctuation">{</span>
       <span class="token comment" spellcheck="true">//IO操作花费</span>
  <span class="token keyword">double</span> io_cost<span class="token punctuation">;</span> 
      <span class="token comment" spellcheck="true">//CPU操作花费</span>
  <span class="token keyword">double</span> cpu_cost<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//远程操作花费</span>
  <span class="token keyword">double</span> import_cost<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">//内存操作花费</span>
  <span class="token keyword">double</span> mem_cost<span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">//5.7.19版本暂时没有考虑内存操作花费</span>
      <span class="token keyword">double</span> <span class="token function">total_cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> io_cost <span class="token operator">+</span> cpu_cost <span class="token operator">+</span> import_cost<span class="token punctuation">;</span> <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">/// Add to IO cost</span>
  <span class="token keyword">void</span> <span class="token function">add_io</span><span class="token punctuation">(</span><span class="token keyword">double</span> add_io_cost<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">DBUG_ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_max_cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    io_cost<span class="token operator">+</span><span class="token operator">=</span> add_io_cost<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">/// Add to CPU cost</span>
  <span class="token keyword">void</span> <span class="token function">add_cpu</span><span class="token punctuation">(</span><span class="token keyword">double</span> add_cpu_cost<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">DBUG_ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_max_cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cpu_cost<span class="token operator">+</span><span class="token operator">=</span> add_cpu_cost<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">/// Add to import cost</span>
  <span class="token keyword">void</span> <span class="token function">add_import</span><span class="token punctuation">(</span><span class="token keyword">double</span> add_import_cost<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">DBUG_ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_max_cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    import_cost<span class="token operator">+</span><span class="token operator">=</span> add_import_cost<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">/// Add to memory cost</span>
  <span class="token keyword">void</span> <span class="token function">add_mem</span><span class="token punctuation">(</span><span class="token keyword">double</span> add_mem_cost<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">DBUG_ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">is_max_cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mem_cost<span class="token operator">+</span><span class="token operator">=</span> add_mem_cost<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在DsMrr_impl::get_disk_sweep_mrr_cost方法里，还是添加了内存操作花费，只是目前暂不考虑，将来的版本会考虑</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token comment" spellcheck="true">/*
    Cost of memory is not included in the total_cost() function and
    thus will not be considered when comparing costs. Still, we
    record it in the cost estimate object for future use.
  */</span>
  cost<span class="token operator">-</span><span class="token operator">></span><span class="token function">add_mem</span><span class="token punctuation">(</span><span class="token operator">*</span>buffer_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="12-2、各个阶段主要结构体间的关系"><a href="#12-2、各个阶段主要结构体间的关系" class="headerlink" title="12.2、各个阶段主要结构体间的关系"></a>12.2、各个阶段主要结构体间的关系</h2><ul>
<li>SQL输入</li>
<li>语法分析：SQL被分解后存放到st_select_lex的各个成员上，如where等子句存在Item上、连接表存放在TABLE_LIST上</li>
<li>查询优化：包括逻辑和物理查询优化，此阶段所有信息存在JOIN对象中</li>
<li>查询执行：最后将查询执行计划交给执行器执行</li>
</ul>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210518090720399.png" alt="image-20210518090720399"></p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210518092309118.png" alt="image-20210518092309118"></p>
<h1 id="13、MySQL查询优化器的原理解析"><a href="#13、MySQL查询优化器的原理解析" class="headerlink" title="13、MySQL查询优化器的原理解析"></a>13、MySQL查询优化器的原理解析</h1><h2 id="13-1、查询优化器整体流程"><a href="#13-1、查询优化器整体流程" class="headerlink" title="13.1、查询优化器整体流程"></a>13.1、查询优化器整体流程</h2><pre class="line-numbers language-cpp"><code class="language-cpp">handle_connection
    do_command
        dispatch_command
            mysql_parse
                mysql_execute_command
                    execute_sqlcom_select
                        handle_query
                            SELECT_LEX<span class="token operator">::</span>prepare
                                remove_redundant_subquery_clauses <span class="token comment" spellcheck="true">//去除子查询中冗余子句</span>
                                resolve_subquery<span class="token comment" spellcheck="true">//子查询优化</span>
                                flatten_subqueries<span class="token comment" spellcheck="true">//将子查询转换为半连接</span>
                                apply_local_transforms
                            SELECT_LEX<span class="token operator">::</span>optimize
                                JOIN<span class="token operator">::</span>optimize
                                    SELECT_LEX<span class="token operator">::</span>apply_local_transforms
                                        delete_unused_merged_columns <span class="token comment" spellcheck="true">//删除未使用的列</span>
                                        simplify_joins <span class="token comment" spellcheck="true">//消除外连接和嵌套连接</span>
                                    <span class="token function">optimize_cond</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>where_cond<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//优化where子句</span>
                                    <span class="token function">optimize_cond</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>having_cond<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//优化having子句</span>
                                    opt_sum_query <span class="token comment" spellcheck="true">//优化count(*), min() and max() （适用于没有group by的情况）</span>
                                    print_where <span class="token comment" spellcheck="true">//打印where条件</span>
                                    JOIN<span class="token operator">::</span>make_join_plan <span class="token comment" spellcheck="true">//计算最优连接次序，初始化JOIN对象</span>
                                        init_planner_arrays <span class="token comment" spellcheck="true">//为连接次序优化初始化临时数组</span>
                                        propagate_dependencies<span class="token comment" spellcheck="true">//求解传播表之间的依赖关系</span>
                                        update_ref_and_keys <span class="token comment" spellcheck="true">//获取索引信息，为快速定位数据，条件比较做准备</span>
                                        estimate_rowcount
                                            get_quick_record_count<span class="token comment" spellcheck="true">//估算每个表中有多少元组可用</span>
                                        choose_table_order
                                            optimize_straight_join<span class="token comment" spellcheck="true">//用户指定表连接次序</span>
                                            <span class="token operator">|</span>greedy_search <span class="token comment" spellcheck="true">// |贪心算法</span>
                                                best_extension_by_limited_search<span class="token comment" spellcheck="true">//确定多表连接的最优查询计划</span>
                                                    best_access_path<span class="token comment" spellcheck="true">//估算访问表的最优访问路径（包括花费）</span>
                                        get_best_combination <span class="token comment" spellcheck="true">//根据最优连接次序，生成执行计划</span>
                                            make_outerjoin_info<span class="token comment" spellcheck="true">//计算外连接信息</span>
                                    mysql_unlock_some_tables <span class="token comment" spellcheck="true">//释放常量表上的锁</span>
                                    substitute_for_best_equal_field<span class="token comment" spellcheck="true">//循环遍历所有表达式，化简表达式（如去除重复等式）</span>
                                    make_join_select <span class="token comment" spellcheck="true">//对条件求值，下推连接条件到表中</span>
                                    JOIN<span class="token operator">::</span>optimize_distinct_group_order
                                        test_if_skip_sort_order <span class="token comment" spellcheck="true">//排序操作的优化（尝试使用索引代替排序）</span>
                                    optimize_fts_query <span class="token comment" spellcheck="true">//优化全文搜索</span>
                                    TEST_join <span class="token comment" spellcheck="true">// 打印连接信息</span>
                                    make_join_readinfo <span class="token comment" spellcheck="true">//细化查询计划</span>
                                        init_join_cache <span class="token comment" spellcheck="true">//初始化连接缓存</span>
                                        push_index_cond <span class="token comment" spellcheck="true">//下推索引条件（ICP）        </span>
                                        pick_table_access_method <span class="token comment" spellcheck="true">//选择合适的数据读取方式</span>
                            JOIN<span class="token operator">::</span>exec
                                JOIN<span class="token operator">::</span>prepare_result <span class="token comment" spellcheck="true">//准备连接结果</span>
                                send_result_set_metadata
                                do_select
                            st_select_lex_unit<span class="token operator">::</span>cleanup
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="13-2、优化器的代码详解"><a href="#13-2、优化器的代码详解" class="headerlink" title="13.2、优化器的代码详解"></a>13.2、优化器的代码详解</h2><h3 id="13-2-1、SELECT-LEX-prepare：优化前的准备工作"><a href="#13-2-1、SELECT-LEX-prepare：优化前的准备工作" class="headerlink" title="13.2.1、SELECT_LEX::prepare：优化前的准备工作"></a>13.2.1、SELECT_LEX::prepare：优化前的准备工作</h3><h4 id="13-2-1-1、整体工作"><a href="#13-2-1-1、整体工作" class="headerlink" title="13.2.1.1、整体工作"></a>13.2.1.1、整体工作</h4><pre class="line-numbers language-cpp"><code class="language-cpp">setup_tables <span class="token comment" spellcheck="true">//初始化基表</span>
check_view_privileges <span class="token comment" spellcheck="true">//权限检查</span>
setup_wild <span class="token comment" spellcheck="true">//将查询语句中的*扩展为表上所有列</span>
setup_fields <span class="token comment" spellcheck="true">//为列填充数据信息</span>
setup_conds <span class="token comment" spellcheck="true">//解析where子句和连接条件</span>
setup_group <span class="token comment" spellcheck="true">//初始化group by子句</span>
setup_order <span class="token comment" spellcheck="true">//初始化order by子句</span>
remove_redundant_subquery_clauses <span class="token comment" spellcheck="true">//去除子查询中的冗余子句</span>
resolve_subquery <span class="token comment" spellcheck="true">//优化IN/ALL/ANY/EXISTS式子查询</span>
split_sum_func2 <span class="token comment" spellcheck="true">//统计order by，having等子句中的sum操作  </span>
flatten_subqueries<span class="token comment" spellcheck="true">//将子查询转换为半连接</span>
apply_local_transforms
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="13-2-1-2、remove-redundant-subquery-clauses"><a href="#13-2-1-2、remove-redundant-subquery-clauses" class="headerlink" title="13.2.1.2、remove_redundant_subquery_clauses"></a>13.2.1.2、remove_redundant_subquery_clauses</h4><p>MySQL定义的子查询类型如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token keyword">enum</span> subs_type <span class="token punctuation">{</span>UNKNOWN_SUBS<span class="token punctuation">,</span> SINGLEROW_SUBS<span class="token punctuation">,</span>
          EXISTS_SUBS<span class="token punctuation">,</span> IN_SUBS<span class="token punctuation">,</span> ALL_SUBS<span class="token punctuation">,</span> ANY_SUBS<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>remove_redundant_subquery_clauses</code>的主要代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//用于去除冗余的orderby，distinct和group by子句</span>
<span class="token keyword">void</span> SELECT_LEX<span class="token operator">::</span><span class="token function">remove_redundant_subquery_clauses</span> <span class="token punctuation">(</span>THD <span class="token operator">*</span>thd<span class="token punctuation">,</span>
                                                   <span class="token keyword">int</span> hidden_group_field_count<span class="token punctuation">,</span>
                                                   <span class="token keyword">int</span> hidden_order_field_count<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>subq_predicate<span class="token operator">-</span><span class="token operator">></span><span class="token function">substype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Item_subselect<span class="token operator">::</span>SINGLEROW_SUBS<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不处理简单的行子查询</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//去除order by子句</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>order_list<span class="token punctuation">.</span>elements<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">empty_order_list</span><span class="token punctuation">(</span>hidden_order_field_count<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//去除distinct子句</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">remove_base_options</span><span class="token punctuation">(</span>SELECT_DISTINCT<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
     <span class="token comment" spellcheck="true">//去除group by子句（如果没有聚合函数和having子句）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>group_list<span class="token punctuation">.</span>elements <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">agg_func_used</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">having_cond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>ORDER <span class="token operator">*</span>g<span class="token operator">=</span> group_list<span class="token punctuation">.</span>first<span class="token punctuation">;</span> g <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> g<span class="token operator">=</span> g<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>g<span class="token operator">-</span><span class="token operator">></span>item <span class="token operator">==</span> g<span class="token operator">-</span><span class="token operator">></span>item_ptr<span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token operator">*</span>g<span class="token operator">-</span><span class="token operator">></span>item<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">walk</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Item<span class="token operator">::</span>clean_up_after_removal<span class="token punctuation">,</span> walk_subquery<span class="token punctuation">,</span>
                             <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>uchar<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        group_list<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>hidden_group_field_count<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          all_fields<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          ref_ptrs<span class="token punctuation">[</span>all_fields<span class="token punctuation">.</span>elements<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="13-2-1-3、resolve-subquery"><a href="#13-2-1-3、resolve-subquery" class="headerlink" title="13.2.1.3、resolve_subquery"></a>13.2.1.3、resolve_subquery</h4><p>主要用于对子查询进行各种优化，可优化方式如下：</p>
<ul>
<li>转换子查询为半连接</li>
<li>使用物化标识子查询</li>
<li>执行IN向EXISTS的转换</li>
<li>执行<op>ALL/ANY/SOME向MIN/MAX的转换，其中op为大于或小于操作</li>
<li>使用值替代标量子查询</li>
</ul>
<p>主要代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> SELECT_LEX<span class="token operator">::</span><span class="token function">resolve_subquery</span><span class="token punctuation">(</span>THD <span class="token operator">*</span>thd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>in_predicate<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//IN操作</span>
  <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/*
    如果左操作数和右操作数的列数量不同，报错退出函数
      Check if the left and right expressions have the same # of
      columns, i.e. we don't have a case like 
        (oe1, oe2) IN (SELECT ie1, ie2, ie3 ...)
    */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>item_list<span class="token punctuation">.</span>elements <span class="token operator">!=</span> in_predicate<span class="token operator">-</span><span class="token operator">></span>left_expr<span class="token operator">-</span><span class="token operator">></span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">my_error</span><span class="token punctuation">(</span>ER_OPERAND_COLUMNS<span class="token punctuation">,</span> <span class="token function">MYF</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> in_predicate<span class="token operator">-</span><span class="token operator">></span>left_expr<span class="token operator">-</span><span class="token operator">></span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
      <span class="token comment" spellcheck="true">/*
      如果满足以下10点，子查询就可以被扁平化为半连接操作（在flatten_subqueries函数里实现）
    Check if we're in subquery that is a candidate for flattening into a
    semi-join (which is done in flatten_subqueries()). The requirements are:
      1. Subquery predicate is an IN/=ANY subquery predicate
      2. Subquery is a single SELECT (not a UNION)
      3. Subquery does not have GROUP BY
      4. Subquery does not use aggregate functions or HAVING
      5. Subquery predicate is (a) in an ON/WHERE clause, and (b) at
      the AND-top-level of that clause.
      6. Parent query block accepts semijoins (i.e we are not in a subquery of
      a single table UPDATE/DELETE (TODO: We should handle this at some
      point by switching to multi-table UPDATE/DELETE)
      7. We're not in a confluent table-less subquery, like "SELECT 1".
      8. No execution method was already chosen (by a prepared statement)
      9. Parent select is not a confluent table-less select
      10. Neither parent nor child select have STRAIGHT_JOIN option.
  */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">semijoin_enabled</span><span class="token punctuation">(</span>thd<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      in_predicate <span class="token operator">&amp;&amp;</span>                                                   <span class="token comment" spellcheck="true">// 1</span>
      <span class="token operator">!</span><span class="token function">is_part_of_union</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                                            <span class="token comment" spellcheck="true">// 2</span>
      <span class="token operator">!</span>group_list<span class="token punctuation">.</span>elements <span class="token operator">&amp;&amp;</span>                                           <span class="token comment" spellcheck="true">// 3</span>
      <span class="token operator">!</span>m_having_cond <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>with_sum_func <span class="token operator">&amp;&amp;</span>                               <span class="token comment" spellcheck="true">// 4</span>
      <span class="token punctuation">(</span>outer<span class="token operator">-</span><span class="token operator">></span>resolve_place <span class="token operator">==</span> st_select_lex<span class="token operator">::</span>RESOLVE_CONDITION <span class="token operator">||</span>      <span class="token comment" spellcheck="true">// 5a</span>
       outer<span class="token operator">-</span><span class="token operator">></span>resolve_place <span class="token operator">==</span> st_select_lex<span class="token operator">::</span>RESOLVE_JOIN_NEST<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>     <span class="token comment" spellcheck="true">// 5a</span>
      <span class="token operator">!</span>outer<span class="token operator">-</span><span class="token operator">></span>semijoin_disallowed <span class="token operator">&amp;&amp;</span>                                    <span class="token comment" spellcheck="true">// 5b</span>
      outer<span class="token operator">-</span><span class="token operator">></span>sj_candidates <span class="token operator">&amp;&amp;</span>                                           <span class="token comment" spellcheck="true">// 6</span>
      leaf_table_count <span class="token operator">&amp;&amp;</span>                                               <span class="token comment" spellcheck="true">// 7</span>
      in_predicate<span class="token operator">-</span><span class="token operator">></span>exec_method <span class="token operator">==</span>
                           Item_exists_subselect<span class="token operator">::</span>EXEC_UNSPECIFIED <span class="token operator">&amp;&amp;</span>   <span class="token comment" spellcheck="true">// 8</span>
      outer<span class="token operator">-</span><span class="token operator">></span>leaf_table_count <span class="token operator">&amp;&amp;</span>                                        <span class="token comment" spellcheck="true">// 9</span>
      <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">active_options</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span> outer<span class="token operator">-</span><span class="token operator">></span><span class="token function">active_options</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>
       SELECT_STRAIGHT_JOIN<span class="token punctuation">)</span><span class="token punctuation">)</span>                                           <span class="token comment" spellcheck="true">//10</span>
  <span class="token punctuation">{</span>
    <span class="token function">DBUG_PRINT</span><span class="token punctuation">(</span><span class="token string">"info"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Subquery is semi-join conversion candidate"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* Notify in the subquery predicate where it belongs in the query graph */</span>
    in_predicate<span class="token operator">-</span><span class="token operator">></span>embedding_join_nest<span class="token operator">=</span> outer<span class="token operator">-</span><span class="token operator">></span>resolve_nest<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/* Register the subquery for further processing in flatten_subqueries() */</span>
    outer<span class="token operator">-</span><span class="token operator">></span>sj_candidates<span class="token operator">-</span><span class="token operator">></span><span class="token function">push_back</span><span class="token punctuation">(</span>in_predicate<span class="token punctuation">)</span><span class="token punctuation">;</span>
    chose_semijoin<span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
    <span class="token comment" spellcheck="true">//如果不可以使用半连接优化，调用select_transformer->select_in_like_transformer函数进行子查询优化(IN/ALL/ANY/SOME)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>chose_semijoin <span class="token operator">&amp;&amp;</span> subq_predicate<span class="token operator">-</span><span class="token operator">></span><span class="token function">select_transformer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">==</span> Item_subselect<span class="token operator">::</span>RES_ERROR<span class="token punctuation">)</span>
        <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="13-2-1-4、flatten-subqueries：转换子查询为半连接"><a href="#13-2-1-4、flatten-subqueries：转换子查询为半连接" class="headerlink" title="13.2.1.4、flatten_subqueries：转换子查询为半连接"></a>13.2.1.4、flatten_subqueries：转换子查询为半连接</h4><p>即把子查询的表对象上拉到from子句，让from子句原先的表对象和子查询中被上拉的表对象进行半连接操作，从而达到扁平化子查询的效果</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210519110113223.png" alt="image-20210519110113223"></p>
<p>上面格式的语句可以优化为下面格式语句</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210519110138660.png" alt="image-20210519110138660"></p>
<p>转换后，经过条件替换函数replace_subcondition的处理，条件部分发生了较大变化（如subq_where合并到父查询的where子句中，生成新条件oe=ie）。</p>
<p>flatten_subqueries实现代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> SELECT_LEX<span class="token operator">::</span><span class="token function">flatten_subqueries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//1、自底向上，转换各子句中存在的子查询</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>subq<span class="token operator">=</span> subq_begin<span class="token punctuation">;</span> subq <span class="token operator">&lt;</span> subq_end<span class="token punctuation">;</span> subq<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
           <span class="token comment" spellcheck="true">//目前版本（5.7.19）仅支持IN格式的子查询</span>
        <span class="token function">DBUG_ASSERT</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">substype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Item_subselect<span class="token operator">::</span>IN_SUBS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//获得子句中的查询语句</span>
        st_select_lex <span class="token operator">*</span>child_select<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>unit<span class="token operator">-</span><span class="token operator">></span><span class="token function">first_select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Check that we proceeded bottom-up</span>
        <span class="token function">DBUG_ASSERT</span><span class="token punctuation">(</span>child_select<span class="token operator">-</span><span class="token operator">></span>sj_candidates <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>sj_convert_priority<span class="token operator">=</span> 
          <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>unit<span class="token operator">-</span><span class="token operator">></span>uncacheable <span class="token operator">&amp;</span> UNCACHEABLE_DEPENDENT<span class="token punctuation">)</span> <span class="token operator">?</span> MAX_TABLES <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span>
          child_select<span class="token operator">-</span><span class="token operator">></span>leaf_table_count<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    
    <span class="token comment" spellcheck="true">/*
    2、对子查询进行转换，转换前先排序，排序规则是：
    1)相关子查询比不相关子查询靠前
    2）有更多外表的子查询靠前
    */</span>
    <span class="token comment" spellcheck="true">//2.1、排序</span>
    <span class="token function">my_qsort</span><span class="token punctuation">(</span>subq_begin<span class="token punctuation">,</span>
           sj_candidates<span class="token operator">-</span><span class="token operator">></span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sj_candidates<span class="token operator">-</span><span class="token operator">></span><span class="token function">element_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
           <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>qsort_cmp<span class="token operator">></span><span class="token punctuation">(</span>subq_sj_candidate_cmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    uint table_count<span class="token operator">=</span> leaf_table_count<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//2.2、对排好序的所有子查询进行转换前的准备工作：条件替换</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>subq<span class="token operator">=</span> subq_begin<span class="token punctuation">;</span> subq <span class="token operator">&lt;</span> subq_end<span class="token punctuation">;</span> subq<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Add the tables in the subquery nest plus one in case of materialization:</span>
        <span class="token keyword">const</span> uint tables_added<span class="token operator">=</span>
          <span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>unit<span class="token operator">-</span><span class="token operator">></span><span class="token function">first_select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>leaf_table_count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>sj_chosen<span class="token operator">=</span> table_count <span class="token operator">+</span> tables_added <span class="token operator">&lt;=</span> MAX_TABLES<span class="token punctuation">;</span>
        table_count<span class="token operator">+</span><span class="token operator">=</span> tables_added<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// In WHERE/ON of parent query, replace IN(subq) with "1" (&lt;=>TRUE)</span>
        Item <span class="token operator">*</span><span class="token operator">*</span>tree<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>embedding_join_nest <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">?</span>
                     <span class="token operator">&amp;</span>m_where_cond <span class="token operator">:</span>
                    <span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>embedding_join_nest<span class="token operator">-</span><span class="token operator">></span><span class="token function">join_cond_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">replace_subcondition</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> <span class="token operator">*</span>subq<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token function">Item_int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> FALSE<span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* purecov: inspected */</span>
      <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//2.3、对所有排好序的子查询进行转换</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>subq<span class="token operator">=</span> subq_begin<span class="token punctuation">;</span> subq <span class="token operator">&lt;</span> subq_end<span class="token punctuation">;</span> subq<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>sj_chosen<span class="token punctuation">)</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token function">OPT_TRACE_TRANSFORM</span><span class="token punctuation">(</span>trace<span class="token punctuation">,</span> oto0<span class="token punctuation">,</span> oto1<span class="token punctuation">,</span>
                            <span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>unit<span class="token operator">-</span><span class="token operator">></span><span class="token function">first_select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>select_number<span class="token punctuation">,</span>
                            <span class="token string">"IN (SELECT)"</span><span class="token punctuation">,</span> <span class="token string">"semijoin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        oto1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"chosen"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">convert_subquery_to_semijoin</span><span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    
    <span class="token comment" spellcheck="true">//3、对于第2步不能通过convert_subquery_to_semijoin函数处理的子查询，将IN转换为EXISTS格式</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>subq<span class="token operator">=</span> subq_begin<span class="token punctuation">;</span> subq <span class="token operator">&lt;</span> subq_end<span class="token punctuation">;</span> subq<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
    SELECT_LEX <span class="token operator">*</span>save_select_lex<span class="token operator">=</span> thd<span class="token operator">-</span><span class="token operator">></span>lex<span class="token operator">-</span><span class="token operator">></span><span class="token function">current_select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thd<span class="token operator">-</span><span class="token operator">></span>lex<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_current_select</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>unit<span class="token operator">-</span><span class="token operator">></span><span class="token function">first_select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//实现每个子查询中的优化</span>
    res<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">select_transformer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>unit<span class="token operator">-</span><span class="token operator">></span><span class="token function">first_select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thd<span class="token operator">-</span><span class="token operator">></span>lex<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_current_select</span><span class="token punctuation">(</span>save_select_lex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Item <span class="token operator">*</span><span class="token operator">*</span>tree<span class="token operator">=</span> subquery_in_join_clause <span class="token operator">?</span>
      <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>subq<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>embedding_join_nest<span class="token operator">-</span><span class="token operator">></span><span class="token function">join_cond_ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">&amp;</span>m_where_cond<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//将IN转换为EXISTS格式</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">replace_subcondition</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> <span class="token operator">*</span>subq<span class="token punctuation">,</span> substitute<span class="token punctuation">,</span> do_fix_fields<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="13-2-1-5、select-transformer：子查询优化"><a href="#13-2-1-5、select-transformer：子查询优化" class="headerlink" title="13.2.1.5、select_transformer：子查询优化"></a>13.2.1.5、select_transformer：子查询优化</h4><p>select_transformer是父类Item_subselect的一个方法，被4个子类Item_singlerow_subselect、Item_in_subselect、Item_allany_subselect、Item_exists_subselect继承，根据具体类型实现各自的优化。其内部是调用select_in_like_transformer函数来完成子查询的优化的</p>
<p>select_in_like_transformer的代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp">Item_subselect<span class="token operator">::</span>trans_res
Item_in_subselect<span class="token operator">::</span><span class="token function">select_in_like_transformer</span><span class="token punctuation">(</span>SELECT_LEX <span class="token operator">*</span>select<span class="token punctuation">,</span>
                                              Comp_creator <span class="token operator">*</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//如果子查询对应优化器不存在，创建一个优化器</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>optimizer<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    Prepared_stmt_arena_holder <span class="token function">ps_arena_holder</span><span class="token punctuation">(</span>thd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    optimizer<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Item_in_optimizer</span><span class="token punctuation">(</span>left_expr<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
    thd<span class="token operator">-</span><span class="token operator">></span>lex<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_current_select</span><span class="token punctuation">(</span>select<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">//如果IN谓词的左操作数只有一列，则认为是标量IN子查询</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left_expr<span class="token operator">-</span><span class="token operator">></span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
      res<span class="token operator">=</span> <span class="token function">single_value_transformer</span><span class="token punctuation">(</span>select<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">/* we do not support row operation for ALL/ANY/SOME */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>func <span class="token operator">!=</span> <span class="token operator">&amp;</span>eq_creator<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        <span class="token function">my_error</span><span class="token punctuation">(</span>ER_OPERAND_COLUMNS<span class="token punctuation">,</span> <span class="token function">MYF</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span>RES_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
       <span class="token comment" spellcheck="true">//否则则认为是行式IN子查询</span>
      res<span class="token operator">=</span> <span class="token function">row_value_transformer</span><span class="token punctuation">(</span>select<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>                                            
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="13-2-2、JOIN-optimize：优化器的主入口方法"><a href="#13-2-2、JOIN-optimize：优化器的主入口方法" class="headerlink" title="13.2.2、JOIN::optimize：优化器的主入口方法"></a>13.2.2、JOIN::optimize：优化器的主入口方法</h3><p>包括逻辑查询优化和物理查询优化，得到最终查询执行计划。实现代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> JOIN<span class="token operator">::</span><span class="token function">optimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    apply_local_transforms <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//将外连接转换为内连接（递归调用）</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">simplify_joins</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>top_join_list<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m_where_cond<span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//记录连接的嵌套信息</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">record_join_nest_info</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>top_join_list<span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//给每个嵌套连接分配一个bit位，构建bitmap</span>
        <span class="token function">build_bitmap_for_nested_joins</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>top_join_list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment" spellcheck="true">//对查询语句中的临时关系或视图对象，使用optimize_derived函数创建临时表或物化临时关系，便于后续使用</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>select_lex<span class="token operator">-</span><span class="token operator">></span>materialized_derived_table_count<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>TABLE_LIST <span class="token operator">*</span>tl<span class="token operator">=</span> select_lex<span class="token operator">-</span><span class="token operator">></span>leaf_tables<span class="token punctuation">;</span> tl<span class="token punctuation">;</span> tl<span class="token operator">=</span> tl<span class="token operator">-</span><span class="token operator">></span>next_leaf<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>tl<span class="token operator">-</span><span class="token operator">></span><span class="token function">is_view_or_derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tl<span class="token operator">-</span><span class="token operator">></span><span class="token function">optimize_derived</span><span class="token punctuation">(</span>thd<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//优化where子句</span>
    <span class="token function">optimize_cond</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>where_cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cond_equal<span class="token punctuation">,</span>
                      <span class="token operator">&amp;</span>select_lex<span class="token operator">-</span><span class="token operator">></span>top_join_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>select_lex<span class="token operator">-</span><span class="token operator">></span>cond_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//优化having子句</span>
    <span class="token function">optimize_cond</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>having_cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cond_equal<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
                      <span class="token operator">&amp;</span>select_lex<span class="token operator">-</span><span class="token operator">></span>having_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//对没有group子句且调用了count(*), min() and max()函数的情况进行优化</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>tables_list <span class="token operator">&amp;&amp;</span> implicit_grouping<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">//对每个单表（叶子表）上满足上述条件的情况进行优化</span>
          <span class="token function">opt_sum_query</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> select_lex<span class="token operator">-</span><span class="token operator">></span>leaf_tables<span class="token punctuation">,</span> all_fields<span class="token punctuation">,</span>
                            where_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//计算最优连接次序，初始化JOIN对象</span>
    <span class="token function">make_join_plan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//小优化：对常量表提前解锁</span>
    <span class="token function">mysql_unlock_some_tables</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> ct<span class="token punctuation">,</span> const_tables<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//化简条件和每个表上的冗余等式</span>
    <span class="token function">substitute_for_best_equal_field</span><span class="token punctuation">(</span>where_cond<span class="token punctuation">,</span> cond_equal<span class="token punctuation">,</span> map2table<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//对条件尽量求值，并下推约束条件到表中</span>
    <span class="token function">make_join_select</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> where_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//排序操作的优化</span>
   optimize_distinct_group_order <span class="token operator">-</span><span class="token operator">></span> <span class="token function">test_if_skip_sort_order</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//优化全文搜索</span>
    <span class="token function">optimize_fts_query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//为各种类型的表数据获取做准备工作</span>
    <span class="token function">make_join_readinfo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> no_jbuf_after<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//初始化临时表</span>
    <span class="token function">make_tmp_tables_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="13-2-3、JOIN-make-join-plan：计算最优的查询优化执行计划"><a href="#13-2-3、JOIN-make-join-plan：计算最优的查询优化执行计划" class="headerlink" title="13.2.3、JOIN::make_join_plan：计算最优的查询优化执行计划"></a>13.2.3、JOIN::make_join_plan：计算最优的查询优化执行计划</h3><p>实现代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> JOIN<span class="token operator">::</span><span class="token function">make_join_plan</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//初始化连接次序优化的临时数组</span>
    <span class="token function">init_planner_arrays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">//求解传播表之间的依赖关系</span>
    <span class="token function">propagate_dependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//将表之间的依赖关系写到优化器跟踪信息里</span>
    <span class="token function">trace_table_dependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//获取索引信息</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>where_cond <span class="token operator">||</span> select_lex<span class="token operator">-</span><span class="token operator">></span>outer_join<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">update_ref_and_keys</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>keyuse_array<span class="token punctuation">,</span> join_tab<span class="token punctuation">,</span> tables<span class="token punctuation">,</span> where_cond<span class="token punctuation">,</span>
                            cond_equal<span class="token punctuation">,</span> <span class="token operator">~</span>select_lex<span class="token operator">-</span><span class="token operator">></span>outer_join<span class="token punctuation">,</span> select_lex<span class="token punctuation">,</span>
                            <span class="token operator">&amp;</span>sargables<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//基于表之间的依赖关系，可以把一些用于半连接计算的表拉到上层，避开用半连接计算</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>select_lex<span class="token operator">-</span><span class="token operator">></span>sj_pullout_done <span class="token operator">&amp;&amp;</span> select_lex<span class="token operator">-</span><span class="token operator">></span>sj_nests<span class="token punctuation">.</span>elements <span class="token operator">&amp;&amp;</span>
      <span class="token function">pull_out_semijoin_tables</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//基于行数提取常量表</span>
    <span class="token function">extract_const_tables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//基于函数依赖提取常量表</span>
    <span class="token function">extract_func_dependent_tables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">estimate_rowcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>JOIN_TAB <span class="token operator">*</span>tab<span class="token operator">=</span> join_tab<span class="token punctuation">;</span> tab <span class="token operator">&lt;</span> tab_end<span class="token punctuation">;</span> tab<span class="token operator">++</span><span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
            <span class="token keyword">const</span> Cost_model_table <span class="token operator">*</span><span class="token keyword">const</span> cost_model<span class="token operator">=</span> tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">table</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">cost_model</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//如果是常量表，元组数最多是1</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> JT_SYSTEM <span class="token operator">||</span> tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> JT_CONST<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// Only one matching row and one block to read</span>
          tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_records</span><span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span>found_records<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          tab<span class="token operator">-</span><span class="token operator">></span>worst_seeks<span class="token operator">=</span> cost_model<span class="token operator">-</span><span class="token operator">></span><span class="token function">page_read_cost</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          tab<span class="token operator">-</span><span class="token operator">></span>read_time<span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ha_rows<span class="token operator">></span><span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span>worst_seeks<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//计算非常量表的元组数、获取数据的时间花费和最坏搜索因子</span>
            tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_records</span><span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span>found_records<span class="token operator">=</span> tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">table</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>file<span class="token operator">-</span><span class="token operator">></span>stats<span class="token punctuation">.</span>records<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">const</span> Cost_estimate table_scan_time<span class="token operator">=</span> tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">table</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>file<span class="token operator">-</span><span class="token operator">></span><span class="token function">table_scan_cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tab<span class="token operator">-</span><span class="token operator">></span>read_time<span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>ha_rows<span class="token operator">></span><span class="token punctuation">(</span>table_scan_time<span class="token punctuation">.</span><span class="token function">total_cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tab<span class="token operator">-</span><span class="token operator">></span>worst_seeks<span class="token operator">=</span>
              <span class="token function">min</span><span class="token punctuation">(</span>cost_model<span class="token operator">-</span><span class="token operator">></span><span class="token function">page_read_cost</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> tab<span class="token operator">-</span><span class="token operator">></span>found_records <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                  <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> tab<span class="token operator">-</span><span class="token operator">></span>read_time <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">const</span> <span class="token keyword">double</span> min_worst_seek<span class="token operator">=</span> cost_model<span class="token operator">-</span><span class="token operator">></span><span class="token function">page_read_cost</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span>worst_seeks <span class="token operator">&lt;</span> min_worst_seek<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// Fix for small tables</span>
              tab<span class="token operator">-</span><span class="token operator">></span>worst_seeks<span class="token operator">=</span> min_worst_seek<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果有group和distinct子句，则为这些操作所在的列确定是否有索引可用</span>
            <span class="token function">add_group_and_distinct_keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果可以执行范围扫描，则重新计算元组数、获取数据的时间花费</span>
            TABLE_LIST <span class="token operator">*</span><span class="token keyword">const</span> tl<span class="token operator">=</span> tab<span class="token operator">-</span><span class="token operator">></span>table_ref<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tab<span class="token operator">-</span><span class="token operator">></span>const_keys<span class="token punctuation">.</span><span class="token function">is_clear_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                        <span class="token comment" spellcheck="true">// (1)</span>
                <span class="token punctuation">(</span><span class="token operator">!</span>tl<span class="token operator">-</span><span class="token operator">></span>embedding <span class="token operator">||</span>                                        <span class="token comment" spellcheck="true">// (2)</span>
                 <span class="token punctuation">(</span>tl<span class="token operator">-</span><span class="token operator">></span>embedding <span class="token operator">&amp;&amp;</span> tl<span class="token operator">-</span><span class="token operator">></span>embedding<span class="token operator">-</span><span class="token operator">></span><span class="token function">sj_cond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// (3)</span>
            <span class="token punctuation">{</span>
              ha_rows records<span class="token operator">=</span> <span class="token function">get_quick_record_count</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> tab<span class="token punctuation">,</span> row_limit<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
           <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//否则执行全表扫描</span>
              <span class="token function">Opt_trace_object</span><span class="token punctuation">(</span>trace<span class="token punctuation">,</span> <span class="token string">"table_scan"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
                <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"rows"</span><span class="token punctuation">,</span> tab<span class="token operator">-</span><span class="token operator">></span>found_records<span class="token punctuation">)</span><span class="token punctuation">.</span>
                <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"cost"</span><span class="token punctuation">,</span> tab<span class="token operator">-</span><span class="token operator">></span>read_time<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//为了利用好索引，对索引对象上的keyuse值进行更新</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">plan_is_const</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token function">optimize_keyuse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//使用物化技术优化半连接嵌套</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sj_nests <span class="token operator">&amp;&amp;</span> <span class="token function">optimize_semijoin_nests_for_materialization</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//选择多表连接算法（有两个，一是使用用户指定的连接次序，二是使用贪心算法进行穷举搜索）</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Optimize_table_order</span><span class="token punctuation">(</span>thd<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">choose_table_order</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//决定子查询的优化策略（IN->EXISTS和物化二选一）</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>unit<span class="token operator">-</span><span class="token operator">></span>item <span class="token operator">&amp;&amp;</span> <span class="token function">decide_subquery_strategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment" spellcheck="true">//根据choose_table_order得到的最优路径生成执行计划</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_best_combination</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="13-2-4、choose-table-order：求解多表连接最优连接路径"><a href="#13-2-4、choose-table-order：求解多表连接最优连接路径" class="headerlink" title="13.2.4、choose_table_order：求解多表连接最优连接路径"></a>13.2.4、choose_table_order：求解多表连接最优连接路径</h3><p>choose_table_order函数选择一个算法求解最优路径，实现代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> Optimize_table_order<span class="token operator">::</span><span class="token function">choose_table_order</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">//如果全是常量表，不用做多表连接的优化</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>join<span class="token operator">-</span><span class="token operator">></span>const_tables <span class="token operator">==</span> join<span class="token operator">-</span><span class="token operator">></span>tables<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>join<span class="token operator">-</span><span class="token operator">></span>best_positions<span class="token punctuation">,</span> join<span class="token operator">-</span><span class="token operator">></span>positions<span class="token punctuation">,</span>
       <span class="token keyword">sizeof</span><span class="token punctuation">(</span>POSITION<span class="token punctuation">)</span> <span class="token operator">*</span> join<span class="token operator">-</span><span class="token operator">></span>const_tables<span class="token punctuation">)</span><span class="token punctuation">;</span>
    join<span class="token operator">-</span><span class="token operator">></span>best_read<span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
    join<span class="token operator">-</span><span class="token operator">></span>best_rowcount<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//确定是否采用SQL语句指定的次序（SQL中通过hit指定straight join）来生成多表连接执行计划</span>
    <span class="token keyword">const</span> <span class="token keyword">bool</span> straight_join<span class="token operator">=</span>join<span class="token operator">-</span><span class="token operator">></span>select_lex<span class="token operator">-</span><span class="token operator">></span><span class="token function">active_options</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> SELECT_STRAIGHT_JOIN<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//如果存在半连接，则采用物化方法进行优化</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>emb_sjm_nest<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
    <span class="token function">merge_sort</span><span class="token punctuation">(</span>join<span class="token operator">-</span><span class="token operator">></span>best_ref <span class="token operator">+</span> join<span class="token operator">-</span><span class="token operator">></span>const_tables<span class="token punctuation">,</span>
               join<span class="token operator">-</span><span class="token operator">></span>best_ref <span class="token operator">+</span> join<span class="token operator">-</span><span class="token operator">></span>tables<span class="token punctuation">,</span>
               <span class="token function">Join_tab_compare_embedded_first</span><span class="token punctuation">(</span>emb_sjm_nest<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    join_tables<span class="token operator">=</span> emb_sjm_nest<span class="token operator">-</span><span class="token operator">></span>sj_inner_tables<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token comment" spellcheck="true">//否则，需要对多表连接进行优化求解最优路径</span>
      <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//使用用户指定的表连接次序对表排序</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>straight_join<span class="token punctuation">)</span>
          <span class="token function">merge_sort</span><span class="token punctuation">(</span>join<span class="token operator">-</span><span class="token operator">></span>best_ref <span class="token operator">+</span> join<span class="token operator">-</span><span class="token operator">></span>const_tables<span class="token punctuation">,</span>
                     join<span class="token operator">-</span><span class="token operator">></span>best_ref <span class="token operator">+</span> join<span class="token operator">-</span><span class="token operator">></span>tables<span class="token punctuation">,</span>
                     <span class="token function">Join_tab_compare_straight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token comment" spellcheck="true">//否则使用贪心算法，在这之前需要对表进行排序。排序规则是按照表的元组数从小到大排序（这是一条启发式规则）</span>
          <span class="token function">merge_sort</span><span class="token punctuation">(</span>join<span class="token operator">-</span><span class="token operator">></span>best_ref <span class="token operator">+</span> join<span class="token operator">-</span><span class="token operator">></span>const_tables<span class="token punctuation">,</span>
                     join<span class="token operator">-</span><span class="token operator">></span>best_ref <span class="token operator">+</span> join<span class="token operator">-</span><span class="token operator">></span>tables<span class="token punctuation">,</span>
                     <span class="token function">Join_tab_compare_default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//所有基表去掉常量表就是要连接的表</span>
        join_tables<span class="token operator">=</span> join<span class="token operator">-</span><span class="token operator">></span>all_table_map <span class="token operator">&amp;</span> <span class="token operator">~</span>join<span class="token operator">-</span><span class="token operator">></span>const_table_map<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>straight_join<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果使用用户指定次序连接，查询优化器不再优化</span>
            <span class="token function">optimize_straight_join</span><span class="token punctuation">(</span>join_tables<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">else</span>
      <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//否则使用贪心算法进行搜索</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">greedy_search</span><span class="token punctuation">(</span>join_tables<span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//修改半连接策略并估算花费</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fix_semijoin_strategies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="13-2-5、make-join-select：对条件求值，下推连接条件到表中"><a href="#13-2-5、make-join-select：对条件求值，下推连接条件到表中" class="headerlink" title="13.2.5、make_join_select：对条件求值，下推连接条件到表中"></a>13.2.5、make_join_select：对条件求值，下推连接条件到表中</h3><p>make_join_select函数主要用于分解连接条件（where和on等条件），下推连接条件到表中，实现代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">make_join_select</span><span class="token punctuation">(</span>JOIN <span class="token operator">*</span>join<span class="token punctuation">,</span> Item <span class="token operator">*</span>cond<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//1、优化点：把列上的非NULL语义加入到条件中，有利于条件判断（语义优化技术）</span>
    <span class="token function">add_not_null_conds</span><span class="token punctuation">(</span>join<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//2、抽取表达式中的常量</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>cond<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         const_cond<span class="token operator">=</span> <span class="token function">make_cond_for_table</span><span class="token punctuation">(</span>cond<span class="token punctuation">,</span> join<span class="token operator">-</span><span class="token operator">></span>const_table_map<span class="token punctuation">,</span>
                                    <span class="token punctuation">(</span>table_map<span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">and_conditions</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>const_cond<span class="token punctuation">,</span> join<span class="token operator">-</span><span class="token operator">></span>best_ref<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">//3、遍历每个表，对可能的条件进行下推</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>uint i<span class="token operator">=</span>join<span class="token operator">-</span><span class="token operator">></span>const_tables <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> join<span class="token operator">-</span><span class="token operator">></span>tables <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         Item <span class="token operator">*</span>push_cond<span class="token operator">=</span> <span class="token function">make_cond_for_table</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> tab<span class="token operator">-</span><span class="token operator">></span>table_ref<span class="token operator">-</span><span class="token operator">></span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>tab<span class="token operator">-</span><span class="token operator">></span>table_ref<span class="token operator">-</span><span class="token operator">></span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>push_cond<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">table</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>file<span class="token operator">-</span><span class="token operator">></span><span class="token function">cond_push</span><span class="token punctuation">(</span>push_cond<span class="token punctuation">)</span><span class="token punctuation">)</span>
                tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">table</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>file<span class="token operator">-</span><span class="token operator">></span>pushed_cond<span class="token operator">=</span> push_cond<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="13-2-6、make-join-readinfo：为连接的每个表构造信息"><a href="#13-2-6、make-join-readinfo：为连接的每个表构造信息" class="headerlink" title="13.2.6、make_join_readinfo：为连接的每个表构造信息"></a>13.2.6、make_join_readinfo：为连接的每个表构造信息</h3><p>make_join_readinfo函数用于确认连接是否要排序，并建立半连接的消除重复的策略；为连接中的每个非常量表增加缓存、下推索引条件等方式的信息处理。实现代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">make_join_readinfo</span><span class="token punctuation">(</span>JOIN <span class="token operator">*</span>join<span class="token punctuation">,</span> uint no_jbuf_after<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//建立半连接重复元组消除策略</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setup_semijoin_dups_elimination</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> no_jbuf_after<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span>uint i<span class="token operator">=</span> join<span class="token operator">-</span><span class="token operator">></span>const_tables<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> join<span class="token operator">-</span><span class="token operator">></span>tables<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">use_join_cache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> JOIN_CACHE<span class="token operator">::</span>ALG_NONE<span class="token punctuation">)</span>
                  qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">init_join_cache</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化连接缓存对象</span>
          <span class="token keyword">switch</span> <span class="token punctuation">(</span>qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> JT_EQ_REF<span class="token operator">:</span>
            <span class="token keyword">case</span> JT_REF_OR_NULL<span class="token operator">:</span>
            <span class="token keyword">case</span> JT_REF<span class="token operator">:</span>
            <span class="token keyword">case</span> JT_SYSTEM<span class="token operator">:</span>
            <span class="token keyword">case</span> JT_CONST<span class="token operator">:</span>
               <span class="token comment" spellcheck="true">//如果有索引可用，直接使用索引</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-</span><span class="token operator">></span>covering_keys<span class="token punctuation">.</span><span class="token function">is_set</span><span class="token punctuation">(</span>qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                  <span class="token operator">!</span>table<span class="token operator">-</span><span class="token operator">></span>no_keyread<span class="token punctuation">)</span>
                table<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_keyread</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">else</span><span class="token comment" spellcheck="true">//下推索引条件，可以快速获取单表数据</span>
                qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">push_index_cond</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>trace_refine_table<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> JT_ALL<span class="token operator">:</span>
              join<span class="token operator">-</span><span class="token operator">></span>thd<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_status_no_index_used</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token comment" spellcheck="true">/* Fall through */</span>
            <span class="token keyword">case</span> JT_INDEX_SCAN<span class="token operator">:</span>
               <span class="token comment" spellcheck="true">//动态快速扫描</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span>use_quick <span class="token operator">==</span> QS_DYNAMIC_RANGE<span class="token punctuation">)</span>
              <span class="token punctuation">{</span>
                join<span class="token operator">-</span><span class="token operator">></span>thd<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_status_no_good_index_used</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>statistics<span class="token punctuation">)</span>
                  join<span class="token operator">-</span><span class="token operator">></span>thd<span class="token operator">-</span><span class="token operator">></span><span class="token function">inc_status_select_range_check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span> <span class="token keyword">else</span>
              <span class="token punctuation">{</span>
                  <span class="token keyword">if</span> <span class="token punctuation">(</span>statistics<span class="token punctuation">)</span>
                  <span class="token punctuation">{</span>
                      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> join<span class="token operator">-</span><span class="token operator">></span>const_tables<span class="token punctuation">)</span>
                          join<span class="token operator">-</span><span class="token operator">></span>thd<span class="token operator">-</span><span class="token operator">></span><span class="token function">inc_status_select_scan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token keyword">else</span>
                          join<span class="token operator">-</span><span class="token operator">></span>thd<span class="token operator">-</span><span class="token operator">></span><span class="token function">inc_status_select_full_join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token punctuation">}</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> JT_RANGE<span class="token operator">:</span>
            <span class="token keyword">case</span> JT_INDEX_MERGE<span class="token operator">:</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>statistics<span class="token punctuation">)</span>
              <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> join<span class="token operator">-</span><span class="token operator">></span>const_tables<span class="token punctuation">)</span>
                  join<span class="token operator">-</span><span class="token operator">></span>thd<span class="token operator">-</span><span class="token operator">></span><span class="token function">inc_status_select_range</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                  join<span class="token operator">-</span><span class="token operator">></span>thd<span class="token operator">-</span><span class="token operator">></span><span class="token function">inc_status_select_full_range_join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>table<span class="token operator">-</span><span class="token operator">></span>no_keyread <span class="token operator">&amp;&amp;</span> qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> JT_RANGE<span class="token punctuation">)</span>
              <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-</span><span class="token operator">></span>covering_keys<span class="token punctuation">.</span><span class="token function">is_set</span><span class="token punctuation">(</span>qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">quick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                  <span class="token function">DBUG_ASSERT</span><span class="token punctuation">(</span>qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">quick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>index <span class="token operator">!=</span> MAX_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  table<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_keyread</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>table<span class="token operator">-</span><span class="token operator">></span>key_read<span class="token punctuation">)</span>
                  qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">push_index_cond</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">quick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>index<span class="token punctuation">,</span>
                                           <span class="token operator">&amp;</span>trace_refine_table<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>filter_effect <span class="token operator">!=</span> COND_FILTER_STALE_NO_CONST<span class="token punctuation">)</span>
              <span class="token punctuation">{</span>
                <span class="token keyword">double</span> rows_w_const_cond<span class="token operator">=</span> qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>rows_fetched<span class="token punctuation">;</span>
                qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>rows_fetched<span class="token operator">=</span> <span class="token function">rows2double</span><span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">quick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>records<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>filter_effect <span class="token operator">!=</span> COND_FILTER_STALE<span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                  <span class="token comment" spellcheck="true">// Constant condition moves to filter_effect:</span>
                  <span class="token keyword">if</span> <span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>rows_fetched <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// avoid division by zero</span>
                    tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>filter_effect<span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>
                  <span class="token keyword">else</span>
                    tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>filter_effect<span class="token operator">*</span><span class="token operator">=</span>
                      <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">></span><span class="token punctuation">(</span>rows_w_const_cond<span class="token operator">/</span>tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>rows_fetched<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> JT_FT<span class="token operator">:</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">fts_index_access</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token punctuation">{</span>
                table<span class="token operator">-</span><span class="token operator">></span><span class="token function">set_keyread</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                table<span class="token operator">-</span><span class="token operator">></span>covering_keys<span class="token punctuation">.</span><span class="token function">set_bit</span><span class="token punctuation">(</span>tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">ft_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span>
              <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
              <span class="token function">DBUG_PRINT</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"Table type %d found"</span><span class="token punctuation">,</span>qep_tab<span class="token operator">-</span><span class="token operator">></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* purecov: deadcode */</span>
              <span class="token function">DBUG_ASSERT</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">/* purecov: deadcode */</span>
           <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="13-2-7、JOIN-exec：执行查询执行计划"><a href="#13-2-7、JOIN-exec：执行查询执行计划" class="headerlink" title="13.2.7、JOIN::exec：执行查询执行计划"></a>13.2.7、JOIN::exec：执行查询执行计划</h3><p>JOIN::exec函数根据查询执行计划，完成SQL语句的执行。实现如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> JOIN<span class="token operator">::</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//准备连接结果</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">prepare_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        DBUG_VOID_RETURN<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    query_result<span class="token operator">-</span><span class="token operator">></span><span class="token function">send_result_set_metadata</span><span class="token punctuation">(</span><span class="token operator">*</span>fields<span class="token punctuation">,</span>Protocol<span class="token operator">::</span>SEND_NUM_ROWS <span class="token operator">|</span> Protocol<span class="token operator">::</span>SEND_EOF<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//完成执行</span>
      error<span class="token operator">=</span> <span class="token function">do_select</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="13-3、代价估算"><a href="#13-3、代价估算" class="headerlink" title="13.3、代价估算"></a>13.3、代价估算</h2><p>MySQL代价估算属于物理优化的范畴，是比较多表连接路径优劣的重要依据，计算的过程依赖统计模块提供的统计信息。</p>
<h3 id="13-3-1、查询代价估算模型"><a href="#13-3-1、查询代价估算模型" class="headerlink" title="13.3.1、查询代价估算模型"></a>13.3.1、查询代价估算模型</h3><p>MySQL使用代价估算公式 Cost = io_cost + cpu_cost + import_cost，对单个对象的某种扫描方式的花费进行了计算，整体上考虑IO，CPU和远程操作代价。</p>
<p>MySQL认为，多表连接找出每个表的最小花费就能得到最终连接的最小花费。因为多个表之间按照一定规则排好序（常量表在前，其他表按照元组数从小到大排序）。因此，MySQL代价估算的重点，在于单表扫描的花费（best_access_path）。</p>
<p>单表扫描分为索引扫描和全表扫描。对于全表扫描，主要涉及CPU和IO花费（计算公式为：所有元组 * 每个元组CPU花费 + 所有元组 * 每个元组IO花费）；</p>
<p>对于索引扫描，分解点有两个，一个是比较符，一个是索引类型。比较符分为等值比较（操作符为=或者IN）和范围比较（操作符为&lt;, &gt;, BETWEEN等）；索引类型根据是否唯一等情况进行划分。</p>
<p>因此MySQL的代价估算重点应该是<strong>计算基于索引的单表扫描在范围操作符作用下IO和CPU的花费。（best_access_path函数，还没细看）</strong></p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210519173443006.png" alt="image-20210519173443006"></p>
<h3 id="13-3-2、查询代价估算过程"><a href="#13-3-2、查询代价估算过程" class="headerlink" title="13.3.2、查询代价估算过程"></a>13.3.2、查询代价估算过程</h3><p>MySQL的查询优化器，代价估算分为以下两个阶段：</p>
<ul>
<li>多表连接阶段：依据代价估算模型，求解最优的连接顺序</li>
<li>多表连接之后：对连接树上的每个表进行进一步计算，找出每个表的最优访问方式</li>
</ul>
<h4 id="13-3-2-1、多表连接阶段代价估算过程"><a href="#13-3-2-1、多表连接阶段代价估算过程" class="headerlink" title="13.3.2.1、多表连接阶段代价估算过程"></a>13.3.2.1、多表连接阶段代价估算过程</h4><p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210519175100027.png" alt="image-20210519175100027"></p>
<h4 id="13-3-2-2、多表连接之后局部代价估算过程"><a href="#13-3-2-2、多表连接之后局部代价估算过程" class="headerlink" title="13.3.2.2、多表连接之后局部代价估算过程"></a>13.3.2.2、多表连接之后局部代价估算过程</h4><p>多表连接阶段已经确定了多表的连接顺序，查询执行计划基本完成。但是对部分表的扫描还可以优化，重新确认扫描方式。这个是在make_join_select函数查询优化器阶段后期。需要重新扫描的情况有如下两种：</p>
<p>第一种情况：</p>
<ul>
<li>存在使得范围优化器可用的条件</li>
<li>在一个或多个索引上存在非常量条件</li>
<li>部分非常量的列被读取过</li>
</ul>
<p>第二种情况：</p>
<ul>
<li>条件仅依赖常量</li>
<li>第一个非常量表</li>
<li>语句中含有LIMIT子句使得多表连接时对表的函数估算不正确</li>
<li>查询没有使用FOUND_ROWS()方式执行（SQL中指定了SQL_CALC_FOUND_ROWS）</li>
</ul>
<p>多表连接之后，通过调用make_join_select函数对满足上述情况的部分表重新扫描计算其花费，找出最优的。此时是对已经确定执行顺序的查询执行计划做进一步的局部优化，如下图：</p>
<p><img src="https://zhangqu-oss.oss-cn-zhangjiakou.aliyuncs.com/img/image-20210519180752524.png" alt="image-20210519180752524"></p>
<h3 id="13-3-3、其他的代价估算"><a href="#13-3-3、其他的代价估算" class="headerlink" title="13.3.3、其他的代价估算"></a>13.3.3、其他的代价估算</h3><h4 id="13-3-3-1、check-quick-select：计算基于索引做范围扫描的代价"><a href="#13-3-3-1、check-quick-select：计算基于索引做范围扫描的代价" class="headerlink" title="13.3.3.1、check_quick_select：计算基于索引做范围扫描的代价"></a>13.3.3.1、check_quick_select：计算基于索引做范围扫描的代价</h4><p>check_quick_select函数用于依据给定的索引（参数tree上的idx位置）做范围扫描，计算所能获得的元组个数和花费等。实现代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span>
ha_rows <span class="token function">check_quick_select</span><span class="token punctuation">(</span>PARAM <span class="token operator">*</span>param<span class="token punctuation">,</span> uint idx<span class="token punctuation">,</span> <span class="token keyword">bool</span> index_only<span class="token punctuation">,</span>
                           SEL_ARG <span class="token operator">*</span>tree<span class="token punctuation">,</span> <span class="token keyword">bool</span> update_tbl_stats<span class="token punctuation">,</span> 
           
                           uint <span class="token operator">*</span>mrr_flags<span class="token punctuation">,</span> uint <span class="token operator">*</span>bufsize<span class="token punctuation">,</span> Cost_estimate <span class="token operator">*</span>cost<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//传递信息到seq，通过seq把check_quick_select的参数传到multi_range_read_info_const函数里</span>
    seq<span class="token punctuation">.</span>keyno<span class="token operator">=</span> idx<span class="token punctuation">;</span>
    seq<span class="token punctuation">.</span>real_keyno<span class="token operator">=</span> keynr<span class="token punctuation">;</span>
    seq<span class="token punctuation">.</span>start<span class="token operator">=</span> tree<span class="token punctuation">;</span> 
    <span class="token comment" spellcheck="true">//确定是使用索引的统计信息（index statistics）还是索引的精确信息（index dives）</span>
    param<span class="token operator">-</span><span class="token operator">></span>use_index_statistics<span class="token operator">=</span> 
    <span class="token function">eq_ranges_exceeds_limit</span><span class="token punctuation">(</span>tree<span class="token punctuation">,</span> <span class="token operator">&amp;</span>range_count<span class="token punctuation">,</span> 
                            param<span class="token operator">-</span><span class="token operator">></span>thd<span class="token operator">-</span><span class="token operator">></span>variables<span class="token punctuation">.</span>eq_range_index_dive_limit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//基于ROR进行扫描</span>
    param<span class="token operator">-</span><span class="token operator">></span>is_ror_scan<span class="token operator">=</span> TRUE<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/*
    HA_KEY_SCAN_NOT_ROR表示哈希索引扫描不能返回按rowid有序的记录
    */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-</span><span class="token operator">></span><span class="token function">index_flags</span><span class="token punctuation">(</span>keynr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> TRUE<span class="token punctuation">)</span> <span class="token operator">&amp;</span> HA_KEY_SCAN_NOT_ROR<span class="token punctuation">)</span>
        param<span class="token operator">-</span><span class="token operator">></span>is_ror_scan<span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//对索引的扫描利用MRR方式（优化外存的读取，使得批量读取的读取位置有序，保障磁盘磁头不是无序运动）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>param<span class="token operator">-</span><span class="token operator">></span>order_direction <span class="token operator">!=</span> ORDER<span class="token operator">::</span>ORDER_NOT_RELEVANT<span class="token punctuation">)</span>
        <span class="token operator">*</span>mrr_flags<span class="token operator">|</span><span class="token operator">=</span> HA_MRR_SORTED<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment" spellcheck="true">//根据索引利用MRR技术，获取行数、花费等信息</span>
    rows<span class="token operator">=</span> file<span class="token operator">-</span><span class="token operator">></span><span class="token function">multi_range_read_info_const</span><span class="token punctuation">(</span>keynr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>seq_if<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>seq<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bufsize<span class="token punctuation">,</span> mrr_flags<span class="token punctuation">,</span> cost<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="13-3-3-2、test-quick-select：快速获取数据方式的代价计算"><a href="#13-3-3-2、test-quick-select：快速获取数据方式的代价计算" class="headerlink" title="13.3.3.2、test_quick_select：快速获取数据方式的代价计算"></a>13.3.3.2、test_quick_select：快速获取数据方式的代价计算</h4><p>test_quick_select函数为MySQL获取数据提供了一种快速获取数据的方式，方便MySQL判断表上的数据量。实现代码如下：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">test_quick_select</span><span class="token punctuation">(</span>THD <span class="token operator">*</span>thd<span class="token punctuation">,</span> key_map keys_to_use<span class="token punctuation">,</span>
                      table_map prev_tables<span class="token punctuation">,</span>
                      ha_rows limit<span class="token punctuation">,</span> <span class="token keyword">bool</span> force_quick_range<span class="token punctuation">,</span>
                      <span class="token keyword">const</span> ORDER<span class="token operator">::</span>enum_order interesting_order<span class="token punctuation">,</span>
                      <span class="token keyword">const</span> QEP_shared_owner <span class="token operator">*</span>tab<span class="token punctuation">,</span>
                      Item <span class="token operator">*</span>cond<span class="token punctuation">,</span>
                      key_map <span class="token operator">*</span>needed_reg<span class="token punctuation">,</span>
                      QUICK_SELECT_I <span class="token operator">*</span><span class="token operator">*</span>quick<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//初始的代价计算</span>
     <span class="token keyword">double</span> scan_time<span class="token operator">=</span>cost_model<span class="token operator">-</span><span class="token operator">></span><span class="token function">row_evaluate_cost</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>records<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
      Cost_estimate cost_est<span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span>file<span class="token operator">-</span><span class="token operator">></span><span class="token function">table_scan_cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      cost_est<span class="token punctuation">.</span><span class="token function">add_io</span><span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      cost_est<span class="token punctuation">.</span><span class="token function">add_cpu</span><span class="token punctuation">(</span>scan_time<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>force_index<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        scan_time<span class="token operator">=</span> DBL_MAX<span class="token punctuation">;</span>
        cost_est<span class="token punctuation">.</span><span class="token function">set_max_cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>limit <span class="token operator">&lt;</span> records<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        cost_est<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// Force to use index</span>
        cost_est<span class="token punctuation">.</span><span class="token function">add_io</span><span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span><span class="token function">cost_model</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">page_read_cost</span><span class="token punctuation">(</span>
          <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>records<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cost_est<span class="token punctuation">.</span><span class="token function">add_cpu</span><span class="token punctuation">(</span>scan_time<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cost_est<span class="token punctuation">.</span><span class="token function">total_cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">2.0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>force_quick_range<span class="token punctuation">)</span>
        <span class="token function">DBUG_RETURN</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* No need for quick select */</span>     
    <span class="token comment" spellcheck="true">//根据只读索引计算扫描花费，不用读取表数据即可完成，因此单独计算</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token operator">-</span><span class="token operator">></span>covering_keys<span class="token punctuation">.</span><span class="token function">is_clear_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">int</span> key_for_use<span class="token operator">=</span> <span class="token function">find_shortest_key</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token operator">&amp;</span>head<span class="token operator">-</span><span class="token operator">></span>covering_keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
      Cost_estimate key_read_time<span class="token operator">=</span>
        param<span class="token punctuation">.</span>table<span class="token operator">-</span><span class="token operator">></span>file<span class="token operator">-</span><span class="token operator">></span><span class="token function">index_scan_cost</span><span class="token punctuation">(</span>key_for_use<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
                                           <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>records<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      key_read_time<span class="token punctuation">.</span><span class="token function">add_cpu</span><span class="token punctuation">(</span>cost_model<span class="token operator">-</span><span class="token operator">></span><span class="token function">row_evaluate_cost</span><span class="token punctuation">(</span>
        <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token punctuation">(</span>records<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">bool</span> chosen<span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key_read_time <span class="token operator">&lt;</span> cost_est<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        cost_est<span class="token operator">=</span> key_read_time<span class="token punctuation">;</span>
        chosen<span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//计算单表上带有MIN/MAX聚合函数的分组操作花费</span>
    group_trp<span class="token operator">=</span> <span class="token function">get_best_group_min_max</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>param<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> <span class="token operator">&amp;</span>best_cost<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>group_trp<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      param<span class="token punctuation">.</span>table<span class="token operator">-</span><span class="token operator">></span>quick_condition_rows<span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>group_trp<span class="token operator">-</span><span class="token operator">></span>records<span class="token punctuation">,</span>
                                             head<span class="token operator">-</span><span class="token operator">></span>file<span class="token operator">-</span><span class="token operator">></span>stats<span class="token punctuation">.</span>records<span class="token punctuation">)</span><span class="token punctuation">;</span>
      Opt_trace_object <span class="token function">grp_summary</span><span class="token punctuation">(</span>trace<span class="token punctuation">,</span>
                                   <span class="token string">"best_group_range_summary"</span><span class="token punctuation">,</span>
                                   Opt_trace_context<span class="token operator">::</span>RANGE_OPTIMIZER<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>trace<span class="token operator">-</span><span class="token operator">></span><span class="token function">is_started</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        group_trp<span class="token operator">-</span><span class="token operator">></span><span class="token function">trace_basic_info</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>param<span class="token punctuation">,</span> <span class="token operator">&amp;</span>grp_summary<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>group_trp<span class="token operator">-</span><span class="token operator">></span>cost_est <span class="token operator">&lt;</span> best_cost<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        grp_summary<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"chosen"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        best_trp<span class="token operator">=</span> group_trp<span class="token punctuation">;</span>
        best_cost<span class="token operator">=</span> best_trp<span class="token operator">-</span><span class="token operator">></span>cost_est<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">else</span>
        grp_summary<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"chosen"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add_alnum</span><span class="token punctuation">(</span><span class="token string">"cause"</span><span class="token punctuation">,</span> <span class="token string">"cost"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
     <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//基于索引做范围扫描的最优花费</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>range_trp<span class="token operator">=</span> <span class="token function">get_key_scans_params</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>param<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> FALSE<span class="token punctuation">,</span> TRUE<span class="token punctuation">,</span>
                                             <span class="token operator">&amp;</span>best_cost<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          best_trp<span class="token operator">=</span> range_trp<span class="token punctuation">;</span>
          best_cost<span class="token operator">=</span> best_trp<span class="token operator">-</span><span class="token operator">></span>cost_est<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>thd<span class="token operator">-</span><span class="token operator">></span>lex<span class="token operator">-</span><span class="token operator">></span>sql_command <span class="token operator">!=</span> SQLCOM_DELETE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>  <span class="token comment" spellcheck="true">//非删除操作</span>
            param<span class="token punctuation">.</span>index_merge_allowed <span class="token operator">&amp;&amp;</span>
            interesting_order <span class="token operator">!=</span> ORDER<span class="token operator">::</span>ORDER_DESC<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//不支持降序</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//基于覆盖“ROR交操作”算法求解非覆盖“ROR交操作”</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rori_trp<span class="token operator">=</span> <span class="token function">get_best_ror_intersect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>param<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> <span class="token operator">&amp;</span>best_cost<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
            best_trp<span class="token operator">=</span> rori_trp<span class="token punctuation">;</span>
            best_cost<span class="token operator">=</span> best_trp<span class="token operator">-</span><span class="token operator">></span>cost_est<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//计算基于index merge的ROR-UNION操作的花费</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tree<span class="token operator">-</span><span class="token operator">></span>merges<span class="token punctuation">.</span><span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>param<span class="token punctuation">.</span>index_merge_allowed <span class="token operator">&amp;&amp;</span>
            interesting_order <span class="token operator">!=</span> ORDER<span class="token operator">::</span>ORDER_DESC <span class="token operator">&amp;&amp;</span>
            param<span class="token punctuation">.</span>table<span class="token operator">-</span><span class="token operator">></span>file<span class="token operator">-</span><span class="token operator">></span>stats<span class="token punctuation">.</span>records<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>imerge<span class="token operator">=</span> it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
            new_conj_trp<span class="token operator">=</span> <span class="token function">get_best_disjunct_quick</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>param<span class="token punctuation">,</span> imerge<span class="token punctuation">,</span>
                                                  <span class="token operator">&amp;</span>best_cost<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>new_conj_trp<span class="token punctuation">)</span>
              <span class="token function">set_if_smaller</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span>table<span class="token operator">-</span><span class="token operator">></span>quick_condition_rows<span class="token punctuation">,</span>
                             new_conj_trp<span class="token operator">-</span><span class="token operator">></span>records<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>best_conj_trp <span class="token operator">||</span>
                <span class="token punctuation">(</span>new_conj_trp <span class="token operator">&amp;&amp;</span>
                 new_conj_trp<span class="token operator">-</span><span class="token operator">></span>cost_est <span class="token operator">&lt;</span> best_conj_trp<span class="token operator">-</span><span class="token operator">></span>cost_est<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
              best_conj_trp<span class="token operator">=</span> new_conj_trp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>best_conj_trp<span class="token punctuation">)</span>
            best_trp<span class="token operator">=</span> best_conj_trp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《20210520》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/05/19/20210520/" property="cc:attributionName"
               rel="cc:attributionURL">
                JavaGuy
            </a> 采用
            <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> -->

<script>
    new Valine({
        el: '#vcomments',
        appId: 'GgssQFlBBeYrJoL1y5s8jXeR-gzGzoHsz',
        appKey: 'kXYkbr7xencqP3PxqQNKykdt',
        notify: 'true' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/05/27/20210527-1/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="20210527">
                        
                        <span class="card-title">20210527</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1、MySQL查询优化进一步学习1.1、子查询优化MySQL支持的子查询优化策略如下：

使用MySQL trace工具，跟踪优化器对SQL的整个优化执行过程。
首先建三张表，并添加索引
DROP TABLE IF EXISTS `t1`;
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-05-27
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Lab/" class="post-category" target="_blank">
                                    Lab
                                </a>
                            
                            <a href="/categories/Lab/%E5%91%A8%E4%BC%9A%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/" class="post-category" target="_blank">
                                    周会总结报告
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" target="_blank">
                        <span class="chip bg-color">子查询优化</span>
                    </a>
                    
                    <a href="/tags/%E6%9D%A1%E4%BB%B6%E5%8C%96%E7%AE%80/" target="_blank">
                        <span class="chip bg-color">条件化简</span>
                    </a>
                    
                    <a href="/tags/%E6%B6%88%E9%99%A4%E5%A4%96%E8%BF%9E%E6%8E%A5/" target="_blank">
                        <span class="chip bg-color">消除外连接</span>
                    </a>
                    
                    <a href="/tags/%E8%AF%AD%E4%B9%89%E4%BC%98%E5%8C%96/" target="_blank">
                        <span class="chip bg-color">语义优化</span>
                    </a>
                    
                    <a href="/tags/%E9%9D%9ESPJ%E4%BC%98%E5%8C%96/" target="_blank">
                        <span class="chip bg-color">非SPJ优化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/05/13/shu-ju-ku-cha-xun-you-hua-qi-de-yi-zhu-yue-du-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="数据库查询优化器的艺术阅读笔记">
                        
                        <span class="card-title">数据库查询优化器的艺术阅读笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            1、数据管理系统的查询优化1.1、数据库调优1.1.1、目标使数据库有更高的吞吐量和更短的响应时间。
1.1.2、常见调优方法
人工调优

基于案例的调优（静态）

自调优

Oracle实现的自调优技术

Redo Logfile Siz
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-05-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Lab/" class="post-category" target="_blank">
                                    Lab
                                </a>
                            
                            <a href="/categories/Lab/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-category" target="_blank">
                                    阅读笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: JavaGuy的博客<br />'
            + '作者: JavaGuy<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

<!-- <script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
<script>
    const btw = new BTWPlugin();
    btw.init({
        id: 'artDetail',
        blogId: '20962-1585405055583-879',
        name: '算法码上来',
        qrcode: 'https://godweiyang.com/medias/gzh.jpg',
        keyword: 'VIP',
    });
</script> -->

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4, h5, h6'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5, h6').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; ZhangQu. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">280.1k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/zhangqu999" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:zhang1842279380@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>





    <a href="http://wpa.qq.com/msgrd?v=3&uin=1842279380&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 1000;
        var uvcountOffset = 200;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2021, 03, 18, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    
    <script type="text/javascript" src="/libs/others/snow.js"></script>
    

</body>

</html>